<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Alchemy: src/parser/fol.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_bad0962745a374caf6e9fb10c9087375.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_3033a79d4f7a8f4cae88b9594c95e6c0.html">parser</a></div>
<h1>fol.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* A Bison parser, made by GNU Bison 2.1.  */</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="comment">/* Skeleton parser for GLR parsing with Bison,</span>
<a name="l00004"></a>00004 <span class="comment">   Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00008"></a>00008 <span class="comment">   the Free Software Foundation; either version 2, or (at your option)</span>
<a name="l00009"></a>00009 <span class="comment">   any later version.</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00012"></a>00012 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00013"></a>00013 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00014"></a>00014 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00017"></a>00017 <span class="comment">   along with this program; if not, write to the Free Software</span>
<a name="l00018"></a>00018 <span class="comment">   Foundation, Inc., 51 Franklin Street, Fifth Floor,</span>
<a name="l00019"></a>00019 <span class="comment">   Boston, MA 02110-1301, USA.  */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="comment">/* This is the parser code for GLR (Generalized LR) parser. */</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/* Identify Bison output.  */</span>
<a name="l00024"></a>00024 <span class="preprocessor">#define YYBISON 1</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span>
<a name="l00026"></a>00026 <span class="comment">/* Bison version.  */</span>
<a name="l00027"></a>00027 <span class="preprocessor">#define YYBISON_VERSION "2.1"</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a>00029 <span class="comment">/* Skeleton name.  */</span>
<a name="l00030"></a>00030 <span class="preprocessor">#define YYSKELETON_NAME "glr.c"</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>
<a name="l00032"></a>00032 <span class="comment">/* Pure parsers.  */</span>
<a name="l00033"></a>00033 <span class="preprocessor">#define YYPURE 0</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span>
<a name="l00035"></a>00035 <span class="comment">/* Using locations.  */</span>
<a name="l00036"></a>00036 <span class="preprocessor">#define YYLSP_NEEDED 0</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="comment">/* Tokens.  */</span>
<a name="l00041"></a>00041 <span class="preprocessor">#ifndef YYTOKENTYPE</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor"># define YYTOKENTYPE</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>   <span class="comment">/* Put the tokens into the symbol table, so that GDB and other debuggers</span>
<a name="l00044"></a>00044 <span class="comment">      know about them.  */</span>
<a name="l00045"></a>00045    <span class="keyword">enum</span> yytokentype {
<a name="l00046"></a>00046      ZZ_NUM = 258,
<a name="l00047"></a>00047      ZZ_DOTDOTDOT = 259,
<a name="l00048"></a>00048      ZZ_STRING = 260,
<a name="l00049"></a>00049      ZZ_EQEQ = 261,
<a name="l00050"></a>00050      ZZ_INCLUDE = 262,
<a name="l00051"></a>00051      ZZ_PREDICATE = 263,
<a name="l00052"></a>00052      ZZ_FUNCTION = 264,
<a name="l00053"></a>00053      ZZ_CONSTANT = 265,
<a name="l00054"></a>00054      ZZ_VARIABLE = 266,
<a name="l00055"></a>00055      ZZ_TYPE = 267,
<a name="l00056"></a>00056      ZZ_FORALL = 268,
<a name="l00057"></a>00057      ZZ_EXIST = 269,
<a name="l00058"></a>00058      ZZ_EQUIV = 270,
<a name="l00059"></a>00059      ZZ_IMPLY = 271
<a name="l00060"></a>00060    };
<a name="l00061"></a>00061 <span class="preprocessor">#endif</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="comment">/* Tokens.  */</span>
<a name="l00063"></a>00063 <span class="preprocessor">#define ZZ_NUM 258</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_DOTDOTDOT 259</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_STRING 260</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_EQEQ 261</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_INCLUDE 262</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_PREDICATE 263</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_FUNCTION 264</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_CONSTANT 265</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_VARIABLE 266</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_TYPE 267</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_FORALL 268</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_EXIST 269</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_EQUIV 270</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#define ZZ_IMPLY 271</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span>
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">/* Copy the first part of user declarations.  */</span>
<a name="l00082"></a>00082 <span class="preprocessor">#line 66 "../src/parser/fol.y"</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span>
<a name="l00084"></a>00084 <span class="preprocessor">#define YYSTYPE int</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#define YYDEBUG 1</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>
<a name="l00087"></a>00087 <span class="preprocessor">#include "fol.h"</span>
<a name="l00088"></a>00088 <span class="preprocessor">#include "follex.cpp"</span>
<a name="l00089"></a>00089 
<a name="l00090"></a>00090   <span class="comment">// 0: no output; 1,2: increasing order of verbosity</span>
<a name="l00091"></a>00091 <span class="keywordtype">int</span> folDbg = 0;
<a name="l00092"></a>00092 <span class="comment">//int folDbg = 1;</span>
<a name="l00093"></a>00093 <span class="comment">//int folDbg = 2;</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">/* Enabling traces.  */</span>
<a name="l00098"></a>00098 <span class="preprocessor">#ifndef YYDEBUG</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor"># define YYDEBUG 0</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span>
<a name="l00102"></a>00102 <span class="comment">/* Enabling verbose error messages.  */</span>
<a name="l00103"></a>00103 <span class="preprocessor">#ifdef YYERROR_VERBOSE</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor"># undef YYERROR_VERBOSE</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span><span class="preprocessor"># define YYERROR_VERBOSE 1</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor"># define YYERROR_VERBOSE 1</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>
<a name="l00110"></a>00110 <span class="comment">/* Enabling the token table.  */</span>
<a name="l00111"></a>00111 <span class="preprocessor">#ifndef YYTOKEN_TABLE</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span><span class="preprocessor"># define YYTOKEN_TABLE 0</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span>
<a name="l00115"></a>00115 <span class="preprocessor">#if ! defined (YYSTYPE) &amp;&amp; ! defined (YYSTYPE_IS_DECLARED)</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">int</span> YYSTYPE;
<a name="l00117"></a>00117 <span class="preprocessor"># define YYSTYPE_IS_DECLARED 1</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="preprocessor"># define YYSTYPE_IS_TRIVIAL 1</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span>
<a name="l00121"></a>00121 <span class="preprocessor">#if ! defined (YYLTYPE) &amp;&amp; ! defined (YYLTYPE_IS_DECLARED)</span>
<a name="l00122"></a><a class="code" href="structYYLTYPE.html">00122</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structYYLTYPE.html">YYLTYPE</a>
<a name="l00123"></a>00123 {
<a name="l00124"></a>00124 
<a name="l00125"></a><a class="code" href="structYYLTYPE.html#23416f288b2d6553b6757640465eb29b">00125</a>   <span class="keywordtype">char</span> <a class="code" href="structYYLTYPE.html#23416f288b2d6553b6757640465eb29b">yydummy</a>;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 } <a class="code" href="structYYLTYPE.html">YYLTYPE</a>;
<a name="l00128"></a>00128 <span class="preprocessor"># define YYLTYPE_IS_DECLARED 1</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span><span class="preprocessor"># define YYLTYPE_IS_TRIVIAL 1</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span>
<a name="l00132"></a>00132 <span class="comment">/* Default (constant) value used for initialization for null</span>
<a name="l00133"></a>00133 <span class="comment">   right-hand sides.  Unlike the standard yacc.c template,</span>
<a name="l00134"></a>00134 <span class="comment">   here we set the default value of $$ to a zeroed-out value.</span>
<a name="l00135"></a>00135 <span class="comment">   Since the default value is undefined, this behavior is</span>
<a name="l00136"></a>00136 <span class="comment">   technically correct. */</span>
<a name="l00137"></a>00137 <span class="keyword">static</span> YYSTYPE yyval_default;
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="comment">/* Copy the second part of user declarations.  */</span>
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="comment">/* Line 217 of glr.c.  */</span>
<a name="l00143"></a>00143 <span class="preprocessor">#line 144 "fol.cpp"</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span>
<a name="l00145"></a>00145 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00146"></a>00146 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00147"></a>00147 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00148"></a>00148 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="preprocessor">#ifndef YY_</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span><span class="preprocessor"># if YYENABLE_NLS</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span><span class="preprocessor">#  if ENABLE_NLS</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span><span class="preprocessor">#   include &lt;libintl.h&gt;</span> <span class="comment">/* INFRINGES ON USER NAME SPACE */</span>
<a name="l00154"></a>00154 <span class="preprocessor">#   define YY_(msgid) dgettext ("bison-runtime", msgid)</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span><span class="preprocessor"># ifndef YY_</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span><span class="preprocessor">#  define YY_(msgid) msgid</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span>
<a name="l00162"></a>00162 <span class="preprocessor">#ifndef YYFREE</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span><span class="preprocessor"># define YYFREE free</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span><span class="preprocessor">#ifndef YYMALLOC</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span><span class="preprocessor"># define YYMALLOC malloc</span>
<a name="l00167"></a>00167 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span><span class="preprocessor">#ifndef YYREALLOC</span>
<a name="l00169"></a>00169 <span class="preprocessor"></span><span class="preprocessor"># define YYREALLOC realloc</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span>
<a name="l00172"></a>00172 <span class="preprocessor">#define YYSIZEMAX ((size_t) -1)</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span>
<a name="l00174"></a>00174 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span>   <span class="keyword">typedef</span> <span class="keywordtype">bool</span> yybool;
<a name="l00176"></a>00176 <span class="preprocessor">#else</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span>   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> yybool;
<a name="l00178"></a>00178 <span class="preprocessor">#endif</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span><span class="preprocessor">#define yytrue 1</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span><span class="preprocessor">#define yyfalse 0</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span>
<a name="l00182"></a>00182 <span class="preprocessor">#ifndef YYSETJMP</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span><span class="preprocessor"># include &lt;setjmp.h&gt;</span>
<a name="l00184"></a>00184 <span class="preprocessor"># define YYJMP_BUF jmp_buf</span>
<a name="l00185"></a>00185 <span class="preprocessor"></span><span class="preprocessor"># define YYSETJMP(env) setjmp (env)</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span><span class="preprocessor"># define YYLONGJMP(env, val) longjmp (env, val)</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00188"></a>00188 <span class="preprocessor"></span>
<a name="l00189"></a>00189 <span class="comment">/*-----------------.</span>
<a name="l00190"></a>00190 <span class="comment">| GCC extensions.  |</span>
<a name="l00191"></a>00191 <span class="comment">`-----------------*/</span>
<a name="l00192"></a>00192 
<a name="l00193"></a>00193 <span class="preprocessor">#ifndef __attribute__</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span><span class="comment">/* This feature is available in gcc versions 2.5 and later.  */</span>
<a name="l00195"></a>00195 <span class="preprocessor"># if (!defined (__GNUC__) || __GNUC__ &lt; 2 \</span>
<a name="l00196"></a>00196 <span class="preprocessor">      || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &lt; 5) || __STRICT_ANSI__)</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span><span class="preprocessor">#  define __attribute__(Spec) </span><span class="comment">/* empty */</span>
<a name="l00198"></a>00198 <span class="preprocessor"># endif</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span>
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00203"></a>00203 <span class="preprocessor"></span><span class="preprocessor"># define YYOPTIONAL_LOC(Name) </span><span class="comment">/* empty */</span>
<a name="l00204"></a>00204 <span class="preprocessor">#else</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span><span class="preprocessor"># define YYOPTIONAL_LOC(Name) Name __attribute__ ((__unused__))</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00207"></a>00207 <span class="preprocessor"></span>
<a name="l00208"></a>00208 <span class="preprocessor">#ifndef YYASSERT</span>
<a name="l00209"></a>00209 <span class="preprocessor"></span><span class="preprocessor"># define YYASSERT(condition) ((void) ((condition) || (abort (), 0)))</span>
<a name="l00210"></a>00210 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00211"></a>00211 <span class="preprocessor"></span>
<a name="l00212"></a>00212 <span class="comment">/* YYFINAL -- State number of the termination state. */</span>
<a name="l00213"></a>00213 <span class="preprocessor">#define YYFINAL  2</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span><span class="comment">/* YYLAST -- Last index in YYTABLE.  */</span>
<a name="l00215"></a>00215 <span class="preprocessor">#define YYLAST   205</span>
<a name="l00216"></a>00216 <span class="preprocessor"></span>
<a name="l00217"></a>00217 <span class="comment">/* YYNTOKENS -- Number of terminals. */</span>
<a name="l00218"></a>00218 <span class="preprocessor">#define YYNTOKENS  38</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span><span class="comment">/* YYNNTS -- Number of nonterminals. */</span>
<a name="l00220"></a>00220 <span class="preprocessor">#define YYNNTS  86</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span><span class="comment">/* YYNRULES -- Number of rules. */</span>
<a name="l00222"></a>00222 <span class="preprocessor">#define YYNRULES  154</span>
<a name="l00223"></a>00223 <span class="preprocessor"></span><span class="comment">/* YYNRULES -- Number of states. */</span>
<a name="l00224"></a>00224 <span class="preprocessor">#define YYNSTATES  215</span>
<a name="l00225"></a>00225 <span class="preprocessor"></span><span class="comment">/* YYMAXRHS -- Maximum number of symbols on right-hand side of rule. */</span>
<a name="l00226"></a>00226 <span class="preprocessor">#define YYMAXRHS 10</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span><span class="comment">/* YYMAXLEFT -- Maximum number of symbols to the left of a handle</span>
<a name="l00228"></a>00228 <span class="comment">   accessed by $0, $-1, etc., in any rule. */</span>
<a name="l00229"></a>00229 <span class="preprocessor">#define YYMAXLEFT 0</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span>
<a name="l00231"></a>00231 <span class="comment">/* YYTRANSLATE(X) -- Bison symbol number corresponding to X.  */</span>
<a name="l00232"></a>00232 <span class="preprocessor">#define YYUNDEFTOK  2</span>
<a name="l00233"></a>00233 <span class="preprocessor"></span><span class="preprocessor">#define YYMAXUTOK   271</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span>
<a name="l00235"></a>00235 <span class="preprocessor">#define YYTRANSLATE(YYX)                                                \</span>
<a name="l00236"></a>00236 <span class="preprocessor">  ((YYX &lt;= 0) ? YYEOF :                                                 \</span>
<a name="l00237"></a>00237 <span class="preprocessor">   (unsigned int) (YYX) &lt;= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)</span>
<a name="l00238"></a>00238 <span class="preprocessor"></span>
<a name="l00239"></a>00239 <span class="comment">/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */</span>
<a name="l00240"></a>00240 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> yytranslate[] =
<a name="l00241"></a>00241 {
<a name="l00242"></a>00242        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00243"></a>00243       25,     2,     2,    28,     2,     2,     2,     2,     2,     2,
<a name="l00244"></a>00244        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00245"></a>00245        2,     2,     2,    21,     2,     2,     2,    24,     2,     2,
<a name="l00246"></a>00246       33,    34,    22,    14,    32,    13,    27,    23,     2,     2,
<a name="l00247"></a>00247        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00248"></a>00248       37,    29,    36,    35,    26,     2,     2,     2,     2,     2,
<a name="l00249"></a>00249        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00250"></a>00250        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00251"></a>00251        2,     2,     2,     2,    20,     2,     2,     2,     2,     2,
<a name="l00252"></a>00252        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00253"></a>00253        2,     2,     2,     2,     2,     2,     2,     2,    19,     2,
<a name="l00254"></a>00254        2,     2,     2,    30,     2,    31,     2,     2,     2,     2,
<a name="l00255"></a>00255        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00256"></a>00256        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00257"></a>00257        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00258"></a>00258        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00259"></a>00259        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00260"></a>00260        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00261"></a>00261        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00262"></a>00262        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00263"></a>00263        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00264"></a>00264        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00265"></a>00265        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00266"></a>00266        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
<a name="l00267"></a>00267        2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
<a name="l00268"></a>00268        5,     6,     7,     8,     9,    10,    11,    12,    15,    16,
<a name="l00269"></a>00269       17,    18
<a name="l00270"></a>00270 };
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="preprocessor">#if YYDEBUG</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span><span class="comment">/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in</span>
<a name="l00274"></a>00274 <span class="comment">   YYRHS.  */</span>
<a name="l00275"></a>00275 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yyprhs[] =
<a name="l00276"></a>00276 {
<a name="l00277"></a>00277        0,     0,     3,     4,     8,    11,    14,    18,    22,    26,
<a name="l00278"></a>00278       30,    35,    39,    43,    44,    45,    46,    55,    57,    60,
<a name="l00279"></a>00279       61,    63,    65,    67,    68,    70,    72,    76,    78,    80,
<a name="l00280"></a>00280       81,    88,    90,    92,    93,    94,    99,   101,   103,   105,
<a name="l00281"></a>00281      106,   108,   112,   115,   118,   119,   120,   121,   132,   136,
<a name="l00282"></a>00282      138,   139,   144,   146,   148,   149,   150,   151,   159,   160,
<a name="l00283"></a>00283      161,   162,   171,   173,   175,   176,   181,   182,   187,   189,
<a name="l00284"></a>00284      191,   193,   195,   196,   198,   200,   201,   202,   209,   210,
<a name="l00285"></a>00285      211,   212,   222,   224,   228,   230,   232,   234,   236,   238,
<a name="l00286"></a>00286      240,   242,   244,   245,   247,   248,   253,   254,   257,   258,
<a name="l00287"></a>00287      264,   265,   271,   272,   278,   279,   285,   286,   287,   288,
<a name="l00288"></a>00288      295,   296,   300,   302,   304,   305,   306,   312,   314,   316,
<a name="l00289"></a>00289      317,   318,   326,   327,   328,   334,   336,   338,   341,   344,
<a name="l00290"></a>00290      346,   347,   349,   350,   355,   357,   359,   361,   363,   365,
<a name="l00291"></a>00291      368,   372,   373,   375,   376,   377,   384,   385,   386,   387,
<a name="l00292"></a>00292      396,   398,   400,   402,   404
<a name="l00293"></a>00293 };
<a name="l00294"></a>00294 
<a name="l00295"></a>00295 <span class="comment">/* YYRHS -- A `-1'-separated list of the rules' RHS. */</span>
<a name="l00296"></a>00296 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span> yyrhs[] =
<a name="l00297"></a>00297 {
<a name="l00298"></a>00298       39,     0,    -1,    -1,    39,     1,    25,    -1,    39,    45,
<a name="l00299"></a>00299       -1,    39,    47,    -1,    39,    49,    45,    -1,    39,    56,
<a name="l00300"></a>00300       45,    -1,    39,    64,    45,    -1,    39,    68,    45,    -1,
<a name="l00301"></a>00301       39,    43,    78,    79,    -1,    39,    43,    82,    -1,    39,
<a name="l00302"></a>00302       43,    45,    -1,    -1,    -1,    -1,    39,    40,    89,    41,
<a name="l00303"></a>00303       90,    44,    42,    45,    -1,    26,    -1,    43,    26,    -1,
<a name="l00304"></a>00304       -1,    27,    -1,    25,    -1,    28,    -1,    -1,    25,    -1,
<a name="l00305"></a>00305       28,    -1,     7,     5,    48,    -1,    25,    -1,    28,    -1,
<a name="l00306"></a>00306       -1,    51,    29,    30,    50,    52,    31,    -1,    11,    -1,
<a name="l00307"></a>00307       12,    -1,    -1,    -1,    52,    55,    53,    54,    -1,    11,
<a name="l00308"></a>00308       -1,     5,    -1,    10,    -1,    -1,    32,    -1,    25,    32,
<a name="l00309"></a>00309       25,    -1,    25,    32,    -1,    32,    25,    -1,    -1,    -1,
<a name="l00310"></a>00310       -1,    51,    29,    30,    57,     3,    58,    32,    59,    60,
<a name="l00311"></a>00311       31,    -1,     4,    32,     3,    -1,    61,    -1,    -1,    63,
<a name="l00312"></a>00312       32,    62,    61,    -1,    63,    -1,     3,    -1,    -1,    -1,
<a name="l00313"></a>00313       -1,    11,    65,    33,    66,    73,    67,    34,    -1,    -1,
<a name="l00314"></a>00314       -1,    -1,    72,    69,    11,    70,    33,    71,    73,    34,
<a name="l00315"></a>00315       -1,    12,    -1,    11,    -1,    -1,    73,    32,    74,    76,
<a name="l00316"></a>00316       -1,    -1,    73,    32,    75,    77,    -1,    76,    -1,    77,
<a name="l00317"></a>00317       -1,    12,    -1,    11,    -1,    -1,    21,    -1,    35,    -1,
<a name="l00318"></a>00318       -1,    -1,     8,    80,    33,    81,    86,    34,    -1,    -1,
<a name="l00319"></a>00319       -1,    -1,    88,    29,    83,     9,    84,    33,    85,    86,
<a name="l00320"></a>00320       34,    -1,    87,    -1,    86,    55,    87,    -1,    10,    -1,
<a name="l00321"></a>00321        5,    -1,     3,    -1,    11,    -1,    10,    -1,     5,    -1,
<a name="l00322"></a>00322        3,    -1,    11,    -1,    -1,     3,    -1,    -1,    33,    91,
<a name="l00323"></a>00323       90,    34,    -1,    -1,    92,   106,    -1,    -1,    90,    18,
<a name="l00324"></a>00324       93,    46,    90,    -1,    -1,    90,    17,    94,    46,    90,
<a name="l00325"></a>00325       -1,    -1,    90,    19,    95,    46,    90,    -1,    -1,    90,
<a name="l00326"></a>00326       20,    96,    46,    90,    -1,    -1,    -1,    -1,    97,   101,
<a name="l00327"></a>00327       98,   102,    99,    90,    -1,    -1,    21,   100,    90,    -1,
<a name="l00328"></a>00328       15,    -1,    16,    -1,    -1,    -1,   103,   105,    32,   104,
<a name="l00329"></a>00329      102,    -1,   105,    -1,    11,    -1,    -1,    -1,   112,     8,
<a name="l00330"></a>00330      107,    33,   108,   113,    34,    -1,    -1,    -1,   109,   115,
<a name="l00331"></a>00331      111,   110,   115,    -1,    36,    -1,    37,    -1,    36,    29,
<a name="l00332"></a>00332       -1,    37,    29,    -1,    29,    -1,    -1,    22,    -1,    -1,
<a name="l00333"></a>00333      113,    32,   114,   115,    -1,   115,    -1,   117,    -1,    10,
<a name="l00334"></a>00334       -1,     5,    -1,     3,    -1,   116,    11,    -1,   116,    11,
<a name="l00335"></a>00335       21,    -1,    -1,    14,    -1,    -1,    -1,     9,   118,    33,
<a name="l00336"></a>00336      119,   113,    34,    -1,    -1,    -1,    -1,   120,    33,   121,
<a name="l00337"></a>00337      115,   123,   122,   115,    34,    -1,    14,    -1,    13,    -1,
<a name="l00338"></a>00338       22,    -1,    23,    -1,    24,    -1
<a name="l00339"></a>00339 };
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 <span class="comment">/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */</span>
<a name="l00342"></a>00342 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yyrline[] =
<a name="l00343"></a>00343 {
<a name="l00344"></a>00344        0,   114,   114,   116,   127,   128,   129,   130,   131,   132,
<a name="l00345"></a>00345      133,   135,   137,   141,   146,   151,   140,   209,   210,   213,
<a name="l00346"></a>00346      216,   226,   228,   231,   234,   236,   242,   305,   307,   318,
<a name="l00347"></a>00347      316,   336,   349,   364,   369,   368,   389,   389,   389,   394,
<a name="l00348"></a>00348      397,   399,   406,   412,   423,   429,   456,   421,   467,   504,
<a name="l00349"></a>00349      511,   509,   518,   521,   558,   570,   571,   557,   591,   614,
<a name="l00350"></a>00350      639,   590,   668,   668,   674,   673,   678,   677,   680,   681,
<a name="l00351"></a>00351      685,   698,   717,   720,   726,   738,   751,   737,   795,   801,
<a name="l00352"></a>00352      846,   793,   891,   899,   909,   910,   916,   925,   933,   942,
<a name="l00353"></a>00353      954,   963,   978,   981,   996,   995,  1010,  1010,  1014,  1013,
<a name="l00354"></a>00354     1026,  1025,  1038,  1037,  1049,  1048,  1060,  1062,  1068,  1060,
<a name="l00355"></a>00355     1079,  1078,  1094,  1102,  1115,  1117,  1115,  1124,  1128,  1155,
<a name="l00356"></a>00356     1185,  1154,  1342,  1361,  1342,  1518,  1532,  1546,  1563,  1580,
<a name="l00357"></a>00357     1595,  1597,  1615,  1613,  1625,  1653,  1844,  1854,  1866,  1881,
<a name="l00358"></a>00358     1887,  1911,  1913,  1925,  1961,  1924,  2043,  2059,  2064,  2043,
<a name="l00359"></a>00359     2148,  2157,  2166,  2175,  2184
<a name="l00360"></a>00360 };
<a name="l00361"></a>00361 <span class="preprocessor">#endif</span>
<a name="l00362"></a>00362 <span class="preprocessor"></span>
<a name="l00363"></a>00363 <span class="preprocessor">#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE</span>
<a name="l00364"></a>00364 <span class="preprocessor"></span><span class="comment">/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.</span>
<a name="l00365"></a>00365 <span class="comment">   First, the terminals, then, starting at YYNTOKENS, nonterminals. */</span>
<a name="l00366"></a>00366 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> yytname[] =
<a name="l00367"></a>00367 {
<a name="l00368"></a>00368   <span class="stringliteral">"$end"</span>, <span class="stringliteral">"error"</span>, <span class="stringliteral">"$undefined"</span>, <span class="stringliteral">"ZZ_NUM"</span>, <span class="stringliteral">"ZZ_DOTDOTDOT"</span>, <span class="stringliteral">"ZZ_STRING"</span>,
<a name="l00369"></a>00369   <span class="stringliteral">"ZZ_EQEQ"</span>, <span class="stringliteral">"ZZ_INCLUDE"</span>, <span class="stringliteral">"ZZ_PREDICATE"</span>, <span class="stringliteral">"ZZ_FUNCTION"</span>, <span class="stringliteral">"ZZ_CONSTANT"</span>,
<a name="l00370"></a>00370   <span class="stringliteral">"ZZ_VARIABLE"</span>, <span class="stringliteral">"ZZ_TYPE"</span>, <span class="stringliteral">"'-'"</span>, <span class="stringliteral">"'+'"</span>, <span class="stringliteral">"ZZ_FORALL"</span>, <span class="stringliteral">"ZZ_EXIST"</span>,
<a name="l00371"></a>00371   <span class="stringliteral">"ZZ_EQUIV"</span>, <span class="stringliteral">"ZZ_IMPLY"</span>, <span class="stringliteral">"'v'"</span>, <span class="stringliteral">"'^'"</span>, <span class="stringliteral">"'!'"</span>, <span class="stringliteral">"'*'"</span>, <span class="stringliteral">"'/'"</span>, <span class="stringliteral">"'%'"</span>,
<a name="l00372"></a>00372   <span class="stringliteral">"'\\n'"</span>, <span class="stringliteral">"'@'"</span>, <span class="stringliteral">"'.'"</span>, <span class="stringliteral">"'\\r'"</span>, <span class="stringliteral">"'='"</span>, <span class="stringliteral">"'{'"</span>, <span class="stringliteral">"'}'"</span>, <span class="stringliteral">"','"</span>, <span class="stringliteral">"'('"</span>, <span class="stringliteral">"')'"</span>,
<a name="l00373"></a>00373   <span class="stringliteral">"'?'"</span>, <span class="stringliteral">"'&gt;'"</span>, <span class="stringliteral">"'&lt;'"</span>, <span class="stringliteral">"$accept"</span>, <span class="stringliteral">"input"</span>, <span class="stringliteral">"@1"</span>, <span class="stringliteral">"@2"</span>, <span class="stringliteral">"@3"</span>, <span class="stringliteral">"at"</span>,
<a name="l00374"></a>00374   <span class="stringliteral">"fullstop"</span>, <span class="stringliteral">"newline"</span>, <span class="stringliteral">"optnewline"</span>, <span class="stringliteral">"include"</span>, <span class="stringliteral">"nnewline"</span>,
<a name="l00375"></a>00375   <span class="stringliteral">"type_declaration"</span>, <span class="stringliteral">"@4"</span>, <span class="stringliteral">"is_variable_type"</span>, <span class="stringliteral">"constant_declarations"</span>,
<a name="l00376"></a>00376   <span class="stringliteral">"@5"</span>, <span class="stringliteral">"variable_or_string_or_constant"</span>, <span class="stringliteral">"constant_sep"</span>,
<a name="l00377"></a>00377   <span class="stringliteral">"numeric_type_declaration"</span>, <span class="stringliteral">"@6"</span>, <span class="stringliteral">"@7"</span>, <span class="stringliteral">"@8"</span>, <span class="stringliteral">"numeric_types"</span>,
<a name="l00378"></a>00378   <span class="stringliteral">"single_numeric_types"</span>, <span class="stringliteral">"@9"</span>, <span class="stringliteral">"single_numeric_type"</span>,
<a name="l00379"></a>00379   <span class="stringliteral">"predicate_declaration"</span>, <span class="stringliteral">"@10"</span>, <span class="stringliteral">"@11"</span>, <span class="stringliteral">"@12"</span>, <span class="stringliteral">"function_declaration"</span>,
<a name="l00380"></a>00380   <span class="stringliteral">"@13"</span>, <span class="stringliteral">"@14"</span>, <span class="stringliteral">"@15"</span>, <span class="stringliteral">"function_return_type"</span>, <span class="stringliteral">"types"</span>, <span class="stringliteral">"@16"</span>, <span class="stringliteral">"@17"</span>,
<a name="l00381"></a>00381   <span class="stringliteral">"type_code"</span>, <span class="stringliteral">"variable_code"</span>, <span class="stringliteral">"pd_not_qs"</span>, <span class="stringliteral">"predicate_definition"</span>, <span class="stringliteral">"@18"</span>,
<a name="l00382"></a>00382   <span class="stringliteral">"@19"</span>, <span class="stringliteral">"function_definition"</span>, <span class="stringliteral">"@20"</span>, <span class="stringliteral">"@21"</span>, <span class="stringliteral">"@22"</span>,
<a name="l00383"></a>00383   <span class="stringliteral">"constants_in_groundings"</span>, <span class="stringliteral">"is_constant_string_num_variable"</span>,
<a name="l00384"></a>00384   <span class="stringliteral">"function_return_constant"</span>, <span class="stringliteral">"weight"</span>, <span class="stringliteral">"sentence"</span>, <span class="stringliteral">"@23"</span>, <span class="stringliteral">"@24"</span>, <span class="stringliteral">"@25"</span>,
<a name="l00385"></a>00385   <span class="stringliteral">"@26"</span>, <span class="stringliteral">"@27"</span>, <span class="stringliteral">"@28"</span>, <span class="stringliteral">"@29"</span>, <span class="stringliteral">"@30"</span>, <span class="stringliteral">"@31"</span>, <span class="stringliteral">"@32"</span>, <span class="stringliteral">"quantifier"</span>,
<a name="l00386"></a>00386   <span class="stringliteral">"variables"</span>, <span class="stringliteral">"@33"</span>, <span class="stringliteral">"@34"</span>, <span class="stringliteral">"quant_variable"</span>, <span class="stringliteral">"atomic_sentence"</span>, <span class="stringliteral">"@35"</span>,
<a name="l00387"></a>00387   <span class="stringliteral">"@36"</span>, <span class="stringliteral">"@37"</span>, <span class="stringliteral">"@38"</span>, <span class="stringliteral">"internal_predicate_sign"</span>, <span class="stringliteral">"asterisk"</span>, <span class="stringliteral">"terms"</span>,
<a name="l00388"></a>00388   <span class="stringliteral">"@39"</span>, <span class="stringliteral">"term"</span>, <span class="stringliteral">"plus"</span>, <span class="stringliteral">"function_term"</span>, <span class="stringliteral">"@40"</span>, <span class="stringliteral">"@41"</span>, <span class="stringliteral">"@42"</span>, <span class="stringliteral">"@43"</span>,
<a name="l00389"></a>00389   <span class="stringliteral">"@44"</span>, <span class="stringliteral">"internal_function_sign"</span>, 0
<a name="l00390"></a>00390 };
<a name="l00391"></a>00391 <span class="preprocessor">#endif</span>
<a name="l00392"></a>00392 <span class="preprocessor"></span>
<a name="l00393"></a>00393 <span class="comment">/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */</span>
<a name="l00394"></a>00394 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> yyr1[] =
<a name="l00395"></a>00395 {
<a name="l00396"></a>00396        0,    38,    39,    39,    39,    39,    39,    39,    39,    39,
<a name="l00397"></a>00397       39,    39,    39,    40,    41,    42,    39,    43,    43,    44,
<a name="l00398"></a>00398       44,    45,    45,    46,    46,    46,    47,    48,    48,    50,
<a name="l00399"></a>00399       49,    51,    51,    52,    53,    52,    54,    54,    54,    55,
<a name="l00400"></a>00400       55,    55,    55,    55,    57,    58,    59,    56,    60,    60,
<a name="l00401"></a>00401       62,    61,    61,    63,    65,    66,    67,    64,    69,    70,
<a name="l00402"></a>00402       71,    68,    72,    72,    74,    73,    75,    73,    73,    73,
<a name="l00403"></a>00403       76,    77,    78,    78,    78,    80,    81,    79,    83,    84,
<a name="l00404"></a>00404       85,    82,    86,    86,    87,    87,    87,    87,    88,    88,
<a name="l00405"></a>00405       88,    88,    89,    89,    91,    90,    92,    90,    93,    90,
<a name="l00406"></a>00406       94,    90,    95,    90,    96,    90,    97,    98,    99,    90,
<a name="l00407"></a>00407      100,    90,   101,   101,   103,   104,   102,   102,   105,   107,
<a name="l00408"></a>00408      108,   106,   109,   110,   106,   111,   111,   111,   111,   111,
<a name="l00409"></a>00409      112,   112,   114,   113,   113,   115,   115,   115,   115,   115,
<a name="l00410"></a>00410      115,   116,   116,   118,   119,   117,   120,   121,   122,   117,
<a name="l00411"></a>00411      123,   123,   123,   123,   123
<a name="l00412"></a>00412 };
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="comment">/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */</span>
<a name="l00415"></a>00415 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> yyr2[] =
<a name="l00416"></a>00416 {
<a name="l00417"></a>00417        0,     2,     0,     3,     2,     2,     3,     3,     3,     3,
<a name="l00418"></a>00418        4,     3,     3,     0,     0,     0,     8,     1,     2,     0,
<a name="l00419"></a>00419        1,     1,     1,     0,     1,     1,     3,     1,     1,     0,
<a name="l00420"></a>00420        6,     1,     1,     0,     0,     4,     1,     1,     1,     0,
<a name="l00421"></a>00421        1,     3,     2,     2,     0,     0,     0,    10,     3,     1,
<a name="l00422"></a>00422        0,     4,     1,     1,     0,     0,     0,     7,     0,     0,
<a name="l00423"></a>00423        0,     8,     1,     1,     0,     4,     0,     4,     1,     1,
<a name="l00424"></a>00424        1,     1,     0,     1,     1,     0,     0,     6,     0,     0,
<a name="l00425"></a>00425        0,     9,     1,     3,     1,     1,     1,     1,     1,     1,
<a name="l00426"></a>00426        1,     1,     0,     1,     0,     4,     0,     2,     0,     5,
<a name="l00427"></a>00427        0,     5,     0,     5,     0,     5,     0,     0,     0,     6,
<a name="l00428"></a>00428        0,     3,     1,     1,     0,     0,     5,     1,     1,     0,
<a name="l00429"></a>00429        0,     7,     0,     0,     5,     1,     1,     2,     2,     1,
<a name="l00430"></a>00430        0,     1,     0,     4,     1,     1,     1,     1,     1,     2,
<a name="l00431"></a>00431        3,     0,     1,     0,     0,     6,     0,     0,     0,     8,
<a name="l00432"></a>00432        1,     1,     1,     1,     1
<a name="l00433"></a>00433 };
<a name="l00434"></a>00434 
<a name="l00435"></a>00435 <span class="comment">/* YYDPREC[RULE-NUM] -- Dynamic precedence of rule #RULE-NUM (0 if none). */</span>
<a name="l00436"></a>00436 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> yydprec[] =
<a name="l00437"></a>00437 {
<a name="l00438"></a>00438        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00439"></a>00439        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00440"></a>00440        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00441"></a>00441        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00442"></a>00442        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00443"></a>00443        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00444"></a>00444        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00445"></a>00445        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00446"></a>00446        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00447"></a>00447        0,     0,     0,     0,     0,     0,     0,     0,     0,     1,
<a name="l00448"></a>00448        0,     1,     0,     1,     0,     1,     0,     0,     0,     2,
<a name="l00449"></a>00449        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00450"></a>00450        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00451"></a>00451        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00452"></a>00452        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00453"></a>00453        0,     0,     0,     0,     0
<a name="l00454"></a>00454 };
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="comment">/* YYMERGER[RULE-NUM] -- Index of merging function for rule #RULE-NUM. */</span>
<a name="l00457"></a>00457 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> yymerger[] =
<a name="l00458"></a>00458 {
<a name="l00459"></a>00459        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00460"></a>00460        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00461"></a>00461        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00462"></a>00462        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00463"></a>00463        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00464"></a>00464        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00465"></a>00465        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00466"></a>00466        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00467"></a>00467        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00468"></a>00468        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00469"></a>00469        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00470"></a>00470        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00471"></a>00471        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00472"></a>00472        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00473"></a>00473        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00474"></a>00474        0,     0,     0,     0,     0
<a name="l00475"></a>00475 };
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="comment">/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE</span>
<a name="l00478"></a>00478 <span class="comment">   doesn't specify something else to do.  Zero means the default is an</span>
<a name="l00479"></a>00479 <span class="comment">   error.  */</span>
<a name="l00480"></a>00480 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> yydefact[] =
<a name="l00481"></a>00481 {
<a name="l00482"></a>00482        2,     0,     1,     0,     0,    31,    32,    21,    17,    22,
<a name="l00483"></a>00483       92,    72,     4,     5,     0,     0,     0,     0,     0,    58,
<a name="l00484"></a>00484        3,     0,     0,    93,    14,    90,    89,    88,    91,    73,
<a name="l00485"></a>00485       18,    74,    12,     0,    11,     0,     6,     0,     7,     8,
<a name="l00486"></a>00486        9,     0,    27,    28,    26,    55,    96,    75,    10,    78,
<a name="l00487"></a>00487       29,    59,     0,   110,    94,    19,   122,     0,     0,     0,
<a name="l00488"></a>00488       33,     0,     0,    71,    70,    56,    68,    69,    96,    96,
<a name="l00489"></a>00489      100,    98,   102,   104,    20,    15,   131,    97,   141,     0,
<a name="l00490"></a>00490      112,   113,   107,    76,    79,    39,    45,    60,    64,     0,
<a name="l00491"></a>00491      111,     0,    23,    23,    23,    23,     0,   138,   137,   143,
<a name="l00492"></a>00492      136,   142,     0,     0,   135,     0,   119,     0,     0,     0,
<a name="l00493"></a>00493        0,    30,    40,    34,     0,     0,     0,     0,    57,    95,
<a name="l00494"></a>00494       24,    25,    96,    96,    96,    96,    16,     0,   129,   125,
<a name="l00495"></a>00495      126,   123,   139,   147,     0,   118,   108,     0,   117,    86,
<a name="l00496"></a>00496       85,    84,    87,    39,    82,    80,    42,    43,     0,    46,
<a name="l00497"></a>00497        0,    65,    67,   101,    99,   103,   105,   144,   127,   128,
<a name="l00498"></a>00498      141,   140,   141,   120,    96,     0,    77,     0,     0,    41,
<a name="l00499"></a>00499       37,    38,    36,    35,     0,    61,   141,   124,     0,   141,
<a name="l00500"></a>00500      109,   115,    83,    39,    53,     0,     0,    49,    52,     0,
<a name="l00501"></a>00501      134,   151,   150,   152,   153,   154,   148,     0,     0,    81,
<a name="l00502"></a>00502        0,    47,    50,   132,   145,   141,   121,   116,    48,     0,
<a name="l00503"></a>00503      141,     0,    51,   133,   149
<a name="l00504"></a>00504 };
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="comment">/* YYPDEFGOTO[NTERM-NUM]. */</span>
<a name="l00507"></a>00507 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yydefgoto[] =
<a name="l00508"></a>00508 {
<a name="l00509"></a>00509       -1,     1,    10,    46,    96,    11,    75,    12,   122,    13,
<a name="l00510"></a>00510       44,    14,    60,    15,    85,   148,   173,   167,    16,    61,
<a name="l00511"></a>00511      114,   174,   186,   187,   209,   188,    17,    22,    52,    89,
<a name="l00512"></a>00512       18,    41,    62,   115,    19,    65,   116,   117,    66,    67,
<a name="l00513"></a>00513       33,    48,    58,   108,    34,    59,   109,   168,   143,   144,
<a name="l00514"></a>00514       35,    24,    55,    69,    56,    93,    92,    94,    95,    57,
<a name="l00515"></a>00515      107,   164,    68,    82,   136,   137,   198,   138,    77,   134,
<a name="l00516"></a>00516      179,    78,   160,   131,    79,   189,   210,   190,   103,   104,
<a name="l00517"></a>00517      127,   176,   105,   162,   205,   196
<a name="l00518"></a>00518 };
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 <span class="comment">/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing</span>
<a name="l00521"></a>00521 <span class="comment">   STATE-NUM.  */</span>
<a name="l00522"></a>00522 <span class="preprocessor">#define YYPACT_NINF -79</span>
<a name="l00523"></a>00523 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yypact[] =
<a name="l00524"></a>00524 {
<a name="l00525"></a>00525      -79,    11,   -79,    -1,    33,    -4,    19,   -79,   -79,   -79,
<a name="l00526"></a>00526       57,    38,   -79,   -79,    25,    36,    25,    25,    25,   -79,
<a name="l00527"></a>00527      -79,    55,    45,   -79,   -79,   -79,   -79,   -79,   -79,   -79,
<a name="l00528"></a>00528      -79,   -79,   -79,    77,   -79,    58,   -79,    62,   -79,   -79,
<a name="l00529"></a>00529      -79,    98,   -79,   -79,   -79,   -79,    46,   -79,   -79,   -79,
<a name="l00530"></a>00530      123,   -79,    -7,   -79,   -79,   121,     9,   147,    85,   122,
<a name="l00531"></a>00531      -79,   139,   113,   -79,   -79,   128,   -79,   -79,    53,    56,
<a name="l00532"></a>00532      -79,   -79,   -79,   -79,   -79,   -79,   -79,   -79,    37,   160,
<a name="l00533"></a>00533      -79,   -79,   -79,   -79,   -79,     3,   -79,   -79,   158,   136,
<a name="l00534"></a>00534      -79,   103,    89,    89,    89,    89,    25,   -79,   -79,   -79,
<a name="l00535"></a>00535      -79,   -79,   107,   161,   -79,   138,   -79,   162,   100,   141,
<a name="l00536"></a>00536      143,   -79,   151,   -79,   146,    -7,   165,   168,   -79,   -79,
<a name="l00537"></a>00537      -79,   -79,    60,    75,    79,    83,   -79,   148,   -79,   153,
<a name="l00538"></a>00538      154,   -79,   159,   -79,   152,   -79,   -79,   173,   -79,   -79,
<a name="l00539"></a>00539      -79,   -79,   -79,    20,   -79,   -79,   164,   -79,   140,   -79,
<a name="l00540"></a>00540      -19,   -79,   -79,   110,   145,   166,   -79,   -79,   -79,   -79,
<a name="l00541"></a>00541       37,   -79,    37,   -79,    86,   155,   -79,   100,   100,   -79,
<a name="l00542"></a>00542      -79,   -79,   -79,   -79,   163,   -79,    37,   -79,   111,    37,
<a name="l00543"></a>00543      135,   -79,   -79,    81,   -79,   156,   167,   -79,   169,   115,
<a name="l00544"></a>00544      -79,   -79,   -79,   -79,   -79,   -79,   -79,   127,   179,   -79,
<a name="l00545"></a>00545      188,   -79,   -79,   -79,   -79,    37,   -79,   -79,   -79,   189,
<a name="l00546"></a>00546       37,   170,   -79,   -79,   -79
<a name="l00547"></a>00547 };
<a name="l00548"></a>00548 
<a name="l00549"></a>00549 <span class="comment">/* YYPGOTO[NTERM-NUM].  */</span>
<a name="l00550"></a>00550 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span> yypgoto[] =
<a name="l00551"></a>00551 {
<a name="l00552"></a>00552      -79,   -79,   -79,   -79,   -79,   -79,   -79,    -8,    63,   -79,
<a name="l00553"></a>00553      -79,   -79,   -79,   -79,   -79,   -79,   -79,   108,   -79,   -79,
<a name="l00554"></a>00554      -79,   -79,   -79,   -15,   -79,   -79,   -79,   -79,   -79,   -79,
<a name="l00555"></a>00555      -79,   -79,   -79,   -79,   -79,    80,   -79,   -79,    84,    82,
<a name="l00556"></a>00556      -79,   -79,   -79,   -79,   -79,   -79,   -79,   -79,    28,    30,
<a name="l00557"></a>00557      -79,   -79,   -67,   -79,   -79,   -79,   -79,   -79,   -79,   -79,
<a name="l00558"></a>00558      -79,   -79,   -79,   -79,     4,   -79,   -79,    66,   -79,   -79,
<a name="l00559"></a>00559      -79,   -79,   -79,   -79,   -79,    26,   -79,   -78,   -79,   -79,
<a name="l00560"></a>00560      -79,   -79,   -79,   -79,   -79,   -79
<a name="l00561"></a>00561 };
<a name="l00562"></a>00562 
<a name="l00563"></a>00563 <span class="comment">/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If</span>
<a name="l00564"></a>00564 <span class="comment">   positive, shift that token.  If negative, reduce the rule which</span>
<a name="l00565"></a>00565 <span class="comment">   number is the opposite.  If zero, do what YYDEFACT says.</span>
<a name="l00566"></a>00566 <span class="comment">   If YYTABLE_NINF, parse error.  */</span>
<a name="l00567"></a>00567 <span class="preprocessor">#define YYTABLE_NINF -147</span>
<a name="l00568"></a>00568 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yytable[] =
<a name="l00569"></a>00569 {
<a name="l00570"></a>00570      102,    90,    91,    32,    63,    64,    36,   -63,    38,    39,
<a name="l00571"></a>00571       40,     2,     3,    88,   -13,   175,   -13,  -130,     4,   -13,
<a name="l00572"></a>00572      -13,   -13,     5,     6,    20,   -13,   -13,   -13,   110,   -54,
<a name="l00573"></a>00573      -62,    76,   -13,   -13,   111,   112,     7,     8,    21,     9,
<a name="l00574"></a>00574       97,    25,    98,    26,   -13,   110,    99,   100,    27,    28,
<a name="l00575"></a>00575        7,   101,   112,     9,   166,   153,   154,   155,   156,    29,
<a name="l00576"></a>00576       23,  -106,  -106,     7,    30,    37,     9,    53,  -106,  -106,
<a name="l00577"></a>00577     -146,  -106,  -106,    31,    53,  -106,  -106,    53,    45,    54,
<a name="l00578"></a>00578       42,    53,   177,    43,   178,    47,    54,    49,   126,    54,
<a name="l00579"></a>00579     -106,  -106,    50,    54,  -106,  -106,    53,   180,  -106,  -106,
<a name="l00580"></a>00580       53,  -106,  -106,   139,    53,   140,   110,    53,    54,    51,
<a name="l00581"></a>00581      141,   142,    54,   112,   120,   199,    54,   121,    83,    54,
<a name="l00582"></a>00582       70,    71,    72,    73,   191,   192,   -44,   211,    71,    72,
<a name="l00583"></a>00583       73,    84,   213,   193,   194,   195,   128,   119,    70,    71,
<a name="l00584"></a>00584       72,    73,    86,   129,   130,   170,    87,   203,    74,   204,
<a name="l00585"></a>00585      171,   172,    70,    71,    72,    73,   123,   124,   125,   203,
<a name="l00586"></a>00586       88,   206,    80,    81,    72,    73,   184,   185,   106,   -66,
<a name="l00587"></a>00587      118,   133,   132,   135,   145,   146,   147,    64,   149,    63,
<a name="l00588"></a>00588      161,   157,   158,   159,   135,   163,    73,   181,   200,   169,
<a name="l00589"></a>00589      135,   208,   184,   113,   212,   150,   183,   182,   201,   152,
<a name="l00590"></a>00590      151,   202,   207,   165,   214,   197
<a name="l00591"></a>00591 };
<a name="l00592"></a>00592 
<a name="l00593"></a>00593 <span class="comment">/* YYCONFLP[YYPACT[STATE-NUM]] -- Pointer into YYCONFL of start of</span>
<a name="l00594"></a>00594 <span class="comment">   list of conflicting reductions corresponding to action entry for</span>
<a name="l00595"></a>00595 <span class="comment">   state STATE-NUM in yytable.  0 means no conflicts.  The list in</span>
<a name="l00596"></a>00596 <span class="comment">   yyconfl is terminated by a rule number of 0.  */</span>
<a name="l00597"></a>00597 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> yyconflp[] =
<a name="l00598"></a>00598 {
<a name="l00599"></a>00599        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00600"></a>00600        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00601"></a>00601        0,     0,     1,     0,     0,     0,     0,     0,     0,     0,
<a name="l00602"></a>00602        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00603"></a>00603        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00604"></a>00604        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00605"></a>00605        3,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00606"></a>00606        0,     0,     0,     0,     0,     0,     0,     0,     0,     5,
<a name="l00607"></a>00607        0,     0,     0,     0,     0,     0,     7,     0,     0,     9,
<a name="l00608"></a>00608        0,     0,     0,    13,     0,     0,     0,     0,     0,     0,
<a name="l00609"></a>00609        0,     0,     0,     0,     0,     0,     0,     0,    15,     0,
<a name="l00610"></a>00610        0,     0,    17,     0,     0,     0,    19,     0,     0,    21,
<a name="l00611"></a>00611        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00612"></a>00612        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00613"></a>00613        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00614"></a>00614        0,     0,    23,    25,    27,    29,     0,     0,     0,     0,
<a name="l00615"></a>00615        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00616"></a>00616        0,     0,     0,    11,     0,     0,     0,     0,     0,     0,
<a name="l00617"></a>00617        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00618"></a>00618       31,     0,     0,     0,     0,     0,     0,     0,     0,     0,
<a name="l00619"></a>00619        0,     0,     0,     0,     0,     0
<a name="l00620"></a>00620 };
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 <span class="comment">/* YYCONFL[I] -- lists of conflicting rule numbers, each terminated by</span>
<a name="l00623"></a>00623 <span class="comment">   0, pointed into by YYCONFLP.  */</span>
<a name="l00624"></a>00624 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yyconfl[] =
<a name="l00625"></a>00625 {
<a name="l00626"></a>00626        0,    13,     0,    92,     0,    96,     0,    96,     0,    96,
<a name="l00627"></a>00627        0,   114,     0,    96,     0,    96,     0,    96,     0,    96,
<a name="l00628"></a>00628        0,    96,     0,   109,     0,   109,     0,   109,     0,   109,
<a name="l00629"></a>00629        0,   114,     0
<a name="l00630"></a>00630 };
<a name="l00631"></a>00631 
<a name="l00632"></a>00632 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> yycheck[] =
<a name="l00633"></a>00633 {
<a name="l00634"></a>00634       78,    68,    69,    11,    11,    12,    14,    11,    16,    17,
<a name="l00635"></a>00635       18,     0,     1,    32,     3,    34,     5,     8,     7,     8,
<a name="l00636"></a>00636        9,    10,    11,    12,    25,    14,    15,    16,    25,    33,
<a name="l00637"></a>00637       11,    22,    21,    22,    31,    32,    25,    26,     5,    28,
<a name="l00638"></a>00638        3,     3,     5,     5,    33,    25,     9,    10,    10,    11,
<a name="l00639"></a>00639       25,    14,    32,    28,    34,   122,   123,   124,   125,    21,
<a name="l00640"></a>00640        3,    15,    16,    25,    26,    29,    28,    21,    15,    16,
<a name="l00641"></a>00641       33,    15,    16,    35,    21,    15,    16,    21,    33,    33,
<a name="l00642"></a>00642       25,    21,   160,    28,   162,     8,    33,    29,    96,    33,
<a name="l00643"></a>00643       15,    16,    30,    33,    15,    16,    21,   164,    15,    16,
<a name="l00644"></a>00644       21,    15,    16,     3,    21,     5,    25,    21,    33,    11,
<a name="l00645"></a>00645       10,    11,    33,    32,    25,    34,    33,    28,    33,    33,
<a name="l00646"></a>00646       17,    18,    19,    20,    13,    14,     3,   205,    18,    19,
<a name="l00647"></a>00647       20,     9,   210,    22,    23,    24,    29,    34,    17,    18,
<a name="l00648"></a>00648       19,    20,     3,    36,    37,     5,    33,    32,    27,    34,
<a name="l00649"></a>00649       10,    11,    17,    18,    19,    20,    93,    94,    95,    32,
<a name="l00650"></a>00650       32,    34,    15,    16,    19,    20,     3,     4,     8,    11,
<a name="l00651"></a>00651       34,    33,    11,    11,    33,    32,    25,    12,    32,    11,
<a name="l00652"></a>00652       21,    33,    29,    29,    11,    33,    20,    32,    32,    25,
<a name="l00653"></a>00653       11,     3,     3,    85,   209,   115,   168,   167,    31,   117,
<a name="l00654"></a>00654      116,    32,   198,   137,    34,   179
<a name="l00655"></a>00655 };
<a name="l00656"></a>00656 
<a name="l00657"></a>00657 <span class="comment">/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing</span>
<a name="l00658"></a>00658 <span class="comment">   symbol of state STATE-NUM.  */</span>
<a name="l00659"></a>00659 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> yystos[] =
<a name="l00660"></a>00660 {
<a name="l00661"></a>00661        0,    39,     0,     1,     7,    11,    12,    25,    26,    28,
<a name="l00662"></a>00662       40,    43,    45,    47,    49,    51,    56,    64,    68,    72,
<a name="l00663"></a>00663       25,     5,    65,     3,    89,     3,     5,    10,    11,    21,
<a name="l00664"></a>00664       26,    35,    45,    78,    82,    88,    45,    29,    45,    45,
<a name="l00665"></a>00665       45,    69,    25,    28,    48,    33,    41,     8,    79,    29,
<a name="l00666"></a>00666       30,    11,    66,    21,    33,    90,    92,    97,    80,    83,
<a name="l00667"></a>00667       50,    57,    70,    11,    12,    73,    76,    77,   100,    91,
<a name="l00668"></a>00668       17,    18,    19,    20,    27,    44,    22,   106,   109,   112,
<a name="l00669"></a>00669       15,    16,   101,    33,     9,    52,     3,    33,    32,    67,
<a name="l00670"></a>00670       90,    90,    94,    93,    95,    96,    42,     3,     5,     9,
<a name="l00671"></a>00671       10,    14,   115,   116,   117,   120,     8,    98,    81,    84,
<a name="l00672"></a>00672       25,    31,    32,    55,    58,    71,    74,    75,    34,    34,
<a name="l00673"></a>00673       25,    28,    46,    46,    46,    46,    45,   118,    29,    36,
<a name="l00674"></a>00674       37,   111,    11,    33,   107,    11,   102,   103,   105,     3,
<a name="l00675"></a>00675        5,    10,    11,    86,    87,    33,    32,    25,    53,    32,
<a name="l00676"></a>00676       73,    76,    77,    90,    90,    90,    90,    33,    29,    29,
<a name="l00677"></a>00677      110,    21,   121,    33,    99,   105,    34,    55,    85,    25,
<a name="l00678"></a>00678        5,    10,    11,    54,    59,    34,   119,   115,   115,   108,
<a name="l00679"></a>00679       90,    32,    87,    86,     3,     4,    60,    61,    63,   113,
<a name="l00680"></a>00680      115,    13,    14,    22,    23,    24,   123,   113,   104,    34,
<a name="l00681"></a>00681       32,    31,    32,    32,    34,   122,    34,   102,     3,    62,
<a name="l00682"></a>00682      114,   115,    61,   115,    34
<a name="l00683"></a>00683 };
<a name="l00684"></a>00684 
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 <span class="comment">/* Prevent warning if -Wmissing-prototypes.  */</span>
<a name="l00687"></a>00687 <span class="keywordtype">int</span> yyparse (<span class="keywordtype">void</span>);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 <span class="comment">/* Error token number */</span>
<a name="l00690"></a>00690 <span class="preprocessor">#define YYTERROR 1</span>
<a name="l00691"></a>00691 <span class="preprocessor"></span>
<a name="l00692"></a>00692 <span class="comment">/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].</span>
<a name="l00693"></a>00693 <span class="comment">   If N is 0, then set CURRENT to the empty location which ends</span>
<a name="l00694"></a>00694 <span class="comment">   the previous symbol: RHS[0] (always defined).  */</span>
<a name="l00695"></a>00695 
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 <span class="preprocessor">#ifndef YYLLOC_DEFAULT</span>
<a name="l00698"></a>00698 <span class="preprocessor"></span><span class="preprocessor"># define YYLLOC_DEFAULT(Current, Rhs, N) ((void) 0)</span>
<a name="l00699"></a>00699 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00700"></a>00700 <span class="preprocessor"></span>
<a name="l00701"></a>00701 
<a name="l00702"></a>00702 <span class="preprocessor">#ifndef YY_LOCATION_PRINT</span>
<a name="l00703"></a>00703 <span class="preprocessor"></span><span class="preprocessor"># define YY_LOCATION_PRINT(File, Loc) ((void) 0)</span>
<a name="l00704"></a>00704 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00705"></a>00705 <span class="preprocessor"></span>
<a name="l00706"></a>00706 
<a name="l00707"></a>00707 <span class="comment">/* YYLEX -- calling `yylex' with the right arguments.  */</span>
<a name="l00708"></a>00708 <span class="preprocessor">#define YYLEX yylex ()</span>
<a name="l00709"></a>00709 <span class="preprocessor"></span>
<a name="l00710"></a>00710 YYSTYPE yylval;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712 <a class="code" href="structYYLTYPE.html">YYLTYPE</a> yylloc;
<a name="l00713"></a>00713 
<a name="l00714"></a>00714 <span class="keywordtype">int</span> yynerrs;
<a name="l00715"></a>00715 <span class="keywordtype">int</span> yychar;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> YYEOF = 0;
<a name="l00718"></a>00718 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> YYEMPTY = -2;
<a name="l00719"></a>00719 
<a name="l00720"></a>00720 <span class="keyword">typedef</span> <span class="keyword">enum</span> { yyok, yyaccept, yyabort, yyerr } YYRESULTTAG;
<a name="l00721"></a>00721 
<a name="l00722"></a>00722 <span class="preprocessor">#define YYCHK(YYE)                                                           \</span>
<a name="l00723"></a>00723 <span class="preprocessor">   do { YYRESULTTAG yyflag = YYE; if (yyflag != yyok) return yyflag; }       \</span>
<a name="l00724"></a>00724 <span class="preprocessor">   while (0)</span>
<a name="l00725"></a>00725 <span class="preprocessor"></span>
<a name="l00726"></a>00726 <span class="preprocessor">#if YYDEBUG</span>
<a name="l00727"></a>00727 <span class="preprocessor"></span>
<a name="l00728"></a>00728 <span class="preprocessor">#if ! defined (YYFPRINTF)</span>
<a name="l00729"></a>00729 <span class="preprocessor"></span><span class="preprocessor">#  define YYFPRINTF fprintf</span>
<a name="l00730"></a>00730 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00731"></a>00731 <span class="preprocessor"></span>
<a name="l00732"></a>00732 <span class="preprocessor"># define YYDPRINTF(Args)                        \</span>
<a name="l00733"></a>00733 <span class="preprocessor">do {                                            \</span>
<a name="l00734"></a>00734 <span class="preprocessor">  if (yydebug)                                  \</span>
<a name="l00735"></a>00735 <span class="preprocessor">    YYFPRINTF Args;                             \</span>
<a name="l00736"></a>00736 <span class="preprocessor">} while (0)</span>
<a name="l00737"></a>00737 <span class="preprocessor"></span>
<a name="l00738"></a>00738 <span class="comment">/*--------------------------------.</span>
<a name="l00739"></a>00739 <span class="comment">| Print this symbol on YYOUTPUT.  |</span>
<a name="l00740"></a>00740 <span class="comment">`--------------------------------*/</span>
<a name="l00741"></a>00741 
<a name="l00742"></a>00742 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00743"></a>00743 yysymprint (FILE *yyoutput, <span class="keywordtype">int</span> yytype, YYSTYPE *yyvaluep)
<a name="l00744"></a>00744 {
<a name="l00745"></a>00745   <span class="comment">/* Pacify ``unused variable'' warnings.  */</span>
<a name="l00746"></a>00746   (void) yyvaluep;
<a name="l00747"></a>00747 
<a name="l00748"></a>00748   <span class="keywordflow">if</span> (yytype &lt; YYNTOKENS)
<a name="l00749"></a>00749     YYFPRINTF (yyoutput, <span class="stringliteral">"token %s ("</span>, yytname[yytype]);
<a name="l00750"></a>00750   <span class="keywordflow">else</span>
<a name="l00751"></a>00751     YYFPRINTF (yyoutput, <span class="stringliteral">"nterm %s ("</span>, yytname[yytype]);
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 
<a name="l00754"></a>00754 <span class="preprocessor"># ifdef YYPRINT</span>
<a name="l00755"></a>00755 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (yytype &lt; YYNTOKENS)
<a name="l00756"></a>00756     YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
<a name="l00757"></a>00757 <span class="preprocessor"># endif</span>
<a name="l00758"></a>00758 <span class="preprocessor"></span>  <span class="keywordflow">switch</span> (yytype)
<a name="l00759"></a>00759     {
<a name="l00760"></a>00760       <span class="keywordflow">default</span>:
<a name="l00761"></a>00761         <span class="keywordflow">break</span>;
<a name="l00762"></a>00762     }
<a name="l00763"></a>00763   YYFPRINTF (yyoutput, <span class="stringliteral">")"</span>);
<a name="l00764"></a>00764 }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766 
<a name="l00767"></a>00767 <span class="preprocessor"># define YY_SYMBOL_PRINT(Title, Type, Value, Location)          \</span>
<a name="l00768"></a>00768 <span class="preprocessor">do {                                                            \</span>
<a name="l00769"></a>00769 <span class="preprocessor">  if (yydebug)                                                  \</span>
<a name="l00770"></a>00770 <span class="preprocessor">    {                                                           \</span>
<a name="l00771"></a>00771 <span class="preprocessor">      YYFPRINTF (stderr, "%s ", Title);                         \</span>
<a name="l00772"></a>00772 <span class="preprocessor">      yysymprint (stderr,                                       \</span>
<a name="l00773"></a>00773 <span class="preprocessor">                  Type, Value); \</span>
<a name="l00774"></a>00774 <span class="preprocessor">      YYFPRINTF (stderr, "\n");                                 \</span>
<a name="l00775"></a>00775 <span class="preprocessor">    }                                                           \</span>
<a name="l00776"></a>00776 <span class="preprocessor">} while (0)</span>
<a name="l00777"></a>00777 <span class="preprocessor"></span>
<a name="l00778"></a>00778 <span class="comment">/* Nonzero means print parse trace.  It is left uninitialized so that</span>
<a name="l00779"></a>00779 <span class="comment">   multiple parsers can coexist.  */</span>
<a name="l00780"></a>00780 <span class="keywordtype">int</span> yydebug;
<a name="l00781"></a>00781 
<a name="l00782"></a>00782 <span class="preprocessor">#else </span><span class="comment">/* !YYDEBUG */</span>
<a name="l00783"></a>00783 
<a name="l00784"></a>00784 <span class="preprocessor"># define YYDPRINTF(Args)</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span><span class="preprocessor"># define YY_SYMBOL_PRINT(Title, Type, Value, Location)</span>
<a name="l00786"></a>00786 <span class="preprocessor"></span>
<a name="l00787"></a>00787 <span class="preprocessor">#endif </span><span class="comment">/* !YYDEBUG */</span>
<a name="l00788"></a>00788 
<a name="l00789"></a>00789 <span class="comment">/* YYINITDEPTH -- initial size of the parser's stacks.  */</span>
<a name="l00790"></a>00790 <span class="preprocessor">#ifndef YYINITDEPTH</span>
<a name="l00791"></a>00791 <span class="preprocessor"></span><span class="preprocessor"># define YYINITDEPTH 200</span>
<a name="l00792"></a>00792 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00793"></a>00793 <span class="preprocessor"></span>
<a name="l00794"></a>00794 <span class="comment">/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only</span>
<a name="l00795"></a>00795 <span class="comment">   if the built-in stack extension method is used).</span>
<a name="l00796"></a>00796 <span class="comment"></span>
<a name="l00797"></a>00797 <span class="comment">   Do not make this value too large; the results are undefined if</span>
<a name="l00798"></a>00798 <span class="comment">   SIZE_MAX &lt; YYMAXDEPTH * sizeof (GLRStackItem)</span>
<a name="l00799"></a>00799 <span class="comment">   evaluated with infinite-precision integer arithmetic.  */</span>
<a name="l00800"></a>00800 
<a name="l00801"></a>00801 <span class="preprocessor">#ifndef YYMAXDEPTH</span>
<a name="l00802"></a>00802 <span class="preprocessor"></span><span class="preprocessor"># define YYMAXDEPTH 10000</span>
<a name="l00803"></a>00803 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00804"></a>00804 <span class="preprocessor"></span>
<a name="l00805"></a>00805 <span class="comment">/* Minimum number of free items on the stack allowed after an</span>
<a name="l00806"></a>00806 <span class="comment">   allocation.  This is to allow allocation and initialization</span>
<a name="l00807"></a>00807 <span class="comment">   to be completed by functions that call yyexpandGLRStack before the</span>
<a name="l00808"></a>00808 <span class="comment">   stack is expanded, thus insuring that all necessary pointers get</span>
<a name="l00809"></a>00809 <span class="comment">   properly redirected to new data. */</span>
<a name="l00810"></a>00810 <span class="preprocessor">#define YYHEADROOM 2</span>
<a name="l00811"></a>00811 <span class="preprocessor"></span>
<a name="l00812"></a>00812 <span class="preprocessor">#ifndef YYSTACKEXPANDABLE</span>
<a name="l00813"></a>00813 <span class="preprocessor"></span><span class="preprocessor"># if (! defined (__cplusplus) \</span>
<a name="l00814"></a>00814 <span class="preprocessor">      || (defined (YYSTYPE_IS_TRIVIAL) &amp;&amp; YYSTYPE_IS_TRIVIAL))</span>
<a name="l00815"></a>00815 <span class="preprocessor"></span><span class="preprocessor">#  define YYSTACKEXPANDABLE 1</span>
<a name="l00816"></a>00816 <span class="preprocessor"></span><span class="preprocessor"># else</span>
<a name="l00817"></a>00817 <span class="preprocessor"></span><span class="preprocessor">#  define YYSTACKEXPANDABLE 0</span>
<a name="l00818"></a>00818 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00819"></a>00819 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00820"></a>00820 <span class="preprocessor"></span>
<a name="l00821"></a>00821 <span class="preprocessor">#if YYERROR_VERBOSE</span>
<a name="l00822"></a>00822 <span class="preprocessor"></span>
<a name="l00823"></a>00823 <span class="preprocessor"># ifndef yystpcpy</span>
<a name="l00824"></a>00824 <span class="preprocessor"></span><span class="preprocessor">#  if defined (__GLIBC__) &amp;&amp; defined (_STRING_H) &amp;&amp; defined (_GNU_SOURCE)</span>
<a name="l00825"></a>00825 <span class="preprocessor"></span><span class="preprocessor">#   define yystpcpy stpcpy</span>
<a name="l00826"></a>00826 <span class="preprocessor"></span><span class="preprocessor">#  else</span>
<a name="l00827"></a>00827 <span class="preprocessor"></span><span class="comment">/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in</span>
<a name="l00828"></a>00828 <span class="comment">   YYDEST.  */</span>
<a name="l00829"></a>00829 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00830"></a>00830 yystpcpy (<span class="keywordtype">char</span> *yydest, <span class="keyword">const</span> <span class="keywordtype">char</span> *yysrc)
<a name="l00831"></a>00831 {
<a name="l00832"></a>00832   <span class="keywordtype">char</span> *yyd = yydest;
<a name="l00833"></a>00833   <span class="keyword">const</span> <span class="keywordtype">char</span> *yys = yysrc;
<a name="l00834"></a>00834 
<a name="l00835"></a>00835   <span class="keywordflow">while</span> ((*yyd++ = *yys++) != <span class="charliteral">'\0'</span>)
<a name="l00836"></a>00836     <span class="keywordflow">continue</span>;
<a name="l00837"></a>00837 
<a name="l00838"></a>00838   <span class="keywordflow">return</span> yyd - 1;
<a name="l00839"></a>00839 }
<a name="l00840"></a>00840 <span class="preprocessor">#  endif</span>
<a name="l00841"></a>00841 <span class="preprocessor"></span><span class="preprocessor"># endif</span>
<a name="l00842"></a>00842 <span class="preprocessor"></span>
<a name="l00843"></a>00843 <span class="preprocessor"># ifndef yytnamerr</span>
<a name="l00844"></a>00844 <span class="preprocessor"></span><span class="comment">/* Copy to YYRES the contents of YYSTR after stripping away unnecessary</span>
<a name="l00845"></a>00845 <span class="comment">   quotes and backslashes, so that it's suitable for yyerror.  The</span>
<a name="l00846"></a>00846 <span class="comment">   heuristic is that double-quoting is unnecessary unless the string</span>
<a name="l00847"></a>00847 <span class="comment">   contains an apostrophe, a comma, or backslash (other than</span>
<a name="l00848"></a>00848 <span class="comment">   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is</span>
<a name="l00849"></a>00849 <span class="comment">   null, do not copy; instead, return the length of what the result</span>
<a name="l00850"></a>00850 <span class="comment">   would have been.  */</span>
<a name="l00851"></a>00851 <span class="keyword">static</span> size_t
<a name="l00852"></a>00852 yytnamerr (<span class="keywordtype">char</span> *yyres, <span class="keyword">const</span> <span class="keywordtype">char</span> *yystr)
<a name="l00853"></a>00853 {
<a name="l00854"></a>00854   <span class="keywordflow">if</span> (*yystr == <span class="charliteral">'"'</span>)
<a name="l00855"></a>00855     {
<a name="l00856"></a>00856       size_t yyn = 0;
<a name="l00857"></a>00857       <span class="keywordtype">char</span> <span class="keyword">const</span> *yyp = yystr;
<a name="l00858"></a>00858 
<a name="l00859"></a>00859       <span class="keywordflow">for</span> (;;)
<a name="l00860"></a>00860         <span class="keywordflow">switch</span> (*++yyp)
<a name="l00861"></a>00861           {
<a name="l00862"></a>00862           <span class="keywordflow">case</span> <span class="charliteral">'\''</span>:
<a name="l00863"></a>00863           <span class="keywordflow">case</span> <span class="charliteral">','</span>:
<a name="l00864"></a>00864             <span class="keywordflow">goto</span> do_not_strip_quotes;
<a name="l00865"></a>00865 
<a name="l00866"></a>00866           <span class="keywordflow">case</span> <span class="charliteral">'\\'</span>:
<a name="l00867"></a>00867             <span class="keywordflow">if</span> (*++yyp != <span class="charliteral">'\\'</span>)
<a name="l00868"></a>00868               <span class="keywordflow">goto</span> do_not_strip_quotes;
<a name="l00869"></a>00869             <span class="comment">/* Fall through.  */</span>
<a name="l00870"></a>00870           <span class="keywordflow">default</span>:
<a name="l00871"></a>00871             <span class="keywordflow">if</span> (yyres)
<a name="l00872"></a>00872               yyres[yyn] = *yyp;
<a name="l00873"></a>00873             yyn++;
<a name="l00874"></a>00874             <span class="keywordflow">break</span>;
<a name="l00875"></a>00875 
<a name="l00876"></a>00876           <span class="keywordflow">case</span> <span class="charliteral">'"'</span>:
<a name="l00877"></a>00877             <span class="keywordflow">if</span> (yyres)
<a name="l00878"></a>00878               yyres[yyn] = <span class="charliteral">'\0'</span>;
<a name="l00879"></a>00879             <span class="keywordflow">return</span> yyn;
<a name="l00880"></a>00880           }
<a name="l00881"></a>00881     do_not_strip_quotes: ;
<a name="l00882"></a>00882     }
<a name="l00883"></a>00883 
<a name="l00884"></a>00884   <span class="keywordflow">if</span> (! yyres)
<a name="l00885"></a>00885     <span class="keywordflow">return</span> strlen (yystr);
<a name="l00886"></a>00886 
<a name="l00887"></a>00887   <span class="keywordflow">return</span> yystpcpy (yyres, yystr) - yyres;
<a name="l00888"></a>00888 }
<a name="l00889"></a>00889 <span class="preprocessor"># endif</span>
<a name="l00890"></a>00890 <span class="preprocessor"></span>
<a name="l00891"></a>00891 <span class="preprocessor">#endif </span><span class="comment">/* !YYERROR_VERBOSE */</span>
<a name="l00892"></a>00892 
<a name="l00894"></a>00894 <span class="keyword">typedef</span> <span class="keywordtype">int</span> yyStateNum;
<a name="l00895"></a>00895 
<a name="l00897"></a>00897 <span class="keyword">typedef</span> <span class="keywordtype">int</span> yyRuleNum;
<a name="l00898"></a>00898 
<a name="l00900"></a>00900 <span class="keyword">typedef</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yySymbol;
<a name="l00901"></a>00901 
<a name="l00903"></a>00903 <span class="keyword">typedef</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span> yyItemNum;
<a name="l00904"></a>00904 
<a name="l00905"></a>00905 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structyyGLRState.html">yyGLRState</a> yyGLRState;
<a name="l00906"></a>00906 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structyySemanticOption.html">yySemanticOption</a> yySemanticOption;
<a name="l00907"></a>00907 <span class="keyword">typedef</span> <span class="keyword">union </span><a class="code" href="unionyyGLRStackItem.html">yyGLRStackItem</a> yyGLRStackItem;
<a name="l00908"></a>00908 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structyyGLRStack.html">yyGLRStack</a> yyGLRStack;
<a name="l00909"></a>00909 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structyyGLRStateSet.html">yyGLRStateSet</a> yyGLRStateSet;
<a name="l00910"></a>00910 
<a name="l00911"></a><a class="code" href="structyyGLRState.html">00911</a> <span class="keyword">struct </span>yyGLRState {
<a name="l00913"></a><a class="code" href="structyyGLRState.html#3188b3d0b913f2f6f2ff1c56dc8b8231">00913</a>   yybool <a class="code" href="structyyGLRState.html#3188b3d0b913f2f6f2ff1c56dc8b8231">yyisState</a>;
<a name="l00916"></a><a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">00916</a>   yybool <a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a>;
<a name="l00918"></a><a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">00918</a>   yyStateNum <a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>;
<a name="l00920"></a><a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">00920</a>   yyGLRState* <a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>;
<a name="l00922"></a><a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">00922</a>   size_t <a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a>;
<a name="l00923"></a>00923   <span class="keyword">union </span>{
<a name="l00927"></a><a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">00927</a>     yySemanticOption* <a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a>;
<a name="l00929"></a><a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">00929</a>     YYSTYPE <a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">yysval</a>;
<a name="l00930"></a>00930   } yysemantics;
<a name="l00932"></a><a class="code" href="structyyGLRState.html#c6143618fb4276d3f8d6030b2f61f26d">00932</a>   <a class="code" href="structYYLTYPE.html">YYLTYPE</a> <a class="code" href="structyyGLRState.html#c6143618fb4276d3f8d6030b2f61f26d">yyloc</a>;
<a name="l00933"></a>00933 };
<a name="l00934"></a>00934 
<a name="l00935"></a><a class="code" href="structyyGLRStateSet.html">00935</a> <span class="keyword">struct </span>yyGLRStateSet {
<a name="l00936"></a><a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">00936</a>   yyGLRState** <a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>;
<a name="l00937"></a><a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">00937</a>   size_t <a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a>, <a class="code" href="structyyGLRStateSet.html#7aa2c0441b518c4be69b712943b263af">yycapacity</a>;
<a name="l00938"></a>00938 };
<a name="l00939"></a>00939 
<a name="l00940"></a><a class="code" href="structyySemanticOption.html">00940</a> <span class="keyword">struct </span>yySemanticOption {
<a name="l00942"></a><a class="code" href="structyySemanticOption.html#01f332a0b1efba6c627889e849d34e63">00942</a>   yybool <a class="code" href="structyySemanticOption.html#01f332a0b1efba6c627889e849d34e63">yyisState</a>;
<a name="l00944"></a><a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">00944</a>   yyRuleNum <a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>;
<a name="l00946"></a><a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">00946</a>   yyGLRState* <a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>;
<a name="l00949"></a><a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">00949</a>   yySemanticOption* <a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a>;
<a name="l00950"></a>00950 };
<a name="l00951"></a>00951 
<a name="l00954"></a><a class="code" href="unionyyGLRStackItem.html">00954</a> <span class="keyword">union </span>yyGLRStackItem {
<a name="l00955"></a><a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">00955</a>   yyGLRState <a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>;
<a name="l00956"></a><a class="code" href="unionyyGLRStackItem.html#3d0f2eae1a1434c0ea04b183df701cc3">00956</a>   yySemanticOption <a class="code" href="unionyyGLRStackItem.html#3d0f2eae1a1434c0ea04b183df701cc3">yyoption</a>;
<a name="l00957"></a>00957 };
<a name="l00958"></a>00958 
<a name="l00959"></a><a class="code" href="structyyGLRStack.html">00959</a> <span class="keyword">struct </span>yyGLRStack {
<a name="l00960"></a><a class="code" href="structyyGLRStack.html#ed6f3ec7244916a7970aefd460d1b9bd">00960</a>   <span class="keywordtype">int</span> <a class="code" href="structyyGLRStack.html#ed6f3ec7244916a7970aefd460d1b9bd">yyerrState</a>;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 
<a name="l00963"></a><a class="code" href="structyyGLRStack.html#37f2d643591b4f494ada5e3e96dcf873">00963</a>   yySymbol* <a class="code" href="structyyGLRStack.html#37f2d643591b4f494ada5e3e96dcf873">yytokenp</a>;
<a name="l00964"></a><a class="code" href="structyyGLRStack.html#24afd02f338a725e3fa6362be3dc5936">00964</a>   YYJMP_BUF <a class="code" href="structyyGLRStack.html#24afd02f338a725e3fa6362be3dc5936">yyexception_buffer</a>;
<a name="l00965"></a><a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">00965</a>   yyGLRStackItem* <a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>;
<a name="l00966"></a><a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">00966</a>   yyGLRStackItem* <a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a>;
<a name="l00967"></a><a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">00967</a>   size_t <a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a>;
<a name="l00968"></a><a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">00968</a>   yyGLRState* <a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a>;
<a name="l00969"></a><a class="code" href="structyyGLRStack.html#142add5df99046684b32fc4a1aaff471">00969</a>   yyGLRState* <a class="code" href="structyyGLRStack.html#142add5df99046684b32fc4a1aaff471">yylastDeleted</a>;
<a name="l00970"></a><a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">00970</a>   yyGLRStateSet <a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>;
<a name="l00971"></a>00971 };
<a name="l00972"></a>00972 
<a name="l00973"></a>00973 <span class="keyword">static</span> <span class="keywordtype">void</span> yyexpandGLRStack (yyGLRStack* yystack);
<a name="l00974"></a>00974 
<a name="l00975"></a>00975 <span class="keyword">static</span> <span class="keywordtype">void</span> yyFail (yyGLRStack* yystack, <span class="keyword">const</span> <span class="keywordtype">char</span>* yymsg)
<a name="l00976"></a>00976   __attribute__ ((__noreturn__));
<a name="l00977"></a>00977 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00978"></a>00978 yyFail (yyGLRStack* yystack, <span class="keyword">const</span> <span class="keywordtype">char</span>* yymsg)
<a name="l00979"></a>00979 {
<a name="l00980"></a>00980   <span class="keywordflow">if</span> (yymsg != NULL)
<a name="l00981"></a>00981     yyerror (yymsg);
<a name="l00982"></a>00982   YYLONGJMP (yystack-&gt;<a class="code" href="structyyGLRStack.html#24afd02f338a725e3fa6362be3dc5936">yyexception_buffer</a>, 1);
<a name="l00983"></a>00983 }
<a name="l00984"></a>00984 
<a name="l00985"></a>00985 <span class="keyword">static</span> <span class="keywordtype">void</span> yyMemoryExhausted (yyGLRStack* yystack)
<a name="l00986"></a>00986   __attribute__ ((__noreturn__));
<a name="l00987"></a>00987 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00988"></a>00988 yyMemoryExhausted (yyGLRStack* yystack)
<a name="l00989"></a>00989 {
<a name="l00990"></a>00990   YYLONGJMP (yystack-&gt;<a class="code" href="structyyGLRStack.html#24afd02f338a725e3fa6362be3dc5936">yyexception_buffer</a>, 2);
<a name="l00991"></a>00991 }
<a name="l00992"></a>00992 
<a name="l00993"></a>00993 <span class="preprocessor">#if YYDEBUG || YYERROR_VERBOSE</span>
<a name="l00994"></a>00994 <span class="preprocessor"></span>
<a name="l00995"></a>00995 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>*
<a name="l00996"></a>00996 yytokenName (yySymbol yytoken)
<a name="l00997"></a>00997 {
<a name="l00998"></a>00998   <span class="keywordflow">if</span> (yytoken == YYEMPTY)
<a name="l00999"></a>00999     <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
<a name="l01000"></a>01000 
<a name="l01001"></a>01001   <span class="keywordflow">if</span> (yytoken &lt; 0) { <span class="keywordtype">char</span>* buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[1]; buf[0]=<span class="charliteral">'\0'</span>; <span class="keywordflow">return</span> buf; } <span class="keywordflow">return</span> yytname[yytoken];
<a name="l01002"></a>01002 }
<a name="l01003"></a>01003 <span class="preprocessor">#endif</span>
<a name="l01004"></a>01004 <span class="preprocessor"></span>
<a name="l01009"></a>01009 <span class="keyword">static</span> <span class="keywordtype">void</span> yyfillin (yyGLRStackItem *, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>) __attribute__ ((__unused__));
<a name="l01010"></a>01010 static <span class="keywordtype">void</span>
<a name="l01011"></a>01011 yyfillin (yyGLRStackItem *yyvsp, <span class="keywordtype">int</span> yylow0, <span class="keywordtype">int</span> yylow1)
<a name="l01012"></a>01012 {
<a name="l01013"></a>01013   yyGLRState* s;
<a name="l01014"></a>01014   <span class="keywordtype">int</span> i;
<a name="l01015"></a>01015   s = yyvsp[yylow0].yystate.<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>;
<a name="l01016"></a>01016   <span class="keywordflow">for</span> (i = yylow0-1; i &gt;= yylow1; i -= 1)
<a name="l01017"></a>01017     {
<a name="l01018"></a>01018       YYASSERT (s-&gt;<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a>);
<a name="l01019"></a>01019       yyvsp[i].yystate.<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a> = yytrue;
<a name="l01020"></a>01020       yyvsp[i].yystate.yysemantics.yysval = s-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">yysval</a>;
<a name="l01021"></a>01021       yyvsp[i].yystate.yyloc = s-&gt;<a class="code" href="structyyGLRState.html#c6143618fb4276d3f8d6030b2f61f26d">yyloc</a>;
<a name="l01022"></a>01022       s = yyvsp[i].yystate.<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a> = s-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>;
<a name="l01023"></a>01023     }
<a name="l01024"></a>01024 }
<a name="l01025"></a>01025 
<a name="l01026"></a>01026 <span class="comment">/* Do nothing if YYNORMAL or if *YYLOW &lt;= YYLOW1.  Otherwise, fill in</span>
<a name="l01027"></a>01027 <span class="comment">   YYVSP[YYLOW1 .. *YYLOW-1] as in yyfillin and set *YYLOW = YYLOW1.</span>
<a name="l01028"></a>01028 <span class="comment">   For convenience, always return YYLOW1.  */</span>
<a name="l01029"></a>01029 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> yyfill (yyGLRStackItem *, <span class="keywordtype">int</span> *, <span class="keywordtype">int</span>, yybool)
<a name="l01030"></a>01030      __attribute__ ((__unused__));
<a name="l01031"></a>01031 static inline <span class="keywordtype">int</span>
<a name="l01032"></a>01032 yyfill (yyGLRStackItem *yyvsp, <span class="keywordtype">int</span> *yylow, <span class="keywordtype">int</span> yylow1, yybool yynormal)
<a name="l01033"></a>01033 {
<a name="l01034"></a>01034   <span class="keywordflow">if</span> (!yynormal &amp;&amp; yylow1 &lt; *yylow)
<a name="l01035"></a>01035     {
<a name="l01036"></a>01036       yyfillin (yyvsp, *yylow, yylow1);
<a name="l01037"></a>01037       *yylow = yylow1;
<a name="l01038"></a>01038     }
<a name="l01039"></a>01039   <span class="keywordflow">return</span> yylow1;
<a name="l01040"></a>01040 }
<a name="l01041"></a>01041 
<a name="l01047"></a>01047 <span class="keyword">static</span> YYRESULTTAG
<a name="l01048"></a>01048 yyuserAction (yyRuleNum yyn, <span class="keywordtype">int</span> yyrhslen, yyGLRStackItem* yyvsp,
<a name="l01049"></a>01049               YYSTYPE* yyvalp,
<a name="l01050"></a>01050               <a class="code" href="structYYLTYPE.html">YYLTYPE</a>* YYOPTIONAL_LOC (yylocp),
<a name="l01051"></a>01051               yyGLRStack* yystack
<a name="l01052"></a>01052               )
<a name="l01053"></a>01053 {
<a name="l01054"></a>01054   yybool yynormal __attribute__ ((__unused__)) =
<a name="l01055"></a>01055     (yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> == NULL);
<a name="l01056"></a>01056   <span class="keywordtype">int</span> yylow;
<a name="l01057"></a>01057 
<a name="l01058"></a>01058 <span class="preprocessor"># undef yyerrok</span>
<a name="l01059"></a>01059 <span class="preprocessor"></span><span class="preprocessor"># define yyerrok (yystack-&gt;yyerrState = 0)</span>
<a name="l01060"></a>01060 <span class="preprocessor"></span><span class="preprocessor"># undef YYACCEPT</span>
<a name="l01061"></a>01061 <span class="preprocessor"></span><span class="preprocessor"># define YYACCEPT return yyaccept</span>
<a name="l01062"></a>01062 <span class="preprocessor"></span><span class="preprocessor"># undef YYABORT</span>
<a name="l01063"></a>01063 <span class="preprocessor"></span><span class="preprocessor"># define YYABORT return yyabort</span>
<a name="l01064"></a>01064 <span class="preprocessor"></span><span class="preprocessor"># undef YYERROR</span>
<a name="l01065"></a>01065 <span class="preprocessor"></span><span class="preprocessor"># define YYERROR return yyerrok, yyerr</span>
<a name="l01066"></a>01066 <span class="preprocessor"></span><span class="preprocessor"># undef YYRECOVERING</span>
<a name="l01067"></a>01067 <span class="preprocessor"></span><span class="preprocessor"># define YYRECOVERING (yystack-&gt;yyerrState != 0)</span>
<a name="l01068"></a>01068 <span class="preprocessor"></span><span class="preprocessor"># undef yyclearin</span>
<a name="l01069"></a>01069 <span class="preprocessor"></span><span class="preprocessor"># define yyclearin (yychar = *(yystack-&gt;yytokenp) = YYEMPTY)</span>
<a name="l01070"></a>01070 <span class="preprocessor"></span><span class="preprocessor"># undef YYFILL</span>
<a name="l01071"></a>01071 <span class="preprocessor"></span><span class="preprocessor"># define YYFILL(N) yyfill (yyvsp, &amp;yylow, N, yynormal)</span>
<a name="l01072"></a>01072 <span class="preprocessor"></span><span class="preprocessor"># undef YYBACKUP</span>
<a name="l01073"></a>01073 <span class="preprocessor"></span><span class="preprocessor"># define YYBACKUP(Token, Value)                                              \</span>
<a name="l01074"></a>01074 <span class="preprocessor">  return yyerror (YY_("parse error: cannot back up")),     \</span>
<a name="l01075"></a>01075 <span class="preprocessor">         yyerrok, yyerr</span>
<a name="l01076"></a>01076 <span class="preprocessor"></span>
<a name="l01077"></a>01077   yylow = 1;
<a name="l01078"></a>01078   <span class="keywordflow">if</span> (yyrhslen == 0)
<a name="l01079"></a>01079     *yyvalp = yyval_default;
<a name="l01080"></a>01080   <span class="keywordflow">else</span>
<a name="l01081"></a>01081     *yyvalp = yyvsp[YYFILL (1-yyrhslen)].<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">yysval</a>;
<a name="l01082"></a>01082   YYLLOC_DEFAULT (*yylocp, yyvsp - yyrhslen, yyrhslen);
<a name="l01083"></a>01083 
<a name="l01084"></a>01084   <span class="keywordflow">switch</span> (yyn)
<a name="l01085"></a>01085     {
<a name="l01086"></a>01086         <span class="keywordflow">case</span> 2:
<a name="l01087"></a>01087 <span class="preprocessor">#line 114 "../src/parser/fol.y"</span>
<a name="l01088"></a>01088 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"input: empty\n"</span>); ;}
<a name="l01089"></a>01089     <span class="keywordflow">break</span>;
<a name="l01090"></a>01090 
<a name="l01091"></a>01091   <span class="keywordflow">case</span> 3:
<a name="l01092"></a>01092 <span class="preprocessor">#line 117 "../src/parser/fol.y"</span>
<a name="l01093"></a>01093 <span class="preprocessor"></span>    { 
<a name="l01094"></a>01094     yyerrok; <span class="comment">// tell Bison not to suppress any errors</span>
<a name="l01095"></a>01095     <span class="keyword">const</span> <span class="keywordtype">char</span>* tok; 
<a name="l01096"></a>01096     <span class="keywordflow">while</span> (<span class="keyword">true</span>)
<a name="l01097"></a>01097     {
<a name="l01098"></a>01098       tok = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01099"></a>01099       <span class="keywordflow">if</span> (strcmp(tok,<span class="stringliteral">"\n"</span>)==0) { <span class="keyword">delete</span> tok; <span class="keywordflow">break</span>; }
<a name="l01100"></a>01100       <span class="keyword">delete</span> tok;
<a name="l01101"></a>01101     }
<a name="l01102"></a>01102   ;}
<a name="l01103"></a>01103     <span class="keywordflow">break</span>;
<a name="l01104"></a>01104 
<a name="l01105"></a>01105   <span class="keywordflow">case</span> 13:
<a name="l01106"></a>01106 <span class="preprocessor">#line 141 "../src/parser/fol.y"</span>
<a name="l01107"></a>01107 <span class="preprocessor"></span>    { 
<a name="l01108"></a>01108     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"input: weight\n"</span>); 
<a name="l01109"></a>01109     zzreset();
<a name="l01110"></a>01110   ;}
<a name="l01111"></a>01111     <span class="keywordflow">break</span>;
<a name="l01112"></a>01112 
<a name="l01113"></a>01113   <span class="keywordflow">case</span> 14:
<a name="l01114"></a>01114 <span class="preprocessor">#line 146 "../src/parser/fol.y"</span>
<a name="l01115"></a>01115 <span class="preprocessor"></span>    {  
<a name="l01116"></a>01116     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"input: sentence\n"</span>);
<a name="l01117"></a>01117       <span class="comment">// the states should be reset because a parse error may have occurred</span>
<a name="l01118"></a>01118   ;}
<a name="l01119"></a>01119     <span class="keywordflow">break</span>;
<a name="l01120"></a>01120 
<a name="l01121"></a>01121   <span class="keywordflow">case</span> 15:
<a name="l01122"></a>01122 <span class="preprocessor">#line 151 "../src/parser/fol.y"</span>
<a name="l01123"></a>01123 <span class="preprocessor"></span>    {
<a name="l01124"></a>01124 
<a name="l01125"></a>01125     <a class="code" href="classListObj.html">ListObj</a>* formula;
<a name="l01126"></a>01126     zzassert(zzoldNewVarList.size()==0,<span class="stringliteral">"expected zzoldNewVarList.size()==0"</span>);
<a name="l01127"></a>01127     zzassert(zzformulaListObjs.size()==1,<span class="stringliteral">"expected zzformulaListObjs.size()=1"</span>);
<a name="l01128"></a>01128         formula = zzformulaListObjs.top(); zzformulaListObjs.pop();
<a name="l01129"></a>01129 
<a name="l01130"></a>01130         zzdetermineEqPredTypes(formula);<span class="comment">//set the any unknown type of '=' predicates</span>
<a name="l01131"></a>01131     zzeqPredList.clear();
<a name="l01132"></a>01132         zzdetermineIntPredTypes(formula);<span class="comment">//set the any unknown type of internal predicates</span>
<a name="l01133"></a>01133     zzintPredList.clear();
<a name="l01134"></a>01134         zzdetermineIntFuncTypes(formula);<span class="comment">//set the any unknown type of internal functions</span>
<a name="l01135"></a>01135     zzintFuncList.clear();
<a name="l01136"></a>01136     zzsetPlusVarTypeId();<span class="comment">// set typeIds of variables with pluses before them</span>
<a name="l01137"></a>01137     zzcheckVarNameToIdMap();
<a name="l01138"></a>01138     
<a name="l01139"></a>01139     <span class="keywordflow">if</span> (zzhasFullStop &amp;&amp; zzwt != NULL)
<a name="l01140"></a>01140     {
<a name="l01141"></a>01141       zzerr(<span class="stringliteral">"A weight must not be specified for a formula that is "</span>
<a name="l01142"></a>01142             <span class="stringliteral">"terminated with a period (i.e. the formula is hard)."</span>);
<a name="l01143"></a>01143       <span class="keyword">delete</span> zzwt; zzwt = NULL;
<a name="l01144"></a>01144     }
<a name="l01145"></a>01145         
<a name="l01146"></a>01146     <span class="comment">// at this point we are sure we are dealing with a formula</span>
<a name="l01147"></a>01147 
<a name="l01148"></a>01148     <span class="comment">//if the '!' operator is used, check that it's correctly used</span>
<a name="l01149"></a>01149     <span class="keywordflow">if</span> (zzuniqueVarIndexes.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() &gt; 0)
<a name="l01150"></a>01150     { 
<a name="l01151"></a>01151       <span class="keywordflow">if</span> (zzfdnumPreds != 1 || zznumAsterisk &gt; 0)
<a name="l01152"></a>01152         zzerr(<span class="stringliteral">"'!' can only be used in a clause with one predicate, "</span>
<a name="l01153"></a>01153               <span class="stringliteral">"and cannot be used with '*'."</span>);
<a name="l01154"></a>01154       <span class="keywordflow">if</span> (zzformulaStr.find(<span class="stringliteral">"EXIST"</span>) != string::npos || 
<a name="l01155"></a>01155           zzformulaStr.find(<span class="stringliteral">"FORALL"</span>) != string::npos)
<a name="l01156"></a>01156         zzerr(<span class="stringliteral">"'!' cannot be used with quantifiers"</span>);
<a name="l01157"></a>01157     }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159       <span class="comment">//if there are errors, we can keep this formula for further processing</span>
<a name="l01160"></a>01160     <span class="keywordflow">if</span> (zznumErrors == 0)
<a name="l01161"></a>01161     {
<a name="l01162"></a>01162         <span class="comment">//defer converting the formula to CNF until we have read all the</span>
<a name="l01163"></a>01163         <span class="comment">//.db files and are sure that we know all the constants to ground</span>
<a name="l01164"></a>01164         <span class="comment">//formula's clauses</span>
<a name="l01165"></a>01165             <a class="code" href="structZZFormulaInfo.html">ZZFormulaInfo</a>* epfi 
<a name="l01166"></a>01166         = <span class="keyword">new</span> <a class="code" href="structZZFormulaInfo.html">ZZFormulaInfo</a>(formula, zzformulaStr, zzfdnumPreds, zzwt, 
<a name="l01167"></a>01167                             zzdefaultWt, zzdomain, zzmln, zzvarNameToIdMap, 
<a name="l01168"></a>01168                             zzplusVarMap, zznumAsterisk, zzuniqueVarIndexes,
<a name="l01169"></a>01169                             zzhasFullStop, zzreadHardClauseWts, 
<a name="l01170"></a>01170                             zzmustHaveWtOrFullStop);
<a name="l01171"></a>01171       zzformulaInfos.append(epfi); 
<a name="l01172"></a>01172     }
<a name="l01173"></a>01173 
<a name="l01174"></a>01174     <span class="keywordflow">if</span> (zzwt) { <span class="keyword">delete</span> zzwt; zzwt = NULL; }
<a name="l01175"></a>01175   ;}
<a name="l01176"></a>01176     <span class="keywordflow">break</span>;
<a name="l01177"></a>01177 
<a name="l01178"></a>01178   <span class="keywordflow">case</span> 17:
<a name="l01179"></a>01179 <span class="preprocessor">#line 209 "../src/parser/fol.y"</span>
<a name="l01180"></a>01180 <span class="preprocessor"></span>    { zzconsumeToken(zztokenList,<span class="stringliteral">"@"</span>); ;}
<a name="l01181"></a>01181     <span class="keywordflow">break</span>;
<a name="l01182"></a>01182 
<a name="l01183"></a>01183   <span class="keywordflow">case</span> 18:
<a name="l01184"></a>01184 <span class="preprocessor">#line 210 "../src/parser/fol.y"</span>
<a name="l01185"></a>01185 <span class="preprocessor"></span>    { zzconsumeToken(zztokenList,<span class="stringliteral">"@"</span>); ;}
<a name="l01186"></a>01186     <span class="keywordflow">break</span>;
<a name="l01187"></a>01187 
<a name="l01188"></a>01188   <span class="keywordflow">case</span> 20:
<a name="l01189"></a>01189 <span class="preprocessor">#line 217 "../src/parser/fol.y"</span>
<a name="l01190"></a>01190 <span class="preprocessor"></span>    { 
<a name="l01191"></a>01191   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">".\n"</span>); zzconsumeToken(zztokenList,<span class="stringliteral">"."</span>); 
<a name="l01192"></a>01192   zzassert(!zzhasFullStop, <span class="stringliteral">"expecting no full stop"</span>);
<a name="l01193"></a>01193   zzhasFullStop = <span class="keyword">true</span>;
<a name="l01194"></a>01194   zzformulaStr.append(<span class="stringliteral">"."</span>);
<a name="l01195"></a>01195 ;}
<a name="l01196"></a>01196     <span class="keywordflow">break</span>;
<a name="l01197"></a>01197 
<a name="l01198"></a>01198   <span class="keywordflow">case</span> 21:
<a name="l01199"></a>01199 <span class="preprocessor">#line 226 "../src/parser/fol.y"</span>
<a name="l01200"></a>01200 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"\\n\n"</span>); zzconsumeToken(zztokenList,<span class="stringliteral">"\n"</span>); ;}
<a name="l01201"></a>01201     <span class="keywordflow">break</span>;
<a name="l01202"></a>01202 
<a name="l01203"></a>01203   <span class="keywordflow">case</span> 22:
<a name="l01204"></a>01204 <span class="preprocessor">#line 228 "../src/parser/fol.y"</span>
<a name="l01205"></a>01205 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"\\r\n"</span>); zzconsumeToken(zztokenList,<span class="stringliteral">"\r"</span>); ;}
<a name="l01206"></a>01206     <span class="keywordflow">break</span>;
<a name="l01207"></a>01207 
<a name="l01208"></a>01208   <span class="keywordflow">case</span> 24:
<a name="l01209"></a>01209 <span class="preprocessor">#line 234 "../src/parser/fol.y"</span>
<a name="l01210"></a>01210 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"\\n\n"</span>); zzconsumeToken(zztokenList,<span class="stringliteral">"\n"</span>); ;}
<a name="l01211"></a>01211     <span class="keywordflow">break</span>;
<a name="l01212"></a>01212 
<a name="l01213"></a>01213   <span class="keywordflow">case</span> 25:
<a name="l01214"></a>01214 <span class="preprocessor">#line 236 "../src/parser/fol.y"</span>
<a name="l01215"></a>01215 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"\\r\n"</span>); zzconsumeToken(zztokenList,<span class="stringliteral">"\r"</span>); ;}
<a name="l01216"></a>01216     <span class="keywordflow">break</span>;
<a name="l01217"></a>01217 
<a name="l01218"></a>01218   <span class="keywordflow">case</span> 26:
<a name="l01219"></a>01219 <span class="preprocessor">#line 243 "../src/parser/fol.y"</span>
<a name="l01220"></a>01220 <span class="preprocessor"></span>    {
<a name="l01221"></a>01221   <span class="keyword">const</span> <span class="keywordtype">char</span>* inc = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01222"></a>01222   <span class="keyword">const</span> <span class="keywordtype">char</span>* str = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01223"></a>01223   <span class="keyword">const</span> <span class="keywordtype">char</span>* nl = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01224"></a>01224   zzassert(strcmp(inc,<span class="stringliteral">"#include"</span>)==0,<span class="stringliteral">"expecting #include keyword"</span>);
<a name="l01225"></a>01225 
<a name="l01226"></a>01226   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"#include %s "</span>, str);
<a name="l01227"></a>01227 
<a name="l01228"></a>01228   string s(str);
<a name="l01229"></a>01229   <span class="keywordflow">if</span> (s.length() == 0)
<a name="l01230"></a>01230   {
<a name="l01231"></a>01231     zzerr(<span class="stringliteral">"empty string used with #include"</span>);
<a name="l01232"></a>01232     <span class="keyword">delete</span> [] inc;
<a name="l01233"></a>01233     <span class="keyword">delete</span> [] str;
<a name="l01234"></a>01234     <span class="keyword">delete</span> [] nl;
<a name="l01235"></a>01235     <span class="keywordflow">break</span>;
<a name="l01236"></a>01236   }
<a name="l01237"></a>01237 
<a name="l01238"></a>01238   zzassert(s.at(0) == <span class="charliteral">'"'</span> &amp;&amp; s.at(s.length()-1) == <span class="charliteral">'"'</span>, <span class="stringliteral">"no enclosing \""</span>);
<a name="l01239"></a>01239   s = s.substr(1, s.length()-2);
<a name="l01240"></a>01240   <span class="keywordtype">int</span> len = s.length();
<a name="l01241"></a>01241 
<a name="l01242"></a>01242   <span class="comment">// if it is a .cpp file, then we are dealing with linked-in functions and predicates</span>
<a name="l01243"></a>01243   <span class="keywordflow">if</span> (s.at(len-4)==<span class="charliteral">'.'</span> &amp;&amp; s.at(len-3)==<span class="charliteral">'c'</span> &amp;&amp; s.at(len-2)==<span class="charliteral">'p'</span> &amp;&amp;
<a name="l01244"></a>01244           s.at(len-1)==<span class="charliteral">'p'</span>) {
<a name="l01245"></a>01245         
<a name="l01246"></a>01246         zzcompileFunctions(str);
<a name="l01247"></a>01247         zzusingLinkedPredicates = <span class="keyword">true</span>;    
<a name="l01248"></a>01248         zzusingLinkedFunctions = <span class="keyword">true</span>;    
<a name="l01249"></a>01249     <span class="keywordflow">break</span>;
<a name="l01250"></a>01250   }
<a name="l01251"></a>01251 
<a name="l01252"></a>01252   FILE* newin = fopen(s.c_str(), <span class="stringliteral">"r"</span> );
<a name="l01253"></a>01253   <span class="keywordflow">if</span> (newin)
<a name="l01254"></a>01254   {
<a name="l01255"></a>01255     zzinStack.push(<a class="code" href="structZZFileState.html">ZZFileState</a>(yyin, string(zzinFileName), zznumCharRead, 
<a name="l01256"></a>01256                                zzline, zzcolumn)); 
<a name="l01257"></a>01257     ungetc(<span class="charliteral">'\n'</span>, newin); <span class="comment">// pretend that file begins with a newline</span>
<a name="l01258"></a>01258     zzline = 1;
<a name="l01259"></a>01259     zzcolumn = -1;
<a name="l01260"></a>01260     zzline--;
<a name="l01261"></a>01261     zzinFileName = str;
<a name="l01262"></a>01262     yyrestart(newin); 
<a name="l01263"></a>01263     zznumCharRead = 0;
<a name="l01264"></a>01264 
<a name="l01265"></a>01265     <span class="comment">// if it is a .db file containing ground predicates</span>
<a name="l01266"></a>01266     <span class="keywordflow">if</span> ((s.at(len-3)==<span class="charliteral">'.'</span> &amp;&amp; s.at(len-2)==<span class="charliteral">'d'</span> &amp;&amp; s.at(len-1)==<span class="charliteral">'b'</span>))
<a name="l01267"></a>01267 <span class="comment">//      ||</span>
<a name="l01268"></a>01268 <span class="comment">//      (s.at(len-5)=='.' &amp;&amp; s.at(len-4)=='f' &amp;&amp; s.at(len-3)=='u' &amp;&amp;</span>
<a name="l01269"></a>01269 <span class="comment">//      s.at(len-2)=='n' &amp;&amp; s.at(len-1)=='c'))</span>
<a name="l01270"></a>01270         zzparseGroundPred = <span class="keyword">true</span>;
<a name="l01271"></a>01271   } 
<a name="l01272"></a>01272   <span class="keywordflow">else</span>
<a name="l01273"></a>01273     zzerr(<span class="stringliteral">"Failed to open file %s."</span>, str);
<a name="l01274"></a>01274   
<a name="l01275"></a>01275   <span class="keyword">delete</span> [] inc;
<a name="l01276"></a>01276   <span class="keyword">delete</span> [] str;
<a name="l01277"></a>01277   <span class="keyword">delete</span> [] nl;
<a name="l01278"></a>01278 ;}
<a name="l01279"></a>01279     <span class="keywordflow">break</span>;
<a name="l01280"></a>01280 
<a name="l01281"></a>01281   <span class="keywordflow">case</span> 27:
<a name="l01282"></a>01282 <span class="preprocessor">#line 305 "../src/parser/fol.y"</span>
<a name="l01283"></a>01283 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"\\n\n"</span>); ;}
<a name="l01284"></a>01284     <span class="keywordflow">break</span>;
<a name="l01285"></a>01285 
<a name="l01286"></a>01286   <span class="keywordflow">case</span> 28:
<a name="l01287"></a>01287 <span class="preprocessor">#line 307 "../src/parser/fol.y"</span>
<a name="l01288"></a>01288 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"\\r\n"</span>); ;}
<a name="l01289"></a>01289     <span class="keywordflow">break</span>;
<a name="l01290"></a>01290 
<a name="l01291"></a>01291   <span class="keywordflow">case</span> 29:
<a name="l01292"></a>01292 <span class="preprocessor">#line 318 "../src/parser/fol.y"</span>
<a name="l01293"></a>01293 <span class="preprocessor"></span>    { 
<a name="l01294"></a>01294   zzconsumeToken(zztokenList,<span class="stringliteral">"="</span>);
<a name="l01295"></a>01295   zzconsumeToken(zztokenList,<span class="stringliteral">"{"</span>);
<a name="l01296"></a>01296   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"= { "</span>); 
<a name="l01297"></a>01297   <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"type_declarations: constant_declarations\n"</span>);
<a name="l01298"></a>01298 ;}
<a name="l01299"></a>01299     <span class="keywordflow">break</span>;
<a name="l01300"></a>01300 
<a name="l01301"></a>01301   <span class="keywordflow">case</span> 30:
<a name="l01302"></a>01302 <span class="preprocessor">#line 326 "../src/parser/fol.y"</span>
<a name="l01303"></a>01303 <span class="preprocessor"></span>    {
<a name="l01304"></a>01304   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"} "</span>);           
<a name="l01305"></a>01305   zzconsumeToken(zztokenList, <span class="stringliteral">"}"</span>);
<a name="l01306"></a>01306   <span class="keyword">delete</span> [] zztypeName;
<a name="l01307"></a>01307   zztypeName = NULL;
<a name="l01308"></a>01308 ;}
<a name="l01309"></a>01309     <span class="keywordflow">break</span>;
<a name="l01310"></a>01310 
<a name="l01311"></a>01311   <span class="keywordflow">case</span> 31:
<a name="l01312"></a>01312 <span class="preprocessor">#line 337 "../src/parser/fol.y"</span>
<a name="l01313"></a>01313 <span class="preprocessor"></span>    {
<a name="l01314"></a>01314   <span class="keyword">const</span> <span class="keywordtype">char</span>* idf = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01315"></a>01315   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"type t_%s "</span>, idf);
<a name="l01316"></a>01316   zzassert(!zzdomain-&gt;<a class="code" href="classDomain.html#da61369ed33763c933aeeaef87d0974b">isType</a>(idf), <span class="stringliteral">"expecting type to be undefined"</span>);
<a name="l01317"></a>01317   <span class="keywordtype">int</span> <span class="keywordtype">id</span> = zzaddTypeToDomain(zzdomain, idf);
<a name="l01318"></a>01318   zzassert(<span class="keywordtype">id</span> &gt;= 0,<span class="stringliteral">"expecting id &gt;= 0"</span>);
<a name="l01319"></a>01319   zzassert(zztypeName==NULL,<span class="stringliteral">"expecting zztypeName==NULL"</span>);
<a name="l01320"></a>01320   zztypeName = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(idf)+1];
<a name="l01321"></a>01321   strcpy(zztypeName, idf);
<a name="l01322"></a>01322   <span class="keyword">delete</span> [] idf;
<a name="l01323"></a>01323 ;}
<a name="l01324"></a>01324     <span class="keywordflow">break</span>;
<a name="l01325"></a>01325 
<a name="l01326"></a>01326   <span class="keywordflow">case</span> 32:
<a name="l01327"></a>01327 <span class="preprocessor">#line 350 "../src/parser/fol.y"</span>
<a name="l01328"></a>01328 <span class="preprocessor"></span>    {
<a name="l01329"></a>01329   <span class="keyword">const</span> <span class="keywordtype">char</span>* idf = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01330"></a>01330   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"type t_%s "</span>, idf);
<a name="l01331"></a>01331   zzassert(zzdomain-&gt;<a class="code" href="classDomain.html#da61369ed33763c933aeeaef87d0974b">isType</a>(idf),<span class="stringliteral">"expecting type to be defined"</span>);
<a name="l01332"></a>01332   <span class="comment">//zzwarn("Type %s has been declared before.",idf);</span>
<a name="l01333"></a>01333   zzassert(zztypeName==NULL,<span class="stringliteral">"expecting zztypeName==NULL"</span>);
<a name="l01334"></a>01334   zztypeName = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(idf)+1];
<a name="l01335"></a>01335   strcpy(zztypeName, idf);
<a name="l01336"></a>01336   <span class="keyword">delete</span> [] idf;
<a name="l01337"></a>01337 ;}
<a name="l01338"></a>01338     <span class="keywordflow">break</span>;
<a name="l01339"></a>01339 
<a name="l01340"></a>01340   <span class="keywordflow">case</span> 34:
<a name="l01341"></a>01341 <span class="preprocessor">#line 369 "../src/parser/fol.y"</span>
<a name="l01342"></a>01342 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"constant_declarations: ZZ_VARIABLE\n"</span>); ;}
<a name="l01343"></a>01343     <span class="keywordflow">break</span>;
<a name="l01344"></a>01344 
<a name="l01345"></a>01345   <span class="keywordflow">case</span> 35:
<a name="l01346"></a>01346 <span class="preprocessor">#line 371 "../src/parser/fol.y"</span>
<a name="l01347"></a>01347 <span class="preprocessor"></span>    {
<a name="l01348"></a>01348     <span class="keyword">const</span> <span class="keywordtype">char</span>* vsc = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01349"></a>01349     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"cd_%s "</span>, vsc);
<a name="l01350"></a>01350     <span class="keywordtype">int</span> constId = zzdomain-&gt;<a class="code" href="classDomain.html#f38c0be29eaffb326073219c18db170c">getConstantId</a>(vsc);
<a name="l01351"></a>01351     <span class="keywordflow">if</span> (constId &lt; 0)
<a name="l01352"></a>01352       zzaddConstantToDomain(vsc, zztypeName);
<a name="l01353"></a>01353     <span class="keywordflow">else</span>
<a name="l01354"></a>01354     {
<a name="l01355"></a>01355       <span class="keyword">const</span> <span class="keywordtype">char</span>* prevType = zzdomain-&gt;<a class="code" href="classDomain.html#55e763b8e14e5629ac2d0f204d13af98">getConstantTypeName</a>(constId);
<a name="l01356"></a>01356       <span class="keywordflow">if</span> (strcmp(prevType,zztypeName)!=0)
<a name="l01357"></a>01357         zzerr(<span class="stringliteral">"constant %s previously declared to be of type %s is redeclared "</span>
<a name="l01358"></a>01358               <span class="stringliteral">"to be of type %s"</span>, vsc, prevType, zztypeName);
<a name="l01359"></a>01359     }
<a name="l01360"></a>01360     <span class="keyword">delete</span> [] vsc;
<a name="l01361"></a>01361   ;}
<a name="l01362"></a>01362     <span class="keywordflow">break</span>;
<a name="l01363"></a>01363 
<a name="l01364"></a>01364   <span class="keywordflow">case</span> 40:
<a name="l01365"></a>01365 <span class="preprocessor">#line 397 "../src/parser/fol.y"</span>
<a name="l01366"></a>01366 <span class="preprocessor"></span>    { zzconsumeToken(zztokenList, <span class="stringliteral">","</span>); ;}
<a name="l01367"></a>01367     <span class="keywordflow">break</span>;
<a name="l01368"></a>01368 
<a name="l01369"></a>01369   <span class="keywordflow">case</span> 41:
<a name="l01370"></a>01370 <span class="preprocessor">#line 400 "../src/parser/fol.y"</span>
<a name="l01371"></a>01371 <span class="preprocessor"></span>    { 
<a name="l01372"></a>01372     zzconsumeToken(zztokenList,<span class="stringliteral">"\n"</span>);
<a name="l01373"></a>01373     zzconsumeToken(zztokenList,<span class="stringliteral">","</span>);
<a name="l01374"></a>01374     zzconsumeToken(zztokenList,<span class="stringliteral">"\n"</span>);
<a name="l01375"></a>01375   ;}
<a name="l01376"></a>01376     <span class="keywordflow">break</span>;
<a name="l01377"></a>01377 
<a name="l01378"></a>01378   <span class="keywordflow">case</span> 42:
<a name="l01379"></a>01379 <span class="preprocessor">#line 407 "../src/parser/fol.y"</span>
<a name="l01380"></a>01380 <span class="preprocessor"></span>    { 
<a name="l01381"></a>01381     zzconsumeToken(zztokenList,<span class="stringliteral">"\n"</span>);
<a name="l01382"></a>01382     zzconsumeToken(zztokenList,<span class="stringliteral">","</span>);
<a name="l01383"></a>01383   ;}
<a name="l01384"></a>01384     <span class="keywordflow">break</span>;
<a name="l01385"></a>01385 
<a name="l01386"></a>01386   <span class="keywordflow">case</span> 43:
<a name="l01387"></a>01387 <span class="preprocessor">#line 413 "../src/parser/fol.y"</span>
<a name="l01388"></a>01388 <span class="preprocessor"></span>    { 
<a name="l01389"></a>01389     zzconsumeToken(zztokenList,<span class="stringliteral">","</span>);
<a name="l01390"></a>01390     zzconsumeToken(zztokenList,<span class="stringliteral">"\n"</span>);
<a name="l01391"></a>01391   ;}
<a name="l01392"></a>01392     <span class="keywordflow">break</span>;
<a name="l01393"></a>01393 
<a name="l01394"></a>01394   <span class="keywordflow">case</span> 44:
<a name="l01395"></a>01395 <span class="preprocessor">#line 423 "../src/parser/fol.y"</span>
<a name="l01396"></a>01396 <span class="preprocessor"></span>    {
<a name="l01397"></a>01397   <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"numeric_type_declarations: \n"</span>);
<a name="l01398"></a>01398   zzconsumeToken(zztokenList,<span class="stringliteral">"="</span>);
<a name="l01399"></a>01399   zzconsumeToken(zztokenList,<span class="stringliteral">"{"</span>);  
<a name="l01400"></a>01400 ;}
<a name="l01401"></a>01401     <span class="keywordflow">break</span>;
<a name="l01402"></a>01402 
<a name="l01403"></a>01403   <span class="keywordflow">case</span> 45:
<a name="l01404"></a>01404 <span class="preprocessor">#line 429 "../src/parser/fol.y"</span>
<a name="l01405"></a>01405 <span class="preprocessor"></span>    {
<a name="l01406"></a>01406   <span class="keyword">const</span> <span class="keywordtype">char</span>* numStr = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01407"></a>01407   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">" %s "</span>, numStr);
<a name="l01408"></a>01408   
<a name="l01409"></a>01409   <span class="keywordtype">double</span> d = atof(numStr);
<a name="l01410"></a>01410   zzinitialNumDeclaration = int(d);
<a name="l01411"></a>01411   <span class="keywordflow">if</span> (d != zzinitialNumDeclaration) zzerr(<span class="stringliteral">"constant %s must be an integer"</span>, numStr);
<a name="l01412"></a>01412 
<a name="l01413"></a>01413   <span class="keywordtype">char</span> constStr[100];
<a name="l01414"></a>01414   zzcreateIntConstant(constStr, zztypeName, zzinitialNumDeclaration);
<a name="l01415"></a>01415   <span class="keywordtype">int</span> constId = zzdomain-&gt;<a class="code" href="classDomain.html#f38c0be29eaffb326073219c18db170c">getConstantId</a>(constStr);
<a name="l01416"></a>01416   <span class="keywordflow">if</span> (constId &lt; 0) 
<a name="l01417"></a>01417     zzaddConstantToDomain(constStr, zztypeName);
<a name="l01418"></a>01418   <span class="keywordflow">else</span>
<a name="l01419"></a>01419   {
<a name="l01420"></a>01420     <span class="keyword">const</span> <span class="keywordtype">char</span>* prevType = zzdomain-&gt;<a class="code" href="classDomain.html#55e763b8e14e5629ac2d0f204d13af98">getConstantTypeName</a>(constId);
<a name="l01421"></a>01421     <span class="keywordflow">if</span> (strcmp(prevType,zztypeName)!=0)
<a name="l01422"></a>01422     {
<a name="l01423"></a>01423       <span class="keywordtype">char</span> buf[30]; sprintf(buf, <span class="stringliteral">"%d"</span>, zzinitialNumDeclaration);
<a name="l01424"></a>01424       zzerr(<span class="stringliteral">"constant %s previously declared to be of type %s is redeclared "</span>
<a name="l01425"></a>01425             <span class="stringliteral">"to be of type %s"</span>, buf, prevType, zztypeName);        
<a name="l01426"></a>01426     }
<a name="l01427"></a>01427   }
<a name="l01428"></a>01428 
<a name="l01429"></a>01429   <span class="keyword">delete</span> [] numStr;
<a name="l01430"></a>01430 ;}
<a name="l01431"></a>01431     <span class="keywordflow">break</span>;
<a name="l01432"></a>01432 
<a name="l01433"></a>01433   <span class="keywordflow">case</span> 46:
<a name="l01434"></a>01434 <span class="preprocessor">#line 456 "../src/parser/fol.y"</span>
<a name="l01435"></a>01435 <span class="preprocessor"></span>    {
<a name="l01436"></a>01436   zzconsumeToken(zztokenList, <span class="stringliteral">","</span>);
<a name="l01437"></a>01437 ;}
<a name="l01438"></a>01438     <span class="keywordflow">break</span>;
<a name="l01439"></a>01439 
<a name="l01440"></a>01440   <span class="keywordflow">case</span> 47:
<a name="l01441"></a>01441 <span class="preprocessor">#line 461 "../src/parser/fol.y"</span>
<a name="l01442"></a>01442 <span class="preprocessor"></span>    {
<a name="l01443"></a>01443   zzconsumeToken(zztokenList, <span class="stringliteral">"}"</span>);
<a name="l01444"></a>01444 ;}
<a name="l01445"></a>01445     <span class="keywordflow">break</span>;
<a name="l01446"></a>01446 
<a name="l01447"></a>01447   <span class="keywordflow">case</span> 48:
<a name="l01448"></a>01448 <span class="preprocessor">#line 468 "../src/parser/fol.y"</span>
<a name="l01449"></a>01449 <span class="preprocessor"></span>    {
<a name="l01450"></a>01450   <span class="comment">//const char* numStr1 = zztokenList.removeLast();</span>
<a name="l01451"></a>01451   zzconsumeToken(zztokenList, <span class="stringliteral">"..."</span>);
<a name="l01452"></a>01452   zzconsumeToken(zztokenList, <span class="stringliteral">","</span>);
<a name="l01453"></a>01453   <span class="keyword">const</span> <span class="keywordtype">char</span>* numStr2 = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01454"></a>01454   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"= ... , %s } "</span>, numStr2);
<a name="l01455"></a>01455   
<a name="l01456"></a>01456   <span class="keywordtype">double</span> d2 = atof(numStr2);
<a name="l01457"></a>01457   <span class="keywordtype">int</span> i2 = int(d2);
<a name="l01458"></a>01458   <span class="keywordflow">if</span> (d2 != i2) zzerr(<span class="stringliteral">"constant %s must be an integer"</span>, numStr2);
<a name="l01459"></a>01459   <span class="keywordflow">if</span> (zzinitialNumDeclaration &gt; i2)
<a name="l01460"></a>01460     zzerr(<span class="stringliteral">"first constant cannot be larger than last constant %s"</span>, numStr2);
<a name="l01461"></a>01461 
<a name="l01462"></a>01462   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = zzinitialNumDeclaration + 1; i &lt;= i2; i++)
<a name="l01463"></a>01463   {
<a name="l01464"></a>01464     <span class="keywordtype">char</span> constStr[100];
<a name="l01465"></a>01465     zzcreateIntConstant(constStr, zztypeName, i);
<a name="l01466"></a>01466     <span class="keywordtype">int</span> constId = zzdomain-&gt;<a class="code" href="classDomain.html#f38c0be29eaffb326073219c18db170c">getConstantId</a>(constStr);
<a name="l01467"></a>01467     <span class="keywordflow">if</span> (constId &lt; 0) 
<a name="l01468"></a>01468       zzaddConstantToDomain(constStr, zztypeName);
<a name="l01469"></a>01469     <span class="keywordflow">else</span>
<a name="l01470"></a>01470     {
<a name="l01471"></a>01471       <span class="keyword">const</span> <span class="keywordtype">char</span>* prevType = zzdomain-&gt;<a class="code" href="classDomain.html#55e763b8e14e5629ac2d0f204d13af98">getConstantTypeName</a>(constId);
<a name="l01472"></a>01472       <span class="keywordflow">if</span> (strcmp(prevType,zztypeName)!=0)
<a name="l01473"></a>01473       {
<a name="l01474"></a>01474         <span class="keywordtype">char</span> buf[30]; sprintf(buf, <span class="stringliteral">"%d"</span>, i);
<a name="l01475"></a>01475         zzerr(<span class="stringliteral">"constant %s previously declared to be of type %s is redeclared "</span>
<a name="l01476"></a>01476               <span class="stringliteral">"to be of type %s"</span>, buf, prevType, zztypeName);        
<a name="l01477"></a>01477       }
<a name="l01478"></a>01478     }
<a name="l01479"></a>01479   }
<a name="l01480"></a>01480 
<a name="l01481"></a>01481   <span class="keyword">delete</span> [] numStr2; <span class="keyword">delete</span> [] zztypeName;
<a name="l01482"></a>01482   zztypeName = NULL;
<a name="l01483"></a>01483 ;}
<a name="l01484"></a>01484     <span class="keywordflow">break</span>;
<a name="l01485"></a>01485 
<a name="l01486"></a>01486   <span class="keywordflow">case</span> 50:
<a name="l01487"></a>01487 <span class="preprocessor">#line 511 "../src/parser/fol.y"</span>
<a name="l01488"></a>01488 <span class="preprocessor"></span>    {  
<a name="l01489"></a>01489     zzconsumeToken(zztokenList, <span class="stringliteral">","</span>);
<a name="l01490"></a>01490     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">", "</span>); 
<a name="l01491"></a>01491     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"single_numeric_types: single_numeric_type\n"</span>); 
<a name="l01492"></a>01492   ;}
<a name="l01493"></a>01493     <span class="keywordflow">break</span>;
<a name="l01494"></a>01494 
<a name="l01495"></a>01495   <span class="keywordflow">case</span> 53:
<a name="l01496"></a>01496 <span class="preprocessor">#line 522 "../src/parser/fol.y"</span>
<a name="l01497"></a>01497 <span class="preprocessor"></span>    {
<a name="l01498"></a>01498   <span class="keyword">const</span> <span class="keywordtype">char</span>* numStr = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01499"></a>01499   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">" %s "</span>, numStr);
<a name="l01500"></a>01500   
<a name="l01501"></a>01501   <span class="keywordtype">double</span> d = atof(numStr);
<a name="l01502"></a>01502   <span class="keywordtype">int</span> i = int(d);
<a name="l01503"></a>01503   <span class="keywordflow">if</span> (d != i) zzerr(<span class="stringliteral">"constant %s must be an integer"</span>, numStr);
<a name="l01504"></a>01504 
<a name="l01505"></a>01505   <span class="keywordtype">char</span> constStr[100];
<a name="l01506"></a>01506   zzcreateIntConstant(constStr, zztypeName, i);
<a name="l01507"></a>01507   <span class="keywordtype">int</span> constId = zzdomain-&gt;<a class="code" href="classDomain.html#f38c0be29eaffb326073219c18db170c">getConstantId</a>(constStr);
<a name="l01508"></a>01508   <span class="keywordflow">if</span> (constId &lt; 0) 
<a name="l01509"></a>01509     zzaddConstantToDomain(constStr, zztypeName);
<a name="l01510"></a>01510   <span class="keywordflow">else</span>
<a name="l01511"></a>01511   {
<a name="l01512"></a>01512     <span class="keyword">const</span> <span class="keywordtype">char</span>* prevType = zzdomain-&gt;<a class="code" href="classDomain.html#55e763b8e14e5629ac2d0f204d13af98">getConstantTypeName</a>(constId);
<a name="l01513"></a>01513     <span class="keywordflow">if</span> (strcmp(prevType,zztypeName)!=0)
<a name="l01514"></a>01514     {
<a name="l01515"></a>01515       <span class="keywordtype">char</span> buf[30]; sprintf(buf, <span class="stringliteral">"%d"</span>, i);
<a name="l01516"></a>01516       zzerr(<span class="stringliteral">"constant %s previously declared to be of type %s is redeclared "</span>
<a name="l01517"></a>01517             <span class="stringliteral">"to be of type %s"</span>, buf, prevType, zztypeName);        
<a name="l01518"></a>01518     }
<a name="l01519"></a>01519   }
<a name="l01520"></a>01520 
<a name="l01521"></a>01521   <span class="keyword">delete</span> [] numStr;
<a name="l01522"></a>01522 ;}
<a name="l01523"></a>01523     <span class="keywordflow">break</span>;
<a name="l01524"></a>01524 
<a name="l01525"></a>01525   <span class="keywordflow">case</span> 54:
<a name="l01526"></a>01526 <span class="preprocessor">#line 558 "../src/parser/fol.y"</span>
<a name="l01527"></a>01527 <span class="preprocessor"></span>    {
<a name="l01528"></a>01528   <span class="keyword">const</span> <span class="keywordtype">char</span>* predName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01529"></a>01529 
<a name="l01530"></a>01530   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"ZZ_PREDICATE pc_%s "</span>, predName);  
<a name="l01531"></a>01531     <span class="comment">//predicate has not been declared a function</span>
<a name="l01532"></a>01532   zzassert(zzdomain-&gt;<a class="code" href="classDomain.html#54a8fa2545579af1ec4a8e74157d972c">getFunctionId</a>(predName) &lt; 0, 
<a name="l01533"></a>01533            <span class="stringliteral">"not expecting pred name to be declared as a function name"</span>);
<a name="l01534"></a>01534   zzassert(zzpredTemplate==NULL,<span class="stringliteral">"expecting zzpredTemplate==NULL"</span>);
<a name="l01535"></a>01535   zzpredTemplate = <span class="keyword">new</span> <a class="code" href="classPredicateTemplate.html">PredicateTemplate</a>();
<a name="l01536"></a>01536   zzpredTemplate-&gt;<a class="code" href="classPredicateTemplate.html#0f9961d21b84e1ca8eb47358dddd59fa">setName</a>(predName);
<a name="l01537"></a>01537   <span class="keyword">delete</span> [] predName;
<a name="l01538"></a>01538 ;}
<a name="l01539"></a>01539     <span class="keywordflow">break</span>;
<a name="l01540"></a>01540 
<a name="l01541"></a>01541   <span class="keywordflow">case</span> 55:
<a name="l01542"></a>01542 <span class="preprocessor">#line 570 "../src/parser/fol.y"</span>
<a name="l01543"></a>01543 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"( "</span>); zzconsumeToken(zztokenList,<span class="stringliteral">"("</span>); ;}
<a name="l01544"></a>01544     <span class="keywordflow">break</span>;
<a name="l01545"></a>01545 
<a name="l01546"></a>01546   <span class="keywordflow">case</span> 56:
<a name="l01547"></a>01547 <span class="preprocessor">#line 571 "../src/parser/fol.y"</span>
<a name="l01548"></a>01548 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"predicate_declaration: types\n"</span>); ;}
<a name="l01549"></a>01549     <span class="keywordflow">break</span>;
<a name="l01550"></a>01550 
<a name="l01551"></a>01551   <span class="keywordflow">case</span> 57:
<a name="l01552"></a>01552 <span class="preprocessor">#line 573 "../src/parser/fol.y"</span>
<a name="l01553"></a>01553 <span class="preprocessor"></span>    {  
<a name="l01554"></a>01554   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">") "</span>); 
<a name="l01555"></a>01555 
<a name="l01556"></a>01556   zzconsumeToken(zztokenList,<span class="stringliteral">")"</span>);
<a name="l01557"></a>01557 
<a name="l01558"></a>01558   zzassert(zzpredTemplate, <span class="stringliteral">"not expecting zzpredTemplate==NULL"</span>);
<a name="l01559"></a>01559   <span class="keywordtype">int</span> <span class="keywordtype">id</span> = zzdomain-&gt;<a class="code" href="classDomain.html#3a0e9d73d6e3c2e06c08968fc4d8df98">addPredicateTemplate</a>(zzpredTemplate);
<a name="l01560"></a>01560   zzassert(<span class="keywordtype">id</span> &gt;= 0, <span class="stringliteral">"expecting pred template id &gt;= 0"</span>);
<a name="l01561"></a>01561   zzpredTemplate-&gt;<a class="code" href="classPredicateTemplate.html#8f539d7a139332cf444a3ccb46fd4e09">setId</a>(<span class="keywordtype">id</span>);
<a name="l01562"></a>01562   zzpredTemplate = NULL;
<a name="l01563"></a>01563 ;}
<a name="l01564"></a>01564     <span class="keywordflow">break</span>;
<a name="l01565"></a>01565 
<a name="l01566"></a>01566   <span class="keywordflow">case</span> 58:
<a name="l01567"></a>01567 <span class="preprocessor">#line 591 "../src/parser/fol.y"</span>
<a name="l01568"></a>01568 <span class="preprocessor"></span>    { 
<a name="l01569"></a>01569   <span class="keyword">const</span> <span class="keywordtype">char</span>* retTypeName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01570"></a>01570   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"ZZ_FUNCTION t_%s "</span>, retTypeName); 
<a name="l01571"></a>01571   <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"function_declaration: ZZ_VARIABLE\n"</span>); 
<a name="l01572"></a>01572 
<a name="l01573"></a>01573   <span class="keywordflow">if</span> (!zzdomain-&gt;<a class="code" href="classDomain.html#da61369ed33763c933aeeaef87d0974b">isType</a>(retTypeName))
<a name="l01574"></a>01574   {
<a name="l01575"></a>01575     <span class="keywordtype">int</span> <span class="keywordtype">id</span> = zzaddTypeToDomain(zzdomain, retTypeName);
<a name="l01576"></a>01576     zzassert(<span class="keywordtype">id</span> &gt;= 0, <span class="stringliteral">"expecting retTypeName's id &gt;= 0"</span>);
<a name="l01577"></a>01577   }
<a name="l01578"></a>01578 
<a name="l01579"></a>01579   zzassert(zzfuncTemplate==NULL, <span class="stringliteral">"expecting zzfuncTemplate==NULL"</span>);
<a name="l01580"></a>01580   zzfuncTemplate = <span class="keyword">new</span> <a class="code" href="classFunctionTemplate.html">FunctionTemplate</a>();
<a name="l01581"></a>01581   zzfuncTemplate-&gt;<a class="code" href="classFunctionTemplate.html#c38e281ee2585a6e1035cbd71b54fa46">setRetTypeName</a>(retTypeName,zzdomain);
<a name="l01582"></a>01582 
<a name="l01583"></a>01583   <span class="comment">// We are creating a new predicate as well</span>
<a name="l01584"></a>01584   zzassert(zzpredTemplate==NULL,<span class="stringliteral">"expecting zzpredTemplate==NULL"</span>);
<a name="l01585"></a>01585   zzpredTemplate = <span class="keyword">new</span> <a class="code" href="classPredicateTemplate.html">PredicateTemplate</a>();
<a name="l01586"></a>01586   zzaddType(retTypeName, zzpredTemplate, NULL, <span class="keyword">false</span>, zzdomain);
<a name="l01587"></a>01587 
<a name="l01588"></a>01588   <span class="keyword">delete</span> [] retTypeName;
<a name="l01589"></a>01589 ;}
<a name="l01590"></a>01590     <span class="keywordflow">break</span>;
<a name="l01591"></a>01591 
<a name="l01592"></a>01592   <span class="keywordflow">case</span> 59:
<a name="l01593"></a>01593 <span class="preprocessor">#line 614 "../src/parser/fol.y"</span>
<a name="l01594"></a>01594 <span class="preprocessor"></span>    {
<a name="l01595"></a>01595   <span class="keyword">const</span> <span class="keywordtype">char</span>* funcName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01596"></a>01596 
<a name="l01597"></a>01597   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"fc_%s "</span>, funcName); 
<a name="l01598"></a>01598   zzassert(zzdomain-&gt;<a class="code" href="classDomain.html#9dcb8a8aa5bb91ed993cb428f2587ad3">getPredicateId</a>(funcName) &lt; 0, 
<a name="l01599"></a>01599            <span class="stringliteral">"not expecting func name to be declared as pred name"</span>);
<a name="l01600"></a>01600   zzfuncTemplate-&gt;<a class="code" href="classPredicateTemplate.html#0f9961d21b84e1ca8eb47358dddd59fa">setName</a>(funcName);
<a name="l01601"></a>01601 
<a name="l01602"></a>01602   <span class="comment">// Predicate name is PredicateTemplate::ZZ_RETURN_PREFIX + function name</span>
<a name="l01603"></a>01603   <span class="keywordtype">char</span>* predName;
<a name="l01604"></a>01604   predName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#62e623b43316dadb940ca05273ecb19d">PredicateTemplate::ZZ_RETURN_PREFIX</a>) +
<a name="l01605"></a>01605                                                         strlen(funcName) + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01606"></a>01606   strcpy(predName, <a class="code" href="classPredicateTemplate.html#62e623b43316dadb940ca05273ecb19d">PredicateTemplate::ZZ_RETURN_PREFIX</a>);
<a name="l01607"></a>01607   strcat(predName, funcName);
<a name="l01608"></a>01608         
<a name="l01609"></a>01609   <span class="comment">// Check that predicate has not been declared a function</span>
<a name="l01610"></a>01610   zzassert(zzdomain-&gt;<a class="code" href="classDomain.html#54a8fa2545579af1ec4a8e74157d972c">getFunctionId</a>(predName) &lt; 0, 
<a name="l01611"></a>01611            <span class="stringliteral">"not expecting pred name to be declared as a function name"</span>);
<a name="l01612"></a>01612   zzassert(zzpredTemplate,<span class="stringliteral">"expecting zzpredTemplate!=NULL"</span>);
<a name="l01613"></a>01613   zzpredTemplate-&gt;<a class="code" href="classPredicateTemplate.html#0f9961d21b84e1ca8eb47358dddd59fa">setName</a>(predName);
<a name="l01614"></a>01614 
<a name="l01615"></a>01615   free(predName);
<a name="l01616"></a>01616   <span class="keyword">delete</span> [] funcName;
<a name="l01617"></a>01617 ;}
<a name="l01618"></a>01618     <span class="keywordflow">break</span>;
<a name="l01619"></a>01619 
<a name="l01620"></a>01620   <span class="keywordflow">case</span> 60:
<a name="l01621"></a>01621 <span class="preprocessor">#line 639 "../src/parser/fol.y"</span>
<a name="l01622"></a>01622 <span class="preprocessor"></span>    {
<a name="l01623"></a>01623   zzconsumeToken(zztokenList,<span class="stringliteral">"("</span>);
<a name="l01624"></a>01624   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"( "</span>); 
<a name="l01625"></a>01625   <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"function_declaration: types\n"</span>); 
<a name="l01626"></a>01626 ;}
<a name="l01627"></a>01627     <span class="keywordflow">break</span>;
<a name="l01628"></a>01628 
<a name="l01629"></a>01629   <span class="keywordflow">case</span> 61:
<a name="l01630"></a>01630 <span class="preprocessor">#line 645 "../src/parser/fol.y"</span>
<a name="l01631"></a>01631 <span class="preprocessor"></span>    {  
<a name="l01632"></a>01632   zzconsumeToken(zztokenList,<span class="stringliteral">")"</span>);
<a name="l01633"></a>01633   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">") "</span>); 
<a name="l01634"></a>01634   zzassert(zzfuncTemplate, <span class="stringliteral">"expecting zzfuncTemplate != NULL"</span>);
<a name="l01635"></a>01635   <span class="keywordtype">int</span> <span class="keywordtype">id</span> = zzdomain-&gt;<a class="code" href="classDomain.html#4deb66f3c5762b94db8d348f203b6edb">addFunctionTemplate</a>(zzfuncTemplate);
<a name="l01636"></a>01636   zzassert(<span class="keywordtype">id</span> &gt;= 0, <span class="stringliteral">"expecting function template's id &gt;= 0"</span>);
<a name="l01637"></a>01637   zzfuncTemplate-&gt;<a class="code" href="classPredicateTemplate.html#8f539d7a139332cf444a3ccb46fd4e09">setId</a>(<span class="keywordtype">id</span>);
<a name="l01638"></a>01638   zzfuncTemplate = NULL;
<a name="l01639"></a>01639 
<a name="l01640"></a>01640   zzassert(zzpredTemplate, <span class="stringliteral">"not expecting zzpredTemplate==NULL"</span>);
<a name="l01641"></a>01641   <span class="comment">// Predicate could already be there</span>
<a name="l01642"></a>01642   <span class="keywordflow">if</span> (!zzdomain-&gt;<a class="code" href="classDomain.html#6d37e0edeb42eda1d44d52aea5aac7ab">isPredicate</a>(zzpredTemplate-&gt;<a class="code" href="classPredicateTemplate.html#7a666615967e2d470d127736314795e0">getName</a>()))
<a name="l01643"></a>01643   {
<a name="l01644"></a>01644     <span class="keywordtype">int</span> predId = zzdomain-&gt;<a class="code" href="classDomain.html#3a0e9d73d6e3c2e06c08968fc4d8df98">addPredicateTemplate</a>(zzpredTemplate);
<a name="l01645"></a>01645     zzassert(predId &gt;= 0, <span class="stringliteral">"expecting pred template id &gt;= 0"</span>);
<a name="l01646"></a>01646     zzpredTemplate-&gt;<a class="code" href="classPredicateTemplate.html#8f539d7a139332cf444a3ccb46fd4e09">setId</a>(predId);
<a name="l01647"></a>01647   }
<a name="l01648"></a>01648   zzpredTemplate = NULL;
<a name="l01649"></a>01649 
<a name="l01650"></a>01650 ;}
<a name="l01651"></a>01651     <span class="keywordflow">break</span>;
<a name="l01652"></a>01652 
<a name="l01653"></a>01653   <span class="keywordflow">case</span> 64:
<a name="l01654"></a>01654 <span class="preprocessor">#line 674 "../src/parser/fol.y"</span>
<a name="l01655"></a>01655 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">", "</span>); zzconsumeToken(zztokenList,<span class="stringliteral">","</span>); ;}
<a name="l01656"></a>01656     <span class="keywordflow">break</span>;
<a name="l01657"></a>01657 
<a name="l01658"></a>01658   <span class="keywordflow">case</span> 66:
<a name="l01659"></a>01659 <span class="preprocessor">#line 678 "../src/parser/fol.y"</span>
<a name="l01660"></a>01660 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">", "</span>); zzconsumeToken(zztokenList,<span class="stringliteral">","</span>); ;}
<a name="l01661"></a>01661     <span class="keywordflow">break</span>;
<a name="l01662"></a>01662 
<a name="l01663"></a>01663   <span class="keywordflow">case</span> 70:
<a name="l01664"></a>01664 <span class="preprocessor">#line 686 "../src/parser/fol.y"</span>
<a name="l01665"></a>01665 <span class="preprocessor"></span>    {  
<a name="l01666"></a>01666   <span class="keyword">const</span> <span class="keywordtype">char</span>* ttype = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01667"></a>01667   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"t_%s "</span>, ttype);
<a name="l01668"></a>01668   zzaddType(ttype, zzpredTemplate, NULL, <span class="keyword">false</span>, zzdomain);
<a name="l01669"></a>01669   <span class="comment">// If we are in a function definition, then add the type to the function too</span>
<a name="l01670"></a>01670   <span class="keywordflow">if</span> (zzfuncTemplate)
<a name="l01671"></a>01671         zzaddType(ttype, NULL, zzfuncTemplate, <span class="keyword">false</span>, zzdomain);
<a name="l01672"></a>01672         
<a name="l01673"></a>01673   <span class="keyword">delete</span> [] ttype;
<a name="l01674"></a>01674 ;}
<a name="l01675"></a>01675     <span class="keywordflow">break</span>;
<a name="l01676"></a>01676 
<a name="l01677"></a>01677   <span class="keywordflow">case</span> 71:
<a name="l01678"></a>01678 <span class="preprocessor">#line 699 "../src/parser/fol.y"</span>
<a name="l01679"></a>01679 <span class="preprocessor"></span>    {
<a name="l01680"></a>01680   <span class="keyword">const</span> <span class="keywordtype">char</span>* varName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();;
<a name="l01681"></a>01681   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"t_%s "</span>, varName);
<a name="l01682"></a>01682   zzassert(!zzdomain-&gt;<a class="code" href="classDomain.html#da61369ed33763c933aeeaef87d0974b">isType</a>(varName), <span class="stringliteral">"expecting varName to be not a type"</span>);
<a name="l01683"></a>01683   <span class="keywordtype">int</span> <span class="keywordtype">id</span> = zzaddTypeToDomain(zzdomain, varName);
<a name="l01684"></a>01684   zzassert(<span class="keywordtype">id</span> &gt;= 0, <span class="stringliteral">"expecting var id &gt;= 0"</span>);
<a name="l01685"></a>01685   zzaddType(varName, zzpredTemplate, NULL, <span class="keyword">false</span>, zzdomain);
<a name="l01686"></a>01686   <span class="comment">// If we are in a function definition, then add the type to the function too</span>
<a name="l01687"></a>01687   <span class="keywordflow">if</span> (zzfuncTemplate)
<a name="l01688"></a>01688         zzaddType(varName, NULL, zzfuncTemplate, <span class="keyword">false</span>, zzdomain);
<a name="l01689"></a>01689   <span class="keyword">delete</span> [] varName;
<a name="l01690"></a>01690 ;}
<a name="l01691"></a>01691     <span class="keywordflow">break</span>;
<a name="l01692"></a>01692 
<a name="l01693"></a>01693   <span class="keywordflow">case</span> 72:
<a name="l01694"></a>01694 <span class="preprocessor">#line 717 "../src/parser/fol.y"</span>
<a name="l01695"></a>01695 <span class="preprocessor"></span>    { 
<a name="l01696"></a>01696     zztrueFalseUnknown = <span class="charliteral">'t'</span>;
<a name="l01697"></a>01697   ;}
<a name="l01698"></a>01698     <span class="keywordflow">break</span>;
<a name="l01699"></a>01699 
<a name="l01700"></a>01700   <span class="keywordflow">case</span> 73:
<a name="l01701"></a>01701 <span class="preprocessor">#line 721 "../src/parser/fol.y"</span>
<a name="l01702"></a>01702 <span class="preprocessor"></span>    { 
<a name="l01703"></a>01703     zzconsumeToken(zztokenList,<span class="stringliteral">"!"</span>); 
<a name="l01704"></a>01704     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"! "</span>); 
<a name="l01705"></a>01705     zztrueFalseUnknown = <span class="charliteral">'f'</span>;
<a name="l01706"></a>01706   ;}
<a name="l01707"></a>01707     <span class="keywordflow">break</span>;
<a name="l01708"></a>01708 
<a name="l01709"></a>01709   <span class="keywordflow">case</span> 74:
<a name="l01710"></a>01710 <span class="preprocessor">#line 727 "../src/parser/fol.y"</span>
<a name="l01711"></a>01711 <span class="preprocessor"></span>    { 
<a name="l01712"></a>01712     zzconsumeToken(zztokenList,<span class="stringliteral">"?"</span>); 
<a name="l01713"></a>01713     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"? "</span>); 
<a name="l01714"></a>01714     zztrueFalseUnknown = <span class="charliteral">'u'</span>;
<a name="l01715"></a>01715   ;}
<a name="l01716"></a>01716     <span class="keywordflow">break</span>;
<a name="l01717"></a>01717 
<a name="l01718"></a>01718   <span class="keywordflow">case</span> 75:
<a name="l01719"></a>01719 <span class="preprocessor">#line 738 "../src/parser/fol.y"</span>
<a name="l01720"></a>01720 <span class="preprocessor"></span>    {
<a name="l01721"></a>01721   <span class="keyword">const</span> <span class="keywordtype">char</span>* predName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01722"></a>01722   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"pd_%s "</span>, predName); 
<a name="l01723"></a>01723   
<a name="l01724"></a>01724   zzcreatePred(zzpred, predName);
<a name="l01725"></a>01725   <span class="keywordflow">if</span> (zztrueFalseUnknown == <span class="charliteral">'t'</span>)      zzpred-&gt;<a class="code" href="classPredicate.html#4c79867498e7d91ba127e22e7b54a91e">setTruthValue</a>(TRUE);
<a name="l01726"></a>01726   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (zztrueFalseUnknown == <span class="charliteral">'f'</span>) zzpred-&gt;<a class="code" href="classPredicate.html#4c79867498e7d91ba127e22e7b54a91e">setTruthValue</a>(FALSE);
<a name="l01727"></a>01727   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (zztrueFalseUnknown == <span class="charliteral">'u'</span>) zzpred-&gt;<a class="code" href="classPredicate.html#4c79867498e7d91ba127e22e7b54a91e">setTruthValue</a>(UNKNOWN);
<a name="l01728"></a>01728   <span class="keywordflow">else</span> { zzassert(<span class="keyword">false</span>, <span class="stringliteral">"expecting t,f,u"</span>); }
<a name="l01729"></a>01729 
<a name="l01730"></a>01730   <span class="keyword">delete</span> [] predName;
<a name="l01731"></a>01731 ;}
<a name="l01732"></a>01732     <span class="keywordflow">break</span>;
<a name="l01733"></a>01733 
<a name="l01734"></a>01734   <span class="keywordflow">case</span> 76:
<a name="l01735"></a>01735 <span class="preprocessor">#line 751 "../src/parser/fol.y"</span>
<a name="l01736"></a>01736 <span class="preprocessor"></span>    { 
<a name="l01737"></a>01737   zzconsumeToken(zztokenList,<span class="stringliteral">"("</span>); 
<a name="l01738"></a>01738   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"( "</span>); 
<a name="l01739"></a>01739   <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"predicate_definition: constants_in_groundings\n"</span>);
<a name="l01740"></a>01740 ;}
<a name="l01741"></a>01741     <span class="keywordflow">break</span>;
<a name="l01742"></a>01742 
<a name="l01743"></a>01743   <span class="keywordflow">case</span> 77:
<a name="l01744"></a>01744 <span class="preprocessor">#line 757 "../src/parser/fol.y"</span>
<a name="l01745"></a>01745 <span class="preprocessor"></span>    { 
<a name="l01746"></a>01746   zzconsumeToken(zztokenList,<span class="stringliteral">")"</span>); 
<a name="l01747"></a>01747   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">")\n"</span>); 
<a name="l01748"></a>01748   
<a name="l01749"></a>01749   zzcheckPredNumTerm(zzpred);
<a name="l01750"></a>01750   <span class="keywordtype">int</span> predId = zzpred-&gt;<a class="code" href="classPredicate.html#bf7ace41fac6ed9b6c68bb29a1c95445">getId</a>();
<a name="l01751"></a>01751   hash_map&lt;int,PredicateHashArray*&gt;::iterator it;
<a name="l01752"></a>01752   <span class="keywordflow">if</span> ((it=zzpredIdToGndPredMap.find(predId)) == zzpredIdToGndPredMap.end())
<a name="l01753"></a>01753     zzpredIdToGndPredMap[predId] = <span class="keyword">new</span> <a class="code" href="classHashArray.html">PredicateHashArray</a>;
<a name="l01754"></a>01754   
<a name="l01755"></a>01755   <a class="code" href="classHashArray.html">PredicateHashArray</a>* pha = zzpredIdToGndPredMap[predId];
<a name="l01756"></a>01756   <span class="keywordflow">if</span> (pha-&gt;<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>(zzpred) &lt; 0)
<a name="l01757"></a>01757   {
<a name="l01758"></a>01758     <span class="keywordtype">int</span> a = pha-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(zzpred);
<a name="l01759"></a>01759     zzassert(a &gt;= 0, <span class="stringliteral">"expecting ground predicate to be found"</span>);
<a name="l01760"></a>01760     string origTvStr = (*pha)[a]-&gt;getTruthValueAsStr();
<a name="l01761"></a>01761     (*pha)[a]-&gt;setTruthValue(zzpred-&gt;<a class="code" href="classPredicate.html#26aabf16a08c2db8abd7032b1ec0ecb9">getTruthValue</a>());
<a name="l01762"></a>01762     string newTvStr = (*pha)[a]-&gt;getTruthValueAsStr();
<a name="l01763"></a>01763 
<a name="l01764"></a>01764     <span class="keywordflow">if</span> (zzwarnDuplicates)
<a name="l01765"></a>01765     {
<a name="l01766"></a>01766       ostringstream oss;
<a name="l01767"></a>01767       oss &lt;&lt; <span class="stringliteral">"Duplicate ground predicate "</span>; zzpred-&gt;<a class="code" href="classPredicate.html#7b9f95dc623d3291895059ca5a6825ca">print</a>(oss, zzdomain); 
<a name="l01768"></a>01768       oss &lt;&lt; <span class="stringliteral">" found. "</span>;
<a name="l01769"></a>01769       <span class="keywordflow">if</span> (origTvStr.compare(newTvStr) != 0)
<a name="l01770"></a>01770         oss &lt;&lt; <span class="stringliteral">"Changed its truthValue from "</span> &lt;&lt; origTvStr &lt;&lt; <span class="stringliteral">" to "</span> &lt;&lt;newTvStr 
<a name="l01771"></a>01771             &lt;&lt; endl;
<a name="l01772"></a>01772       zzwarn(oss.str().c_str());
<a name="l01773"></a>01773     }
<a name="l01774"></a>01774     <span class="keyword">delete</span> zzpred;
<a name="l01775"></a>01775   }
<a name="l01776"></a>01776   zzpred = NULL;
<a name="l01777"></a>01777 ;}
<a name="l01778"></a>01778     <span class="keywordflow">break</span>;
<a name="l01779"></a>01779 
<a name="l01780"></a>01780   <span class="keywordflow">case</span> 78:
<a name="l01781"></a>01781 <span class="preprocessor">#line 795 "../src/parser/fol.y"</span>
<a name="l01782"></a>01782 <span class="preprocessor"></span>    { 
<a name="l01783"></a>01783   zzconsumeToken(zztokenList,<span class="stringliteral">"="</span>); 
<a name="l01784"></a>01784   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"= "</span>); 
<a name="l01785"></a>01785   <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"function_definition: constants_in_groundings\n"</span>);
<a name="l01786"></a>01786 ;}
<a name="l01787"></a>01787     <span class="keywordflow">break</span>;
<a name="l01788"></a>01788 
<a name="l01789"></a>01789   <span class="keywordflow">case</span> 79:
<a name="l01790"></a>01790 <span class="preprocessor">#line 801 "../src/parser/fol.y"</span>
<a name="l01791"></a>01791 <span class="preprocessor"></span>    {
<a name="l01792"></a>01792   <span class="comment">// Predicate name is PredicateTemplate::ZZ_RETURN_PREFIX + function name</span>
<a name="l01793"></a>01793   <span class="keyword">const</span> <span class="keywordtype">char</span>* funcName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01794"></a>01794   <span class="keywordtype">char</span>* predName;
<a name="l01795"></a>01795   predName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#62e623b43316dadb940ca05273ecb19d">PredicateTemplate::ZZ_RETURN_PREFIX</a>) +
<a name="l01796"></a>01796                                                         strlen(funcName) + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01797"></a>01797   strcpy(predName, <a class="code" href="classPredicateTemplate.html#62e623b43316dadb940ca05273ecb19d">PredicateTemplate::ZZ_RETURN_PREFIX</a>);
<a name="l01798"></a>01798   strcat(predName, funcName);
<a name="l01799"></a>01799 
<a name="l01800"></a>01800   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"pd_%s "</span>, predName); 
<a name="l01801"></a>01801   
<a name="l01802"></a>01802   zzcreatePred(zzpred, predName);
<a name="l01803"></a>01803   zzpred-&gt;<a class="code" href="classPredicate.html#4c79867498e7d91ba127e22e7b54a91e">setTruthValue</a>(TRUE);
<a name="l01804"></a>01804 
<a name="l01805"></a>01805   <span class="keywordtype">char</span> constName[100];
<a name="l01806"></a>01806   <span class="keywordtype">char</span>* constString;
<a name="l01807"></a>01807   <span class="keywordflow">if</span> (zztmpReturnNum)
<a name="l01808"></a>01808   {
<a name="l01809"></a>01809         zzcreateAndCheckIntConstant(zztmpReturnConstant, zzfunc, zzpred, zzdomain, constName);
<a name="l01810"></a>01810     <span class="keywordflow">if</span> (constName == NULL)
<a name="l01811"></a>01811     {
<a name="l01812"></a>01812       constString = (<span class="keywordtype">char</span> *)malloc((strlen(zztmpReturnConstant) + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01813"></a>01813       strcpy(constString, zztmpReturnConstant);
<a name="l01814"></a>01814     } <span class="keywordflow">else</span>
<a name="l01815"></a>01815     {
<a name="l01816"></a>01816           constString = (<span class="keywordtype">char</span> *)malloc((strlen(constName) + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01817"></a>01817       strcpy(constString, constName);
<a name="l01818"></a>01818     }
<a name="l01819"></a>01819   }
<a name="l01820"></a>01820   <span class="keywordflow">else</span>
<a name="l01821"></a>01821   {
<a name="l01822"></a>01822     constString = (<span class="keywordtype">char</span> *)malloc((strlen(zztmpReturnConstant) + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));  
<a name="l01823"></a>01823         strcpy(constString, zztmpReturnConstant);
<a name="l01824"></a>01824   }
<a name="l01825"></a>01825 
<a name="l01826"></a>01826   <span class="comment">//Add return constant parsed earlier</span>
<a name="l01827"></a>01827   zzaddConstantToPredFunc(constString);
<a name="l01828"></a>01828 
<a name="l01829"></a>01829   zztmpReturnNum = <span class="keyword">false</span>;
<a name="l01830"></a>01830   free(zztmpReturnConstant);
<a name="l01831"></a>01831   <span class="keyword">delete</span> [] funcName;
<a name="l01832"></a>01832   free(predName);
<a name="l01833"></a>01833   free(constString);
<a name="l01834"></a>01834 ;}
<a name="l01835"></a>01835     <span class="keywordflow">break</span>;
<a name="l01836"></a>01836 
<a name="l01837"></a>01837   <span class="keywordflow">case</span> 80:
<a name="l01838"></a>01838 <span class="preprocessor">#line 846 "../src/parser/fol.y"</span>
<a name="l01839"></a>01839 <span class="preprocessor"></span>    { 
<a name="l01840"></a>01840   zzconsumeToken(zztokenList,<span class="stringliteral">"("</span>); 
<a name="l01841"></a>01841   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"( "</span>); 
<a name="l01842"></a>01842   <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"function_definition: constants_in_groundings\n"</span>);
<a name="l01843"></a>01843 ;}
<a name="l01844"></a>01844     <span class="keywordflow">break</span>;
<a name="l01845"></a>01845 
<a name="l01846"></a>01846   <span class="keywordflow">case</span> 81:
<a name="l01847"></a>01847 <span class="preprocessor">#line 852 "../src/parser/fol.y"</span>
<a name="l01848"></a>01848 <span class="preprocessor"></span>    { 
<a name="l01849"></a>01849   zzconsumeToken(zztokenList,<span class="stringliteral">")"</span>); 
<a name="l01850"></a>01850   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">")\n"</span>); 
<a name="l01851"></a>01851   
<a name="l01852"></a>01852   zzcheckPredNumTerm(zzpred);
<a name="l01853"></a>01853   <span class="keywordtype">int</span> predId = zzpred-&gt;<a class="code" href="classPredicate.html#bf7ace41fac6ed9b6c68bb29a1c95445">getId</a>();
<a name="l01854"></a>01854   hash_map&lt;int,PredicateHashArray*&gt;::iterator it;
<a name="l01855"></a>01855   <span class="keywordflow">if</span> ((it=zzpredIdToGndPredMap.find(predId)) == zzpredIdToGndPredMap.end())
<a name="l01856"></a>01856     zzpredIdToGndPredMap[predId] = <span class="keyword">new</span> <a class="code" href="classHashArray.html">PredicateHashArray</a>;
<a name="l01857"></a>01857   
<a name="l01858"></a>01858   <a class="code" href="classHashArray.html">PredicateHashArray</a>* pha = zzpredIdToGndPredMap[predId];
<a name="l01859"></a>01859   <span class="keywordflow">if</span> (pha-&gt;<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>(zzpred) &lt; 0)
<a name="l01860"></a>01860   {
<a name="l01861"></a>01861     <span class="keywordtype">int</span> a = pha-&gt;<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(zzpred);
<a name="l01862"></a>01862     zzassert(a &gt;= 0, <span class="stringliteral">"expecting ground predicate to be found"</span>);
<a name="l01863"></a>01863     string origTvStr = (*pha)[a]-&gt;getTruthValueAsStr();
<a name="l01864"></a>01864     (*pha)[a]-&gt;setTruthValue(zzpred-&gt;<a class="code" href="classPredicate.html#26aabf16a08c2db8abd7032b1ec0ecb9">getTruthValue</a>());
<a name="l01865"></a>01865     string newTvStr = (*pha)[a]-&gt;getTruthValueAsStr();
<a name="l01866"></a>01866 
<a name="l01867"></a>01867     <span class="keywordflow">if</span> (zzwarnDuplicates)
<a name="l01868"></a>01868     {
<a name="l01869"></a>01869       ostringstream oss;
<a name="l01870"></a>01870       oss &lt;&lt; <span class="stringliteral">"Duplicate ground predicate "</span>; zzpred-&gt;<a class="code" href="classPredicate.html#7b9f95dc623d3291895059ca5a6825ca">print</a>(oss, zzdomain); 
<a name="l01871"></a>01871       oss &lt;&lt; <span class="stringliteral">" found. "</span>;
<a name="l01872"></a>01872       <span class="keywordflow">if</span> (origTvStr.compare(newTvStr) != 0)
<a name="l01873"></a>01873         oss &lt;&lt; <span class="stringliteral">"Changed its truthValue from "</span> &lt;&lt; origTvStr &lt;&lt; <span class="stringliteral">" to "</span> &lt;&lt;newTvStr 
<a name="l01874"></a>01874             &lt;&lt; endl;
<a name="l01875"></a>01875       zzwarn(oss.str().c_str());
<a name="l01876"></a>01876     }
<a name="l01877"></a>01877     <span class="comment">//delete zzpred;</span>
<a name="l01878"></a>01878   }
<a name="l01879"></a>01879 
<a name="l01880"></a>01880   <span class="comment">// Insert FALSE for all other return values</span>
<a name="l01881"></a>01881 
<a name="l01882"></a>01882   zzpred = NULL;
<a name="l01883"></a>01883 ;}
<a name="l01884"></a>01884     <span class="keywordflow">break</span>;
<a name="l01885"></a>01885 
<a name="l01886"></a>01886   <span class="keywordflow">case</span> 82:
<a name="l01887"></a>01887 <span class="preprocessor">#line 892 "../src/parser/fol.y"</span>
<a name="l01888"></a>01888 <span class="preprocessor"></span>    {     
<a name="l01889"></a>01889     <span class="keyword">const</span> <span class="keywordtype">char</span>* constName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01890"></a>01890     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"cg_%s "</span>, constName);
<a name="l01891"></a>01891     zzaddConstantToPredFunc(constName);
<a name="l01892"></a>01892     <span class="keyword">delete</span> [] constName;
<a name="l01893"></a>01893   ;}
<a name="l01894"></a>01894     <span class="keywordflow">break</span>;
<a name="l01895"></a>01895 
<a name="l01896"></a>01896   <span class="keywordflow">case</span> 83:
<a name="l01897"></a>01897 <span class="preprocessor">#line 900 "../src/parser/fol.y"</span>
<a name="l01898"></a>01898 <span class="preprocessor"></span>    {     
<a name="l01899"></a>01899     <span class="keyword">const</span> <span class="keywordtype">char</span>* constName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01900"></a>01900     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"cg_%s "</span>, constName);
<a name="l01901"></a>01901     zzaddConstantToPredFunc(constName);
<a name="l01902"></a>01902     <span class="keyword">delete</span> [] constName;
<a name="l01903"></a>01903   ;}
<a name="l01904"></a>01904     <span class="keywordflow">break</span>;
<a name="l01905"></a>01905 
<a name="l01906"></a>01906   <span class="keywordflow">case</span> 85:
<a name="l01907"></a>01907 <span class="preprocessor">#line 911 "../src/parser/fol.y"</span>
<a name="l01908"></a>01908 <span class="preprocessor"></span>    {
<a name="l01909"></a>01909     <span class="keywordflow">if</span> (zzconstantMustBeDeclared)
<a name="l01910"></a>01910       zzerr(<span class="stringliteral">"Constant %s must be declared before it is used."</span>,
<a name="l01911"></a>01911             zztokenList.<a class="code" href="classStrFifoList.html#708a82bf7b398f6404d93887ba7f9a4c">back</a>());
<a name="l01912"></a>01912   ;}
<a name="l01913"></a>01913     <span class="keywordflow">break</span>;
<a name="l01914"></a>01914 
<a name="l01915"></a>01915   <span class="keywordflow">case</span> 86:
<a name="l01916"></a>01916 <span class="preprocessor">#line 917 "../src/parser/fol.y"</span>
<a name="l01917"></a>01917 <span class="preprocessor"></span>    {
<a name="l01918"></a>01918     <span class="keyword">const</span> <span class="keywordtype">char</span>* intStr = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01919"></a>01919     <span class="keywordtype">char</span> constName[100];
<a name="l01920"></a>01920     zzcreateAndCheckIntConstant(intStr, zzfunc, zzpred, zzdomain, constName);
<a name="l01921"></a>01921     <span class="keywordflow">if</span> (constName == NULL) zztokenList.<a class="code" href="classStrFifoList.html#be472c3b4ece19aaec93d892e8e0a73f">addLast</a>(intStr);
<a name="l01922"></a>01922     <span class="keywordflow">else</span>                   zztokenList.<a class="code" href="classStrFifoList.html#be472c3b4ece19aaec93d892e8e0a73f">addLast</a>(constName);
<a name="l01923"></a>01923     <span class="keyword">delete</span> [] intStr;
<a name="l01924"></a>01924   ;}
<a name="l01925"></a>01925     <span class="keywordflow">break</span>;
<a name="l01926"></a>01926 
<a name="l01927"></a>01927   <span class="keywordflow">case</span> 87:
<a name="l01928"></a>01928 <span class="preprocessor">#line 926 "../src/parser/fol.y"</span>
<a name="l01929"></a>01929 <span class="preprocessor"></span>    {
<a name="l01930"></a>01930     <span class="keywordflow">if</span> (zzconstantMustBeDeclared)
<a name="l01931"></a>01931       zzerr(<span class="stringliteral">"Constant %s must be declared before it is used"</span>,
<a name="l01932"></a>01932             zztokenList.<a class="code" href="classStrFifoList.html#708a82bf7b398f6404d93887ba7f9a4c">back</a>());
<a name="l01933"></a>01933   ;}
<a name="l01934"></a>01934     <span class="keywordflow">break</span>;
<a name="l01935"></a>01935 
<a name="l01936"></a>01936   <span class="keywordflow">case</span> 88:
<a name="l01937"></a>01937 <span class="preprocessor">#line 934 "../src/parser/fol.y"</span>
<a name="l01938"></a>01938 <span class="preprocessor"></span>    {
<a name="l01939"></a>01939     <span class="keyword">const</span> <span class="keywordtype">char</span>* tmp = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01940"></a>01940         zztmpReturnConstant = (<span class="keywordtype">char</span> *)malloc((strlen(tmp) + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01941"></a>01941         strcpy(zztmpReturnConstant, tmp);
<a name="l01942"></a>01942         zztmpReturnNum = <span class="keyword">false</span>;
<a name="l01943"></a>01943         <span class="keyword">delete</span> []tmp;
<a name="l01944"></a>01944         <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"ic_%s "</span>, zztmpReturnConstant); 
<a name="l01945"></a>01945   ;}
<a name="l01946"></a>01946     <span class="keywordflow">break</span>;
<a name="l01947"></a>01947 
<a name="l01948"></a>01948   <span class="keywordflow">case</span> 89:
<a name="l01949"></a>01949 <span class="preprocessor">#line 943 "../src/parser/fol.y"</span>
<a name="l01950"></a>01950 <span class="preprocessor"></span>    {
<a name="l01951"></a>01951     <span class="keywordflow">if</span> (zzconstantMustBeDeclared)
<a name="l01952"></a>01952       zzerr(<span class="stringliteral">"Constant %s must be declared before it is used."</span>,
<a name="l01953"></a>01953             zztokenList.<a class="code" href="classStrFifoList.html#708a82bf7b398f6404d93887ba7f9a4c">back</a>());
<a name="l01954"></a>01954     <span class="keyword">const</span> <span class="keywordtype">char</span>* tmp = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01955"></a>01955         zztmpReturnConstant = (<span class="keywordtype">char</span> *)malloc((strlen(tmp) + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01956"></a>01956         strcpy(zztmpReturnConstant, tmp);
<a name="l01957"></a>01957         zztmpReturnNum = <span class="keyword">false</span>;
<a name="l01958"></a>01958         <span class="keyword">delete</span> []tmp;
<a name="l01959"></a>01959         <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"ic_%s "</span>, zztmpReturnConstant);
<a name="l01960"></a>01960   ;}
<a name="l01961"></a>01961     <span class="keywordflow">break</span>;
<a name="l01962"></a>01962 
<a name="l01963"></a>01963   <span class="keywordflow">case</span> 90:
<a name="l01964"></a>01964 <span class="preprocessor">#line 955 "../src/parser/fol.y"</span>
<a name="l01965"></a>01965 <span class="preprocessor"></span>    {
<a name="l01966"></a>01966         <span class="keyword">const</span> <span class="keywordtype">char</span>* tmp = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01967"></a>01967         zztmpReturnConstant = (<span class="keywordtype">char</span> *)malloc((strlen(tmp) + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01968"></a>01968         strcpy(zztmpReturnConstant, tmp);
<a name="l01969"></a>01969         zztmpReturnNum = <span class="keyword">true</span>;
<a name="l01970"></a>01970         <span class="keyword">delete</span> []tmp;
<a name="l01971"></a>01971         <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"icnum_%s "</span>, zztmpReturnConstant); 
<a name="l01972"></a>01972   ;}
<a name="l01973"></a>01973     <span class="keywordflow">break</span>;
<a name="l01974"></a>01974 
<a name="l01975"></a>01975   <span class="keywordflow">case</span> 91:
<a name="l01976"></a>01976 <span class="preprocessor">#line 964 "../src/parser/fol.y"</span>
<a name="l01977"></a>01977 <span class="preprocessor"></span>    {
<a name="l01978"></a>01978     <span class="keywordflow">if</span> (zzconstantMustBeDeclared)
<a name="l01979"></a>01979       zzerr(<span class="stringliteral">"Constant %s must be declared before it is used"</span>,
<a name="l01980"></a>01980             zztokenList.<a class="code" href="classStrFifoList.html#708a82bf7b398f6404d93887ba7f9a4c">back</a>());
<a name="l01981"></a>01981     <span class="keyword">const</span> <span class="keywordtype">char</span>* tmp = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01982"></a>01982         zztmpReturnConstant = (<span class="keywordtype">char</span> *)malloc((strlen(tmp) + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l01983"></a>01983         strcpy(zztmpReturnConstant, tmp);
<a name="l01984"></a>01984         zztmpReturnNum = <span class="keyword">false</span>;
<a name="l01985"></a>01985         <span class="keyword">delete</span> []tmp;
<a name="l01986"></a>01986         <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"ic_%s "</span>, zztmpReturnConstant);
<a name="l01987"></a>01987   ;}
<a name="l01988"></a>01988     <span class="keywordflow">break</span>;
<a name="l01989"></a>01989 
<a name="l01990"></a>01990   <span class="keywordflow">case</span> 93:
<a name="l01991"></a>01991 <span class="preprocessor">#line 982 "../src/parser/fol.y"</span>
<a name="l01992"></a>01992 <span class="preprocessor"></span>    {
<a name="l01993"></a>01993     <span class="keyword">const</span> <span class="keywordtype">char</span>* wt = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l01994"></a>01994     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"n_%f "</span>, atof(wt));
<a name="l01995"></a>01995     <span class="keywordflow">if</span> (zzwt) <span class="keyword">delete</span> zzwt;
<a name="l01996"></a>01996     zzwt = <span class="keyword">new</span> double(atof(wt));
<a name="l01997"></a>01997     <span class="keyword">delete</span> [] wt;
<a name="l01998"></a>01998   ;}
<a name="l01999"></a>01999     <span class="keywordflow">break</span>;
<a name="l02000"></a>02000 
<a name="l02001"></a>02001   <span class="keywordflow">case</span> 94:
<a name="l02002"></a>02002 <span class="preprocessor">#line 996 "../src/parser/fol.y"</span>
<a name="l02003"></a>02003 <span class="preprocessor"></span>    { 
<a name="l02004"></a>02004     zzconsumeToken(zztokenList,<span class="stringliteral">"("</span>); 
<a name="l02005"></a>02005     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"( "</span>); 
<a name="l02006"></a>02006     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"sentence: '(' sentence\n"</span>);
<a name="l02007"></a>02007     zzformulaStr.append(<span class="stringliteral">"("</span>);
<a name="l02008"></a>02008   ;}
<a name="l02009"></a>02009     <span class="keywordflow">break</span>;
<a name="l02010"></a>02010 
<a name="l02011"></a>02011   <span class="keywordflow">case</span> 95:
<a name="l02012"></a>02012 <span class="preprocessor">#line 1004 "../src/parser/fol.y"</span>
<a name="l02013"></a>02013 <span class="preprocessor"></span>    { 
<a name="l02014"></a>02014     zzconsumeToken(zztokenList,<span class="stringliteral">")"</span>); 
<a name="l02015"></a>02015     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">") "</span>); 
<a name="l02016"></a>02016     zzformulaStr.append(<span class="stringliteral">")"</span>);
<a name="l02017"></a>02017   ;}
<a name="l02018"></a>02018     <span class="keywordflow">break</span>;
<a name="l02019"></a>02019 
<a name="l02020"></a>02020   <span class="keywordflow">case</span> 96:
<a name="l02021"></a>02021 <span class="preprocessor">#line 1010 "../src/parser/fol.y"</span>
<a name="l02022"></a>02022 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"sentence: atomic_sentence\n"</span>); ;}
<a name="l02023"></a>02023     <span class="keywordflow">break</span>;
<a name="l02024"></a>02024 
<a name="l02025"></a>02025   <span class="keywordflow">case</span> 98:
<a name="l02026"></a>02026 <span class="preprocessor">#line 1014 "../src/parser/fol.y"</span>
<a name="l02027"></a>02027 <span class="preprocessor"></span>    {
<a name="l02028"></a>02028     <span class="keyword">const</span> <span class="keywordtype">char</span>* imp = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>(); 
<a name="l02029"></a>02029     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"=&gt; "</span>);
<a name="l02030"></a>02030     zzformulaStr.append(<span class="stringliteral">" =&gt; "</span>);
<a name="l02031"></a>02031     <span class="keyword">delete</span> [] imp;
<a name="l02032"></a>02032   ;}
<a name="l02033"></a>02033     <span class="keywordflow">break</span>;
<a name="l02034"></a>02034 
<a name="l02035"></a>02035   <span class="keywordflow">case</span> 99:
<a name="l02036"></a>02036 <span class="preprocessor">#line 1022 "../src/parser/fol.y"</span>
<a name="l02037"></a>02037 <span class="preprocessor"></span>    { zzcreateListObjFromTopTwo(zzformulaListObjs, <span class="stringliteral">"=&gt;"</span>); ;}
<a name="l02038"></a>02038     <span class="keywordflow">break</span>;
<a name="l02039"></a>02039 
<a name="l02040"></a>02040   <span class="keywordflow">case</span> 100:
<a name="l02041"></a>02041 <span class="preprocessor">#line 1026 "../src/parser/fol.y"</span>
<a name="l02042"></a>02042 <span class="preprocessor"></span>    { 
<a name="l02043"></a>02043     <span class="keyword">const</span> <span class="keywordtype">char</span>* eq = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>(); 
<a name="l02044"></a>02044     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"&lt;=&gt; "</span>);
<a name="l02045"></a>02045     zzformulaStr.append(<span class="stringliteral">" &lt;=&gt; "</span>);
<a name="l02046"></a>02046     <span class="keyword">delete</span> [] eq;  
<a name="l02047"></a>02047   ;}
<a name="l02048"></a>02048     <span class="keywordflow">break</span>;
<a name="l02049"></a>02049 
<a name="l02050"></a>02050   <span class="keywordflow">case</span> 101:
<a name="l02051"></a>02051 <span class="preprocessor">#line 1034 "../src/parser/fol.y"</span>
<a name="l02052"></a>02052 <span class="preprocessor"></span>    { zzcreateListObjFromTopTwo(zzformulaListObjs, <span class="stringliteral">"&lt;=&gt;"</span>); ;}
<a name="l02053"></a>02053     <span class="keywordflow">break</span>;
<a name="l02054"></a>02054 
<a name="l02055"></a>02055   <span class="keywordflow">case</span> 102:
<a name="l02056"></a>02056 <span class="preprocessor">#line 1038 "../src/parser/fol.y"</span>
<a name="l02057"></a>02057 <span class="preprocessor"></span>    { 
<a name="l02058"></a>02058     zzconsumeToken(zztokenList,<span class="stringliteral">"v"</span>); 
<a name="l02059"></a>02059     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"v "</span>); 
<a name="l02060"></a>02060     zzformulaStr.append(<span class="stringliteral">" v "</span>);
<a name="l02061"></a>02061   ;}
<a name="l02062"></a>02062     <span class="keywordflow">break</span>;
<a name="l02063"></a>02063 
<a name="l02064"></a>02064   <span class="keywordflow">case</span> 103:
<a name="l02065"></a>02065 <span class="preprocessor">#line 1045 "../src/parser/fol.y"</span>
<a name="l02066"></a>02066 <span class="preprocessor"></span>    { zzcreateListObjFromTopTwo(zzformulaListObjs, <span class="stringliteral">"v"</span>); ;}
<a name="l02067"></a>02067     <span class="keywordflow">break</span>;
<a name="l02068"></a>02068 
<a name="l02069"></a>02069   <span class="keywordflow">case</span> 104:
<a name="l02070"></a>02070 <span class="preprocessor">#line 1049 "../src/parser/fol.y"</span>
<a name="l02071"></a>02071 <span class="preprocessor"></span>    { 
<a name="l02072"></a>02072     zzconsumeToken(zztokenList,<span class="stringliteral">"^"</span>); 
<a name="l02073"></a>02073     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"^ "</span>); 
<a name="l02074"></a>02074     zzformulaStr.append(<span class="stringliteral">" ^ "</span>);
<a name="l02075"></a>02075   ;}
<a name="l02076"></a>02076     <span class="keywordflow">break</span>;
<a name="l02077"></a>02077 
<a name="l02078"></a>02078   <span class="keywordflow">case</span> 105:
<a name="l02079"></a>02079 <span class="preprocessor">#line 1056 "../src/parser/fol.y"</span>
<a name="l02080"></a>02080 <span class="preprocessor"></span>    { zzcreateListObjFromTopTwo(zzformulaListObjs, <span class="stringliteral">"^"</span>); ;}
<a name="l02081"></a>02081     <span class="keywordflow">break</span>;
<a name="l02082"></a>02082 
<a name="l02083"></a>02083   <span class="keywordflow">case</span> 106:
<a name="l02084"></a>02084 <span class="preprocessor">#line 1060 "../src/parser/fol.y"</span>
<a name="l02085"></a>02085 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"sentence: quantifier\n"</span>); ;}
<a name="l02086"></a>02086     <span class="keywordflow">break</span>;
<a name="l02087"></a>02087 
<a name="l02088"></a>02088   <span class="keywordflow">case</span> 107:
<a name="l02089"></a>02089 <span class="preprocessor">#line 1062 "../src/parser/fol.y"</span>
<a name="l02090"></a>02090 <span class="preprocessor"></span>    { 
<a name="l02091"></a>02091     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"sentence: variables\n"</span>); 
<a name="l02092"></a>02092     zzformulaListObjs.push(<span class="keyword">new</span> <a class="code" href="classListObj.html">ListObj</a>);
<a name="l02093"></a>02093     pair&lt;StringToStringMap*,int&gt; pr(<span class="keyword">new</span> StringToStringMap,zzscopeCounter++);
<a name="l02094"></a>02094     zzoldNewVarList.push_front(pr);
<a name="l02095"></a>02095   ;}
<a name="l02096"></a>02096     <span class="keywordflow">break</span>;
<a name="l02097"></a>02097 
<a name="l02098"></a>02098   <span class="keywordflow">case</span> 108:
<a name="l02099"></a>02099 <span class="preprocessor">#line 1068 "../src/parser/fol.y"</span>
<a name="l02100"></a>02100 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"sentence: sentence\n"</span>); ;}
<a name="l02101"></a>02101     <span class="keywordflow">break</span>;
<a name="l02102"></a>02102 
<a name="l02103"></a>02103   <span class="keywordflow">case</span> 109:
<a name="l02104"></a>02104 <span class="preprocessor">#line 1070 "../src/parser/fol.y"</span>
<a name="l02105"></a>02105 <span class="preprocessor"></span>    { 
<a name="l02106"></a>02106     zzcreateListObjFromTopThree(zzformulaListObjs);
<a name="l02107"></a>02107     pair&lt;StringToStringMap*, int&gt; pr = zzoldNewVarList.front();
<a name="l02108"></a>02108     zzoldNewVarList.pop_front();
<a name="l02109"></a>02109     <span class="keyword">delete</span> pr.first;
<a name="l02110"></a>02110   ;}
<a name="l02111"></a>02111     <span class="keywordflow">break</span>;
<a name="l02112"></a>02112 
<a name="l02113"></a>02113   <span class="keywordflow">case</span> 110:
<a name="l02114"></a>02114 <span class="preprocessor">#line 1079 "../src/parser/fol.y"</span>
<a name="l02115"></a>02115 <span class="preprocessor"></span>    { 
<a name="l02116"></a>02116     zzassert(!zzisNegated,<span class="stringliteral">"expecting !zzisNegated"</span>);
<a name="l02117"></a>02117     zzisNegated = <span class="keyword">true</span>;
<a name="l02118"></a>02118 
<a name="l02119"></a>02119     zzconsumeToken(zztokenList,<span class="stringliteral">"!"</span>);
<a name="l02120"></a>02120     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"! "</span>); 
<a name="l02121"></a>02121     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"sentence: sentence\n"</span>);
<a name="l02122"></a>02122     zzformulaStr.append(<span class="stringliteral">"!"</span>);
<a name="l02123"></a>02123   ;}
<a name="l02124"></a>02124     <span class="keywordflow">break</span>;
<a name="l02125"></a>02125 
<a name="l02126"></a>02126   <span class="keywordflow">case</span> 111:
<a name="l02127"></a>02127 <span class="preprocessor">#line 1089 "../src/parser/fol.y"</span>
<a name="l02128"></a>02128 <span class="preprocessor"></span>    { zzcreateListObjFromTop(zzformulaListObjs, <span class="stringliteral">"!"</span>); ;}
<a name="l02129"></a>02129     <span class="keywordflow">break</span>;
<a name="l02130"></a>02130 
<a name="l02131"></a>02131   <span class="keywordflow">case</span> 112:
<a name="l02132"></a>02132 <span class="preprocessor">#line 1095 "../src/parser/fol.y"</span>
<a name="l02133"></a>02133 <span class="preprocessor"></span>    { 
<a name="l02134"></a>02134     <span class="keyword">const</span> <span class="keywordtype">char</span>* fa = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l02135"></a>02135     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"FORALL "</span>);
<a name="l02136"></a>02136     zzformulaListObjs.push(<span class="keyword">new</span> ListObj(<span class="stringliteral">"FORALL"</span>));
<a name="l02137"></a>02137     zzformulaStr.append(<span class="stringliteral">"FORALL "</span>);
<a name="l02138"></a>02138     <span class="keyword">delete</span> [] fa;
<a name="l02139"></a>02139   ;}
<a name="l02140"></a>02140     <span class="keywordflow">break</span>;
<a name="l02141"></a>02141 
<a name="l02142"></a>02142   <span class="keywordflow">case</span> 113:
<a name="l02143"></a>02143 <span class="preprocessor">#line 1103 "../src/parser/fol.y"</span>
<a name="l02144"></a>02144 <span class="preprocessor"></span>    { 
<a name="l02145"></a>02145     <span class="keyword">const</span> <span class="keywordtype">char</span>* ex = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l02146"></a>02146     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"EXIST "</span>); 
<a name="l02147"></a>02147     zzformulaListObjs.push(<span class="keyword">new</span> ListObj(<span class="stringliteral">"EXIST"</span>));
<a name="l02148"></a>02148     zzformulaStr.append(<span class="stringliteral">"EXIST "</span>);
<a name="l02149"></a>02149     <span class="keyword">delete</span> [] ex;
<a name="l02150"></a>02150   ;}
<a name="l02151"></a>02151     <span class="keywordflow">break</span>;
<a name="l02152"></a>02152 
<a name="l02153"></a>02153   <span class="keywordflow">case</span> 114:
<a name="l02154"></a>02154 <span class="preprocessor">#line 1115 "../src/parser/fol.y"</span>
<a name="l02155"></a>02155 <span class="preprocessor"></span>    { <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"variables: variables\n"</span>); ;}
<a name="l02156"></a>02156     <span class="keywordflow">break</span>;
<a name="l02157"></a>02157 
<a name="l02158"></a>02158   <span class="keywordflow">case</span> 115:
<a name="l02159"></a>02159 <span class="preprocessor">#line 1117 "../src/parser/fol.y"</span>
<a name="l02160"></a>02160 <span class="preprocessor"></span>    {  
<a name="l02161"></a>02161     zzconsumeToken(zztokenList,<span class="stringliteral">","</span>);
<a name="l02162"></a>02162     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">", "</span>); 
<a name="l02163"></a>02163     zzformulaStr.append(<span class="stringliteral">","</span>);
<a name="l02164"></a>02164   ;}
<a name="l02165"></a>02165     <span class="keywordflow">break</span>;
<a name="l02166"></a>02166 
<a name="l02167"></a>02167   <span class="keywordflow">case</span> 117:
<a name="l02168"></a>02168 <span class="preprocessor">#line 1124 "../src/parser/fol.y"</span>
<a name="l02169"></a>02169 <span class="preprocessor"></span>    { zzformulaStr.append(<span class="stringliteral">" "</span>); ;}
<a name="l02170"></a>02170     <span class="keywordflow">break</span>;
<a name="l02171"></a>02171 
<a name="l02172"></a>02172   <span class="keywordflow">case</span> 118:
<a name="l02173"></a>02173 <span class="preprocessor">#line 1129 "../src/parser/fol.y"</span>
<a name="l02174"></a>02174 <span class="preprocessor"></span>    {
<a name="l02175"></a>02175   <span class="keyword">const</span> <span class="keywordtype">char</span>* varName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();  
<a name="l02176"></a>02176   <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"v_%s "</span>, varName); 
<a name="l02177"></a>02177 
<a name="l02178"></a>02178   <span class="comment">//if (isupper(varName[0])) </span>
<a name="l02179"></a>02179   <span class="keywordflow">if</span> (zzisConstant(varName)) 
<a name="l02180"></a>02180   {
<a name="l02181"></a>02181     zzerr(<span class="stringliteral">"Variable %s must be begin with a lowercase character."</span>, varName);
<a name="l02182"></a>02182     ((<span class="keywordtype">char</span>*)varName)[0] = tolower(varName[0]);
<a name="l02183"></a>02183   }
<a name="l02184"></a>02184 
<a name="l02185"></a>02185   <span class="keywordtype">int</span> scopeNum = zzoldNewVarList.front().second;
<a name="l02186"></a>02186   string newVarName = zzappend(varName,scopeNum);
<a name="l02187"></a>02187 
<a name="l02188"></a>02188   StringToStringMap* oldNewVarMap = zzoldNewVarList.front().first;
<a name="l02189"></a>02189   (*oldNewVarMap)[varName]=newVarName;
<a name="l02190"></a>02190   zzvarNameToIdMap[newVarName] = <a class="code" href="structZZVarIdType.html">ZZVarIdType</a>(--zzvarCounter, zzanyTypeId);
<a name="l02191"></a>02191   zzformulaListObjs.top()-&gt;append(newVarName.c_str());
<a name="l02192"></a>02192   zzformulaStr.append(varName); <span class="comment">//use the old var name in the orig string</span>
<a name="l02193"></a>02193   <span class="keyword">delete</span> [] varName;
<a name="l02194"></a>02194 ;}
<a name="l02195"></a>02195     <span class="keywordflow">break</span>;
<a name="l02196"></a>02196 
<a name="l02197"></a>02197   <span class="keywordflow">case</span> 119:
<a name="l02198"></a>02198 <span class="preprocessor">#line 1155 "../src/parser/fol.y"</span>
<a name="l02199"></a>02199 <span class="preprocessor"></span>    {
<a name="l02200"></a>02200     <span class="keyword">const</span> <span class="keywordtype">char</span>* predName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l02201"></a>02201     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"p_%s "</span>, predName); 
<a name="l02202"></a>02202 
<a name="l02203"></a>02203     zzfdnumPreds++;
<a name="l02204"></a>02204     ListObj* predlo = <span class="keyword">new</span> ListObj;
<a name="l02205"></a>02205 
<a name="l02206"></a>02206         <span class="keywordflow">if</span> (<a class="code" href="classPredicateTemplate.html#e0e97f9e9a1ad80d2d7e7a24cb3e1bf6">PredicateTemplate::isInternalPredicateTemplateName</a>(predName))
<a name="l02207"></a>02207         {
<a name="l02208"></a>02208           <span class="comment">//zzinfixPredName is misused here to store internal pred. name</span>
<a name="l02209"></a>02209           zzinfixPredName = (<span class="keywordtype">char</span> *)malloc((strlen(predName)
<a name="l02210"></a>02210                                                                         + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l02211"></a>02211           strcpy(zzinfixPredName, predName);
<a name="l02212"></a>02212           <span class="keyword">const</span> <a class="code" href="classPredicateTemplate.html">PredicateTemplate</a>* t = zzdomain-&gt;<a class="code" href="classDomain.html#eef78ec2808589b539266f40c16adfcd">getEmptyPredicateTemplate</a>();
<a name="l02213"></a>02213       zzassert(zzpred == NULL,<span class="stringliteral">"expecting zzpred==NULL"</span>);
<a name="l02214"></a>02214       zzpred = <span class="keyword">new</span> <a class="code" href="classPredicate.html">Predicate</a>(t);
<a name="l02215"></a>02215       predlo-&gt;<a class="code" href="classListObj.html#0419cac49e66f9dc6d87b0166a23a7ba">append</a>(<a class="code" href="classPredicateTemplate.html#189e0afe52155516d9e0674ee671a630">PredicateTemplate::EMPTY_NAME</a>);
<a name="l02216"></a>02216         }
<a name="l02217"></a>02217         <span class="keywordflow">else</span>
<a name="l02218"></a>02218         {
<a name="l02219"></a>02219       zzcreatePred(zzpred, predName);
<a name="l02220"></a>02220       predlo-&gt;<a class="code" href="classListObj.html#0419cac49e66f9dc6d87b0166a23a7ba">append</a>(predName);
<a name="l02221"></a>02221         }
<a name="l02222"></a>02222         
<a name="l02223"></a>02223     zzformulaStr.append(predName);
<a name="l02224"></a>02224     <span class="keywordflow">if</span>(zzisNegated)  { zzpred-&gt;<a class="code" href="classPredicate.html#ed74cd0a0b4d90189f41a7201ab351ea">setSense</a>(<span class="keyword">false</span>); zzisNegated = <span class="keyword">false</span>; }
<a name="l02225"></a>02225     zzpredFuncListObjs.push(predlo);
<a name="l02226"></a>02226     <span class="keyword">delete</span> [] predName;
<a name="l02227"></a>02227   ;}
<a name="l02228"></a>02228     <span class="keywordflow">break</span>;
<a name="l02229"></a>02229 
<a name="l02230"></a>02230   <span class="keywordflow">case</span> 120:
<a name="l02231"></a>02231 <span class="preprocessor">#line 1185 "../src/parser/fol.y"</span>
<a name="l02232"></a>02232 <span class="preprocessor"></span>    {  
<a name="l02233"></a>02233     zzconsumeToken(zztokenList, <span class="stringliteral">"("</span>);
<a name="l02234"></a>02234     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"( "</span>); 
<a name="l02235"></a>02235     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"atomic_sentence: terms\n"</span>); 
<a name="l02236"></a>02236     zzformulaStr.append(<span class="stringliteral">"("</span>);
<a name="l02237"></a>02237 
<a name="l02238"></a>02238   ;}
<a name="l02239"></a>02239     <span class="keywordflow">break</span>;
<a name="l02240"></a>02240 
<a name="l02241"></a>02241   <span class="keywordflow">case</span> 121:
<a name="l02242"></a>02242 <span class="preprocessor">#line 1194 "../src/parser/fol.y"</span>
<a name="l02243"></a>02243 <span class="preprocessor"></span>    {  
<a name="l02244"></a>02244     zzconsumeToken(zztokenList, <span class="stringliteral">")"</span>);
<a name="l02245"></a>02245     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">") "</span>); 
<a name="l02246"></a>02246 
<a name="l02247"></a>02247           <span class="comment">//If an internal pred., then need to determine type</span>
<a name="l02248"></a>02248           <span class="comment">//zzinfixPredName is misused here to store internal pred. name</span>
<a name="l02249"></a>02249         <span class="keywordflow">if</span> (zzinfixPredName)
<a name="l02250"></a>02250         {
<a name="l02251"></a>02251           ListObj* predlo = zzpredFuncListObjs.top();
<a name="l02252"></a>02252       predlo-&gt;<a class="code" href="classListObj.html#c38530b0c3c331d3147040726987ec7e">replace</a>(<a class="code" href="classPredicateTemplate.html#189e0afe52155516d9e0674ee671a630">PredicateTemplate::EMPTY_NAME</a>, zzinfixPredName);
<a name="l02253"></a>02253                 <span class="comment">// types are possibly unknown</span>
<a name="l02254"></a>02254                 <span class="comment">// If '=' predicate then types are possibly unknown</span>
<a name="l02255"></a>02255                 <span class="comment">//if (strcmp(zzinfixPredName, PredicateTemplate::EQUAL_NAME)==0) {</span>
<a name="l02256"></a>02256       <span class="keywordtype">int</span> lTypeId = zzgetTypeId(zzpred-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(0), (*predlo)[1]-&gt;getStr());
<a name="l02257"></a>02257       <span class="keywordtype">int</span> rTypeId = zzgetTypeId(zzpred-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(1), (*predlo)[2]-&gt;getStr());
<a name="l02258"></a>02258 
<a name="l02259"></a>02259       <span class="keywordflow">if</span> (lTypeId &gt; 0 &amp;&amp; rTypeId &gt; 0) <span class="comment">//if both types are known</span>
<a name="l02260"></a>02260       {
<a name="l02261"></a>02261         <span class="keywordflow">if</span> (lTypeId != rTypeId)
<a name="l02262"></a>02262           zzerr(<span class="stringliteral">"The types on the left and right of '=' must match."</span>);
<a name="l02263"></a>02263         <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02264"></a>02264         {
<a name="l02265"></a>02265               zzsetEqPredTypeName(lTypeId);
<a name="l02266"></a>02266             }
<a name="l02267"></a>02267             <span class="keywordflow">else</span>
<a name="l02268"></a>02268             {
<a name="l02269"></a>02269               zzsetInternalPredTypeName(zzinfixPredName, lTypeId);
<a name="l02270"></a>02270             }
<a name="l02271"></a>02271       }
<a name="l02272"></a>02272       <span class="keywordflow">else</span>  <span class="comment">// if only one type is known</span>
<a name="l02273"></a>02273       <span class="keywordflow">if</span> ( (lTypeId&lt;=0 &amp;&amp; rTypeId&gt;0) || (lTypeId&gt;0 &amp;&amp; rTypeId&lt;=0) )
<a name="l02274"></a>02274       {
<a name="l02275"></a>02275         <span class="keywordtype">int</span> knownTypeId = (lTypeId&gt;0) ? lTypeId : rTypeId;
<a name="l02276"></a>02276         <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02277"></a>02277         {
<a name="l02278"></a>02278           zzsetEqPredTypeName(knownTypeId);
<a name="l02279"></a>02279         }
<a name="l02280"></a>02280         <span class="keywordflow">else</span>
<a name="l02281"></a>02281             {
<a name="l02282"></a>02282               zzsetInternalPredTypeName(zzinfixPredName, knownTypeId);
<a name="l02283"></a>02283             }
<a name="l02284"></a>02284         <span class="keyword">const</span> <span class="keywordtype">char</span>* lvarName = (*predlo)[1]-&gt;getStr();
<a name="l02285"></a>02285         <span class="keyword">const</span> <span class="keywordtype">char</span>* rvarName = (*predlo)[2]-&gt;getStr();
<a name="l02286"></a>02286         <span class="keyword">const</span> <span class="keywordtype">char</span>* unknownVarName = (lTypeId&gt;0) ?  rvarName : lvarName;
<a name="l02287"></a>02287         zzvarNameToIdMap[unknownVarName].typeId_ = knownTypeId;
<a name="l02288"></a>02288       }
<a name="l02289"></a>02289       <span class="keywordflow">else</span> <span class="comment">// if both types are unknown</span>
<a name="l02290"></a>02290       {
<a name="l02291"></a>02291           <span class="comment">//both sides must be variables</span>
<a name="l02292"></a>02292         <span class="keyword">const</span> <span class="keywordtype">char</span>* lvarName = (*predlo)[1]-&gt;getStr();
<a name="l02293"></a>02293         <span class="keyword">const</span> <span class="keywordtype">char</span>* rvarName = (*predlo)[2]-&gt;getStr();
<a name="l02294"></a>02294         lTypeId = zzgetVarTypeId(lvarName);
<a name="l02295"></a>02295         rTypeId = zzgetVarTypeId(rvarName);
<a name="l02296"></a>02296         
<a name="l02297"></a>02297         <span class="keywordflow">if</span> (lTypeId &gt; 0 &amp;&amp; rTypeId &gt; 0) <span class="comment">//if both types are known</span>
<a name="l02298"></a>02298         {
<a name="l02299"></a>02299           <span class="keywordflow">if</span> (lTypeId != rTypeId)
<a name="l02300"></a>02300             zzerr(<span class="stringliteral">"The types of %s and %s on the left and right of "</span>
<a name="l02301"></a>02301                    <span class="stringliteral">"'=' must match."</span>, lvarName, rvarName);
<a name="l02302"></a>02302           <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02303"></a>02303           {
<a name="l02304"></a>02304                 zzsetEqPredTypeName(lTypeId);
<a name="l02305"></a>02305           }
<a name="l02306"></a>02306           <span class="keywordflow">else</span>
<a name="l02307"></a>02307               {
<a name="l02308"></a>02308                 zzsetInternalPredTypeName(zzinfixPredName, lTypeId);
<a name="l02309"></a>02309               }
<a name="l02310"></a>02310         }
<a name="l02311"></a>02311         <span class="keywordflow">else</span>  <span class="comment">// if only one type is known</span>
<a name="l02312"></a>02312         <span class="keywordflow">if</span> ( (lTypeId&lt;=0 &amp;&amp; rTypeId&gt;0) || (lTypeId&gt;0 &amp;&amp; rTypeId&lt;=0) )
<a name="l02313"></a>02313         {
<a name="l02314"></a>02314           <span class="keywordtype">int</span> knownTypeId = (lTypeId&gt;0) ? lTypeId : rTypeId;
<a name="l02315"></a>02315           <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02316"></a>02316           {
<a name="l02317"></a>02317                 zzsetEqPredTypeName(knownTypeId);
<a name="l02318"></a>02318           }
<a name="l02319"></a>02319           <span class="keywordflow">else</span>
<a name="l02320"></a>02320               {
<a name="l02321"></a>02321                 zzsetInternalPredTypeName(zzinfixPredName, knownTypeId);
<a name="l02322"></a>02322               }
<a name="l02323"></a>02323           <span class="keyword">const</span> <span class="keywordtype">char</span>* unknowVarName = (lTypeId&gt;0) ?  rvarName : lvarName;
<a name="l02324"></a>02324           zzvarNameToIdMap[unknowVarName].typeId_ = knownTypeId;
<a name="l02325"></a>02325         }
<a name="l02326"></a>02326         <span class="keywordflow">else</span>
<a name="l02327"></a>02327         {      
<a name="l02328"></a>02328                   <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02329"></a>02329           {
<a name="l02330"></a>02330                 string unknownEqName = zzappend(<a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>, 
<a name="l02331"></a>02331                                             zzeqTypeCounter++);
<a name="l02332"></a>02332                 zzeqPredList.push_back(<a class="code" href="structZZUnknownEqPredInfo.html">ZZUnknownEqPredInfo</a>(unknownEqName,lvarName,
<a name="l02333"></a>02333                                                        rvarName));
<a name="l02334"></a>02334                 predlo-&gt;<a class="code" href="classListObj.html#c38530b0c3c331d3147040726987ec7e">replace</a>(<a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>, unknownEqName.c_str());
<a name="l02335"></a>02335           }
<a name="l02336"></a>02336           <span class="keywordflow">else</span>
<a name="l02337"></a>02337           {
<a name="l02338"></a>02338                 string unknownIntPredName =
<a name="l02339"></a>02339                   zzappendWithUnderscore(zzinfixPredName, zzintPredTypeCounter++);
<a name="l02340"></a>02340                 zzintPredList.push_back(<a class="code" href="structZZUnknownIntPredInfo.html">ZZUnknownIntPredInfo</a>(unknownIntPredName, lvarName,
<a name="l02341"></a>02341                                                          rvarName));
<a name="l02342"></a>02342                 predlo-&gt;<a class="code" href="classListObj.html#c38530b0c3c331d3147040726987ec7e">replace</a>(zzinfixPredName, unknownIntPredName.c_str());
<a name="l02343"></a>02343           }
<a name="l02344"></a>02344         }
<a name="l02345"></a>02345       }
<a name="l02346"></a>02346           free(zzinfixPredName);
<a name="l02347"></a>02347       zzinfixPredName = NULL;
<a name="l02348"></a>02348         }
<a name="l02349"></a>02349 
<a name="l02350"></a>02350     zzcheckPredNumTerm(zzpred);
<a name="l02351"></a>02351     <span class="keyword">delete</span> zzpred;
<a name="l02352"></a>02352     zzpred = NULL;
<a name="l02353"></a>02353     zzassert(zzpredFuncListObjs.size()==1,
<a name="l02354"></a>02354              <span class="stringliteral">"expecting zzpredFuncListObjs.size()==1"</span>);
<a name="l02355"></a>02355     ListObj* predlo = zzpredFuncListObjs.top();
<a name="l02356"></a>02356     zzpredFuncListObjs.pop();
<a name="l02357"></a>02357 
<a name="l02358"></a>02358     <span class="keywordflow">if</span>(zzisAsterisk)
<a name="l02359"></a>02359     {
<a name="l02360"></a>02360       zzisAsterisk = <span class="keyword">false</span>;
<a name="l02361"></a>02361       ListObj* lo = <span class="keyword">new</span> ListObj;
<a name="l02362"></a>02362       lo-&gt;<a class="code" href="classListObj.html#0419cac49e66f9dc6d87b0166a23a7ba">append</a>(<span class="stringliteral">"*"</span>); lo-&gt;<a class="code" href="classListObj.html#0419cac49e66f9dc6d87b0166a23a7ba">append</a>(predlo);
<a name="l02363"></a>02363       zzformulaListObjs.push(lo);
<a name="l02364"></a>02364     }
<a name="l02365"></a>02365     <span class="keywordflow">else</span>
<a name="l02366"></a>02366       zzformulaListObjs.push(predlo);
<a name="l02367"></a>02367 
<a name="l02368"></a>02368     zzformulaStr.append(<span class="stringliteral">")"</span>);
<a name="l02369"></a>02369 
<a name="l02370"></a>02370         <span class="comment">// If we have replaced a function inside the predicate</span>
<a name="l02371"></a>02371         <span class="comment">// then we have to add the conjunction</span>
<a name="l02372"></a>02372         <span class="keywordflow">while</span> (!zzfuncConjStack.empty())
<a name="l02373"></a>02373         {
<a name="l02374"></a>02374                 <span class="comment">// create the second part of the conjunction</span>
<a name="l02375"></a>02375                 <span class="comment">//zzformulaStr.append(" ^ ");</span>
<a name="l02376"></a>02376       ListObj* topPredlo = zzfuncConjStack.top();
<a name="l02377"></a>02377       zzfuncConjStack.pop();
<a name="l02378"></a>02378       zzformulaListObjs.push(topPredlo);
<a name="l02379"></a>02379       zzcreateListObjFromTopTwo(zzformulaListObjs, <span class="stringliteral">"^"</span>);
<a name="l02380"></a>02380         } <span class="comment">//while (!zzfuncConjStack.empty())</span>
<a name="l02381"></a>02381 
<a name="l02382"></a>02382         <span class="keywordflow">if</span> (!zzfuncConjStr.empty())
<a name="l02383"></a>02383         {
<a name="l02384"></a>02384       zzformulaStr.append(zzfuncConjStr);
<a name="l02385"></a>02385       zzfuncConjStr.clear();
<a name="l02386"></a>02386         }
<a name="l02387"></a>02387         zzfunc = NULL;
<a name="l02388"></a>02388   ;}
<a name="l02389"></a>02389     <span class="keywordflow">break</span>;
<a name="l02390"></a>02390 
<a name="l02391"></a>02391   <span class="keywordflow">case</span> 122:
<a name="l02392"></a>02392 <span class="preprocessor">#line 1342 "../src/parser/fol.y"</span>
<a name="l02393"></a>02393 <span class="preprocessor"></span>    {
<a name="l02394"></a>02394     ++zzfdnumPreds;
<a name="l02395"></a>02395     <span class="comment">//zzfdisEqualPred = true;</span>
<a name="l02396"></a>02396     <span class="comment">//const PredicateTemplate* t = zzdomain-&gt;getEqualPredicateTemplate();</span>
<a name="l02397"></a>02397     <span class="keyword">const</span> <a class="code" href="classPredicateTemplate.html">PredicateTemplate</a>* t = zzdomain-&gt;<a class="code" href="classDomain.html#eef78ec2808589b539266f40c16adfcd">getEmptyPredicateTemplate</a>();
<a name="l02398"></a>02398         
<a name="l02399"></a>02399     zzassert(zzpred == NULL,<span class="stringliteral">"expecting zzpred==NULL"</span>);
<a name="l02400"></a>02400     zzpred = <span class="keyword">new</span> <a class="code" href="classPredicate.html">Predicate</a>(t);
<a name="l02401"></a>02401 
<a name="l02402"></a>02402     ListObj* predlo = <span class="keyword">new</span> ListObj;
<a name="l02403"></a>02403     <span class="comment">//predlo-&gt;append(PredicateTemplate::EQUAL_NAME);</span>
<a name="l02404"></a>02404     predlo-&gt;<a class="code" href="classListObj.html#0419cac49e66f9dc6d87b0166a23a7ba">append</a>(<a class="code" href="classPredicateTemplate.html#189e0afe52155516d9e0674ee671a630">PredicateTemplate::EMPTY_NAME</a>);
<a name="l02405"></a>02405     zzpredFuncListObjs.push(predlo);
<a name="l02406"></a>02406     <span class="keywordflow">if</span>(zzisNegated)  { zzpred-&gt;<a class="code" href="classPredicate.html#ed74cd0a0b4d90189f41a7201ab351ea">setSense</a>(<span class="keyword">false</span>); zzisNegated = <span class="keyword">false</span>; }
<a name="l02407"></a>02407 
<a name="l02408"></a>02408     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"atomic_sentence (left): term\n"</span>); 
<a name="l02409"></a>02409   ;}
<a name="l02410"></a>02410     <span class="keywordflow">break</span>;
<a name="l02411"></a>02411 
<a name="l02412"></a>02412   <span class="keywordflow">case</span> 123:
<a name="l02413"></a>02413 <span class="preprocessor">#line 1361 "../src/parser/fol.y"</span>
<a name="l02414"></a>02414 <span class="preprocessor"></span>    {
<a name="l02415"></a>02415         ListObj* predlo = zzpredFuncListObjs.top();
<a name="l02416"></a>02416     predlo-&gt;<a class="code" href="classListObj.html#c38530b0c3c331d3147040726987ec7e">replace</a>(<a class="code" href="classPredicateTemplate.html#189e0afe52155516d9e0674ee671a630">PredicateTemplate::EMPTY_NAME</a>, zzinfixPredName);
<a name="l02417"></a>02417     
<a name="l02418"></a>02418           <span class="comment">// If type known from LHS, then set the pred types accordingly</span>
<a name="l02419"></a>02419     <span class="keywordtype">int</span> lTypeId = zzgetTypeId(zzpred-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(0), (*predlo)[1]-&gt;getStr());
<a name="l02420"></a>02420     <span class="keywordflow">if</span> (lTypeId&gt;0)
<a name="l02421"></a>02421     {
<a name="l02422"></a>02422       <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02423"></a>02423       {
<a name="l02424"></a>02424         zzsetEqPredTypeName(lTypeId);
<a name="l02425"></a>02425       }
<a name="l02426"></a>02426       <span class="keywordflow">else</span>
<a name="l02427"></a>02427           {
<a name="l02428"></a>02428             zzsetInternalPredTypeName(zzinfixPredName, lTypeId);
<a name="l02429"></a>02429           }
<a name="l02430"></a>02430     }
<a name="l02431"></a>02431   ;}
<a name="l02432"></a>02432     <span class="keywordflow">break</span>;
<a name="l02433"></a>02433 
<a name="l02434"></a>02434   <span class="keywordflow">case</span> 124:
<a name="l02435"></a>02435 <span class="preprocessor">#line 1380 "../src/parser/fol.y"</span>
<a name="l02436"></a>02436 <span class="preprocessor"></span>    {  
<a name="l02437"></a>02437     ListObj* predlo = zzpredFuncListObjs.top();
<a name="l02438"></a>02438     <span class="comment">//predlo-&gt;replace(PredicateTemplate::EMPTY_NAME, zzinfixPredName);</span>
<a name="l02439"></a>02439 
<a name="l02440"></a>02440         <span class="comment">// types are possibly unknown</span>
<a name="l02441"></a>02441         <span class="comment">// If '=' predicate then types are possibly unknown</span>
<a name="l02442"></a>02442         <span class="comment">//if (strcmp(zzinfixPredName, PredicateTemplate::EQUAL_NAME)==0) {</span>
<a name="l02443"></a>02443       <span class="keywordtype">int</span> lTypeId = zzgetTypeId(zzpred-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(0), (*predlo)[1]-&gt;getStr());
<a name="l02444"></a>02444       <span class="keywordtype">int</span> rTypeId = zzgetTypeId(zzpred-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(1), (*predlo)[2]-&gt;getStr());
<a name="l02445"></a>02445 
<a name="l02446"></a>02446       <span class="keywordflow">if</span> (lTypeId &gt; 0 &amp;&amp; rTypeId &gt; 0) <span class="comment">//if both types are known</span>
<a name="l02447"></a>02447       {
<a name="l02448"></a>02448         <span class="keywordflow">if</span> (lTypeId != rTypeId)
<a name="l02449"></a>02449           zzerr(<span class="stringliteral">"The types on the left and right of '=' must match."</span>);
<a name="l02450"></a>02450         <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02451"></a>02451         {
<a name="l02452"></a>02452               zzsetEqPredTypeName(lTypeId);
<a name="l02453"></a>02453             }
<a name="l02454"></a>02454             <span class="keywordflow">else</span>
<a name="l02455"></a>02455             {
<a name="l02456"></a>02456               zzsetInternalPredTypeName(zzinfixPredName, lTypeId);
<a name="l02457"></a>02457             }
<a name="l02458"></a>02458       }
<a name="l02459"></a>02459       <span class="keywordflow">else</span>  <span class="comment">// if only one type is known</span>
<a name="l02460"></a>02460       <span class="keywordflow">if</span> ( (lTypeId&lt;=0 &amp;&amp; rTypeId&gt;0) || (lTypeId&gt;0 &amp;&amp; rTypeId&lt;=0) )
<a name="l02461"></a>02461       {
<a name="l02462"></a>02462         <span class="keywordtype">int</span> knownTypeId = (lTypeId&gt;0) ? lTypeId : rTypeId;
<a name="l02463"></a>02463         <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02464"></a>02464         {
<a name="l02465"></a>02465           zzsetEqPredTypeName(knownTypeId);
<a name="l02466"></a>02466         }
<a name="l02467"></a>02467         <span class="keywordflow">else</span>
<a name="l02468"></a>02468             {
<a name="l02469"></a>02469               zzsetInternalPredTypeName(zzinfixPredName, knownTypeId);
<a name="l02470"></a>02470             }
<a name="l02471"></a>02471         <span class="keyword">const</span> <span class="keywordtype">char</span>* lvarName = (*predlo)[1]-&gt;getStr();
<a name="l02472"></a>02472         <span class="keyword">const</span> <span class="keywordtype">char</span>* rvarName = (*predlo)[2]-&gt;getStr();
<a name="l02473"></a>02473         <span class="keyword">const</span> <span class="keywordtype">char</span>* unknownVarName = (lTypeId&gt;0) ?  rvarName : lvarName;
<a name="l02474"></a>02474         zzvarNameToIdMap[unknownVarName].typeId_ = knownTypeId;
<a name="l02475"></a>02475       }
<a name="l02476"></a>02476       <span class="keywordflow">else</span> <span class="comment">// if both types are unknown</span>
<a name="l02477"></a>02477       {
<a name="l02478"></a>02478           <span class="comment">//both sides must be variables</span>
<a name="l02479"></a>02479         <span class="keyword">const</span> <span class="keywordtype">char</span>* lvarName = (*predlo)[1]-&gt;getStr();
<a name="l02480"></a>02480         <span class="keyword">const</span> <span class="keywordtype">char</span>* rvarName = (*predlo)[2]-&gt;getStr();
<a name="l02481"></a>02481         lTypeId = zzgetVarTypeId(lvarName);
<a name="l02482"></a>02482         rTypeId = zzgetVarTypeId(rvarName);
<a name="l02483"></a>02483         
<a name="l02484"></a>02484         <span class="keywordflow">if</span> (lTypeId &gt; 0 &amp;&amp; rTypeId &gt; 0) <span class="comment">//if both types are known</span>
<a name="l02485"></a>02485         {
<a name="l02486"></a>02486           <span class="keywordflow">if</span> (lTypeId != rTypeId)
<a name="l02487"></a>02487             zzerr(<span class="stringliteral">"The types of %s and %s on the left and right of "</span>
<a name="l02488"></a>02488                    <span class="stringliteral">"'=' must match."</span>, lvarName, rvarName);
<a name="l02489"></a>02489           <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02490"></a>02490           {
<a name="l02491"></a>02491                 zzsetEqPredTypeName(lTypeId);
<a name="l02492"></a>02492           }
<a name="l02493"></a>02493           <span class="keywordflow">else</span>
<a name="l02494"></a>02494               {
<a name="l02495"></a>02495                 zzsetInternalPredTypeName(zzinfixPredName, lTypeId);
<a name="l02496"></a>02496               }
<a name="l02497"></a>02497         }
<a name="l02498"></a>02498         <span class="keywordflow">else</span>  <span class="comment">// if only one type is known</span>
<a name="l02499"></a>02499         <span class="keywordflow">if</span> ( (lTypeId&lt;=0 &amp;&amp; rTypeId&gt;0) || (lTypeId&gt;0 &amp;&amp; rTypeId&lt;=0) )
<a name="l02500"></a>02500         {
<a name="l02501"></a>02501           <span class="keywordtype">int</span> knownTypeId = (lTypeId&gt;0) ? lTypeId : rTypeId;
<a name="l02502"></a>02502           <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02503"></a>02503           {
<a name="l02504"></a>02504                 zzsetEqPredTypeName(knownTypeId);
<a name="l02505"></a>02505           }
<a name="l02506"></a>02506           <span class="keywordflow">else</span>
<a name="l02507"></a>02507               {
<a name="l02508"></a>02508                 zzsetInternalPredTypeName(zzinfixPredName, knownTypeId);
<a name="l02509"></a>02509               }
<a name="l02510"></a>02510           <span class="keyword">const</span> <span class="keywordtype">char</span>* unknowVarName = (lTypeId&gt;0) ?  rvarName : lvarName;
<a name="l02511"></a>02511           zzvarNameToIdMap[unknowVarName].typeId_ = knownTypeId;
<a name="l02512"></a>02512         }
<a name="l02513"></a>02513         <span class="keywordflow">else</span>
<a name="l02514"></a>02514         {      
<a name="l02515"></a>02515                   <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02516"></a>02516           {
<a name="l02517"></a>02517                 string unknownEqName = zzappend(<a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>, 
<a name="l02518"></a>02518                                             zzeqTypeCounter++);
<a name="l02519"></a>02519                 zzeqPredList.push_back(<a class="code" href="structZZUnknownEqPredInfo.html">ZZUnknownEqPredInfo</a>(unknownEqName,lvarName,
<a name="l02520"></a>02520                                                        rvarName));
<a name="l02521"></a>02521                 predlo-&gt;<a class="code" href="classListObj.html#c38530b0c3c331d3147040726987ec7e">replace</a>(<a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>, unknownEqName.c_str());
<a name="l02522"></a>02522           }
<a name="l02523"></a>02523           <span class="keywordflow">else</span>
<a name="l02524"></a>02524           {
<a name="l02525"></a>02525                 string unknownIntPredName =
<a name="l02526"></a>02526                   zzappendWithUnderscore(zzinfixPredName, zzintPredTypeCounter++);
<a name="l02527"></a>02527                 zzintPredList.push_back(<a class="code" href="structZZUnknownIntPredInfo.html">ZZUnknownIntPredInfo</a>(unknownIntPredName, lvarName,
<a name="l02528"></a>02528                                                          rvarName));
<a name="l02529"></a>02529                 predlo-&gt;<a class="code" href="classListObj.html#c38530b0c3c331d3147040726987ec7e">replace</a>(zzinfixPredName, unknownIntPredName.c_str());
<a name="l02530"></a>02530           }
<a name="l02531"></a>02531         }
<a name="l02532"></a>02532       }
<a name="l02533"></a>02533         <span class="comment">//}</span>
<a name="l02534"></a>02534         <span class="comment">//else // Infix predicate other than '='</span>
<a name="l02535"></a>02535         <span class="comment">//{</span>
<a name="l02536"></a>02536           <span class="comment">//Only left term could be unknown</span>
<a name="l02537"></a>02537           <span class="comment">//const char* leftTerm = (*predlo)[1]-&gt;getStr();</span>
<a name="l02538"></a>02538         <span class="comment">//}</span>
<a name="l02539"></a>02539             
<a name="l02540"></a>02540     zzassert(zzpredFuncListObjs.size()==1,
<a name="l02541"></a>02541              <span class="stringliteral">"expecting zzpredFuncListObjs.size()==1"</span>);
<a name="l02542"></a>02542     ListObj* topPredlo = zzpredFuncListObjs.top();
<a name="l02543"></a>02543     zzpredFuncListObjs.pop();
<a name="l02544"></a>02544     zzformulaListObjs.push(topPredlo);
<a name="l02545"></a>02545         
<a name="l02546"></a>02546         <span class="keyword">delete</span> zzpred;
<a name="l02547"></a>02547         zzpred = NULL;
<a name="l02548"></a>02548         
<a name="l02549"></a>02549         <span class="comment">// If we have replaced a function inside the predicate</span>
<a name="l02550"></a>02550         <span class="comment">// then we have to add the conjunction</span>
<a name="l02551"></a>02551         <span class="keywordflow">while</span> (!zzfuncConjStack.empty())
<a name="l02552"></a>02552         {
<a name="l02553"></a>02553           <span class="comment">// create the second part of the conjunction</span>
<a name="l02554"></a>02554           <span class="comment">//zzformulaStr.append(" ^ ");</span>
<a name="l02555"></a>02555                 
<a name="l02556"></a>02556       ListObj* topPredlo = zzfuncConjStack.top();
<a name="l02557"></a>02557           zzfuncConjStack.pop();
<a name="l02558"></a>02558           zzformulaListObjs.push(topPredlo);
<a name="l02559"></a>02559           zzcreateListObjFromTopTwo(zzformulaListObjs, <span class="stringliteral">"^"</span>);
<a name="l02560"></a>02560         } <span class="comment">//while (!zzfuncConjStack.empty())</span>
<a name="l02561"></a>02561 
<a name="l02562"></a>02562         <span class="keywordflow">if</span> (!zzfuncConjStr.empty())
<a name="l02563"></a>02563         {
<a name="l02564"></a>02564           zzformulaStr.append(zzfuncConjStr);
<a name="l02565"></a>02565           zzfuncConjStr.clear();
<a name="l02566"></a>02566         }
<a name="l02567"></a>02567         zzfunc = NULL;
<a name="l02568"></a>02568         free(zzinfixPredName);
<a name="l02569"></a>02569     zzinfixPredName = NULL;
<a name="l02570"></a>02570   ;}
<a name="l02571"></a>02571     <span class="keywordflow">break</span>;
<a name="l02572"></a>02572 
<a name="l02573"></a>02573   <span class="keywordflow">case</span> 125:
<a name="l02574"></a>02574 <span class="preprocessor">#line 1519 "../src/parser/fol.y"</span>
<a name="l02575"></a>02575 <span class="preprocessor"></span>    {
<a name="l02576"></a>02576         zzconsumeToken(zztokenList, <span class="stringliteral">"&gt;"</span>);
<a name="l02577"></a>02577     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"&gt; "</span>); 
<a name="l02578"></a>02578     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"atomic_sentence (right): term\n"</span>); 
<a name="l02579"></a>02579     zzformulaStr.append(<span class="stringliteral">" &gt; "</span>);
<a name="l02580"></a>02580     zzinfixPredName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#3200e737325bc60696adcb219123e41b">PredicateTemplate::GT_NAME</a>)
<a name="l02581"></a>02581                                                                   + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l02582"></a>02582         strcpy(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#3200e737325bc60696adcb219123e41b">PredicateTemplate::GT_NAME</a>);
<a name="l02583"></a>02583         <span class="comment">//zzcreateInternalPredTemplate(zzinfixPredName);</span>
<a name="l02584"></a>02584     <span class="comment">//const PredicateTemplate* t = zzdomain-&gt;getPredicateTemplate(zzinfixPredName);</span>
<a name="l02585"></a>02585         <span class="comment">//zzpred-&gt;setTemplate((PredicateTemplate*)t);</span>
<a name="l02586"></a>02586   ;}
<a name="l02587"></a>02587     <span class="keywordflow">break</span>;
<a name="l02588"></a>02588 
<a name="l02589"></a>02589   <span class="keywordflow">case</span> 126:
<a name="l02590"></a>02590 <span class="preprocessor">#line 1533 "../src/parser/fol.y"</span>
<a name="l02591"></a>02591 <span class="preprocessor"></span>    {
<a name="l02592"></a>02592         zzconsumeToken(zztokenList, <span class="stringliteral">"&lt;"</span>);
<a name="l02593"></a>02593     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"&lt; "</span>); 
<a name="l02594"></a>02594     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"atomic_sentence (right): term\n"</span>); 
<a name="l02595"></a>02595     zzformulaStr.append(<span class="stringliteral">" &lt; "</span>); 
<a name="l02596"></a>02596     zzinfixPredName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#31b5560e29de2b037d5bf561894119e6">PredicateTemplate::LT_NAME</a>)
<a name="l02597"></a>02597                                                                   + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l02598"></a>02598         strcpy(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#31b5560e29de2b037d5bf561894119e6">PredicateTemplate::LT_NAME</a>);
<a name="l02599"></a>02599         <span class="comment">//zzcreateInternalPredTemplate(zzinfixPredName);</span>
<a name="l02600"></a>02600     <span class="comment">//const PredicateTemplate* t = zzdomain-&gt;getPredicateTemplate(zzinfixPredName);</span>
<a name="l02601"></a>02601         <span class="comment">//zzpred-&gt;setTemplate((PredicateTemplate*)t);</span>
<a name="l02602"></a>02602   ;}
<a name="l02603"></a>02603     <span class="keywordflow">break</span>;
<a name="l02604"></a>02604 
<a name="l02605"></a>02605   <span class="keywordflow">case</span> 127:
<a name="l02606"></a>02606 <span class="preprocessor">#line 1547 "../src/parser/fol.y"</span>
<a name="l02607"></a>02607 <span class="preprocessor"></span>    {
<a name="l02608"></a>02608         zzconsumeToken(zztokenList, <span class="stringliteral">"&gt;"</span>);
<a name="l02609"></a>02609     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"&gt;"</span>);
<a name="l02610"></a>02610     zzformulaStr.append(<span class="stringliteral">" &gt;"</span>);
<a name="l02611"></a>02611     zzconsumeToken(zztokenList, <span class="stringliteral">"="</span>);
<a name="l02612"></a>02612     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"= "</span>); 
<a name="l02613"></a>02613     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"atomic_sentence (right): term\n"</span>); 
<a name="l02614"></a>02614     zzformulaStr.append(<span class="stringliteral">"= "</span>);
<a name="l02615"></a>02615     zzinfixPredName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#41139320b30633bb540f3ad300f3acab">PredicateTemplate::GTEQ_NAME</a>)
<a name="l02616"></a>02616                                                                   + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l02617"></a>02617         strcpy(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#41139320b30633bb540f3ad300f3acab">PredicateTemplate::GTEQ_NAME</a>);
<a name="l02618"></a>02618         <span class="comment">//zzcreateInternalPredTemplate(zzinfixPredName);</span>
<a name="l02619"></a>02619         <span class="comment">//const PredicateTemplate* t = zzdomain-&gt;getPredicateTemplate(zzinfixPredName);</span>
<a name="l02620"></a>02620         <span class="comment">//zzpred-&gt;setTemplate((PredicateTemplate*)t);</span>
<a name="l02621"></a>02621   ;}
<a name="l02622"></a>02622     <span class="keywordflow">break</span>;
<a name="l02623"></a>02623 
<a name="l02624"></a>02624   <span class="keywordflow">case</span> 128:
<a name="l02625"></a>02625 <span class="preprocessor">#line 1564 "../src/parser/fol.y"</span>
<a name="l02626"></a>02626 <span class="preprocessor"></span>    {
<a name="l02627"></a>02627         zzconsumeToken(zztokenList, <span class="stringliteral">"&lt;"</span>);
<a name="l02628"></a>02628     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"&lt;"</span>);
<a name="l02629"></a>02629     zzformulaStr.append(<span class="stringliteral">" &lt;"</span>);
<a name="l02630"></a>02630     zzconsumeToken(zztokenList, <span class="stringliteral">"="</span>);
<a name="l02631"></a>02631     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"= "</span>); 
<a name="l02632"></a>02632     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"atomic_sentence (right): term\n"</span>); 
<a name="l02633"></a>02633     zzformulaStr.append(<span class="stringliteral">"= "</span>);
<a name="l02634"></a>02634     zzinfixPredName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#e2fb2c6414cba5e2ec35a57b9df61f58">PredicateTemplate::LTEQ_NAME</a>)
<a name="l02635"></a>02635                                                                   + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l02636"></a>02636         strcpy(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#e2fb2c6414cba5e2ec35a57b9df61f58">PredicateTemplate::LTEQ_NAME</a>);
<a name="l02637"></a>02637         <span class="comment">//zzcreateInternalPredTemplate(zzinfixPredName);</span>
<a name="l02638"></a>02638     <span class="comment">//const PredicateTemplate* t = zzdomain-&gt;getPredicateTemplate(zzinfixPredName);</span>
<a name="l02639"></a>02639         <span class="comment">//zzpred-&gt;setTemplate((PredicateTemplate*)t);</span>
<a name="l02640"></a>02640   ;}
<a name="l02641"></a>02641     <span class="keywordflow">break</span>;
<a name="l02642"></a>02642 
<a name="l02643"></a>02643   <span class="keywordflow">case</span> 129:
<a name="l02644"></a>02644 <span class="preprocessor">#line 1581 "../src/parser/fol.y"</span>
<a name="l02645"></a>02645 <span class="preprocessor"></span>    {
<a name="l02646"></a>02646         zzconsumeToken(zztokenList, <span class="stringliteral">"="</span>);
<a name="l02647"></a>02647     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"= "</span>); 
<a name="l02648"></a>02648     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"atomic_sentence (right): term\n"</span>); 
<a name="l02649"></a>02649     zzformulaStr.append(<span class="stringliteral">" = "</span>);
<a name="l02650"></a>02650     zzinfixPredName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)
<a name="l02651"></a>02651                                                                   + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l02652"></a>02652         strcpy(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>);
<a name="l02653"></a>02653     <span class="keyword">const</span> <a class="code" href="classPredicateTemplate.html">PredicateTemplate</a>* t = zzdomain-&gt;<a class="code" href="classDomain.html#88db99efba0e695fbf70258b68409102">getEqualPredicateTemplate</a>();
<a name="l02654"></a>02654         zzpred-&gt;<a class="code" href="classPredicate.html#0bdb9466d29406e1adc57f11a111a062">setTemplate</a>((<a class="code" href="classPredicateTemplate.html">PredicateTemplate</a>*)t);
<a name="l02655"></a>02655   ;}
<a name="l02656"></a>02656     <span class="keywordflow">break</span>;
<a name="l02657"></a>02657 
<a name="l02658"></a>02658   <span class="keywordflow">case</span> 131:
<a name="l02659"></a>02659 <span class="preprocessor">#line 1598 "../src/parser/fol.y"</span>
<a name="l02660"></a>02660 <span class="preprocessor"></span>    { 
<a name="l02661"></a>02661     zzconsumeToken(zztokenList, <span class="stringliteral">"*"</span>);
<a name="l02662"></a>02662     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"* "</span>); 
<a name="l02663"></a>02663     <span class="keywordflow">if</span> (zzisNegated) zzerr(<span class="stringliteral">"'!' and '*' cannot be used at the same time"</span>);
<a name="l02664"></a>02664     zznumAsterisk++;
<a name="l02665"></a>02665     zzassert(!zzisAsterisk,<span class="stringliteral">"expecting !zzisAsterisk"</span>);
<a name="l02666"></a>02666     zzisAsterisk = <span class="keyword">true</span>;
<a name="l02667"></a>02667     zzformulaStr.append(<span class="stringliteral">"*"</span>);
<a name="l02668"></a>02668   ;}
<a name="l02669"></a>02669     <span class="keywordflow">break</span>;
<a name="l02670"></a>02670 
<a name="l02671"></a>02671   <span class="keywordflow">case</span> 132:
<a name="l02672"></a>02672 <span class="preprocessor">#line 1615 "../src/parser/fol.y"</span>
<a name="l02673"></a>02673 <span class="preprocessor"></span>    {  
<a name="l02674"></a>02674     zzconsumeToken(zztokenList, <span class="stringliteral">","</span>);
<a name="l02675"></a>02675     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">", "</span>); 
<a name="l02676"></a>02676     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"terms: term\n"</span>); 
<a name="l02677"></a>02677     <span class="comment">// While parsing function, we do not want to append anything to the formula</span>
<a name="l02678"></a>02678     <span class="keywordflow">if</span> (zzfunc == NULL) zzformulaStr.append(<span class="stringliteral">","</span>);
<a name="l02679"></a>02679   ;}
<a name="l02680"></a>02680     <span class="keywordflow">break</span>;
<a name="l02681"></a>02681 
<a name="l02682"></a>02682   <span class="keywordflow">case</span> 134:
<a name="l02683"></a>02683 <span class="preprocessor">#line 1626 "../src/parser/fol.y"</span>
<a name="l02684"></a>02684 <span class="preprocessor"></span>    {
<a name="l02685"></a>02685         <span class="comment">// After the first term in an internal pred., check if we can determine type</span>
<a name="l02686"></a>02686         <span class="keywordflow">if</span> (zzpred &amp;&amp; zzpred-&gt;<a class="code" href="classPredicate.html#7742fe90ddd2d07e24d844e931be55db">isEmptyPred</a>() &amp;&amp;
<a name="l02687"></a>02687                 zzpred-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>() == 1 &amp;&amp; zzinfixPredName)
<a name="l02688"></a>02688         {
<a name="l02689"></a>02689       ListObj* predlo = zzpredFuncListObjs.top();
<a name="l02690"></a>02690       predlo-&gt;<a class="code" href="classListObj.html#c38530b0c3c331d3147040726987ec7e">replace</a>(<a class="code" href="classPredicateTemplate.html#189e0afe52155516d9e0674ee671a630">PredicateTemplate::EMPTY_NAME</a>, zzinfixPredName);
<a name="l02691"></a>02691     
<a name="l02692"></a>02692                 <span class="comment">// If type known from term, then set the pred types accordingly</span>
<a name="l02693"></a>02693           <span class="keywordtype">int</span> lTypeId = zzgetTypeId(zzpred-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(0), (*predlo)[1]-&gt;getStr());
<a name="l02694"></a>02694       <span class="keywordflow">if</span> (lTypeId&gt;0)
<a name="l02695"></a>02695       {
<a name="l02696"></a>02696         <span class="keywordflow">if</span> (strcmp(zzinfixPredName, <a class="code" href="classPredicateTemplate.html#8293dceb69034f9a3cdc96aa3993219b">PredicateTemplate::EQUAL_NAME</a>)==0)
<a name="l02697"></a>02697         {
<a name="l02698"></a>02698           zzsetEqPredTypeName(lTypeId);
<a name="l02699"></a>02699         }
<a name="l02700"></a>02700         <span class="keywordflow">else</span>
<a name="l02701"></a>02701                 {
<a name="l02702"></a>02702               zzsetInternalPredTypeName(zzinfixPredName, lTypeId);
<a name="l02703"></a>02703                 }
<a name="l02704"></a>02704       }
<a name="l02705"></a>02705         }
<a name="l02706"></a>02706   ;}
<a name="l02707"></a>02707     <span class="keywordflow">break</span>;
<a name="l02708"></a>02708 
<a name="l02709"></a>02709   <span class="keywordflow">case</span> 135:
<a name="l02710"></a>02710 <span class="preprocessor">#line 1654 "../src/parser/fol.y"</span>
<a name="l02711"></a>02711 <span class="preprocessor"></span>    {  
<a name="l02712"></a>02712     zzassert(zzfunc != NULL,<span class="stringliteral">"expecting zzfunc != NULL"</span>);
<a name="l02713"></a>02713     zzcheckFuncNumTerm(zzfunc);
<a name="l02714"></a>02714     zzassert(zzpred != NULL, <span class="stringliteral">"expecting zzpred != NULL"</span>);
<a name="l02715"></a>02715 
<a name="l02716"></a>02716            <span class="comment">// replace function</span>
<a name="l02717"></a>02717          
<a name="l02718"></a>02718            <span class="comment">// Append Term funcVar&lt;zzfuncVarCounter&gt; to predicate where</span>
<a name="l02719"></a>02719            <span class="comment">// function appears and set flag to add conjunction</span>
<a name="l02720"></a>02720 
<a name="l02721"></a>02721            <span class="comment">// 1. Make new variable</span>
<a name="l02722"></a>02722     <span class="keywordtype">char</span>* varName;
<a name="l02723"></a>02723     string newVarName;
<a name="l02724"></a>02724     
<a name="l02725"></a>02725       <span class="comment">// Check if function mapping already occurs in formula</span>
<a name="l02726"></a>02726     ZZFuncToFuncVarMap::iterator mit;
<a name="l02727"></a>02727     <span class="keywordflow">if</span> ((mit = zzfuncToFuncVarMap.find(zzfunc)) != zzfuncToFuncVarMap.end())
<a name="l02728"></a>02728     {
<a name="l02729"></a>02729       newVarName = (*mit).second;
<a name="l02730"></a>02730       varName = (<span class="keywordtype">char</span> *)malloc((strlen(newVarName.c_str()) + 1) * <span class="keyword">sizeof</span>(char));
<a name="l02731"></a>02731       strcpy(varName, newVarName.c_str());
<a name="l02732"></a>02732     }
<a name="l02733"></a>02733     <span class="keywordflow">else</span>
<a name="l02734"></a>02734     {
<a name="l02735"></a>02735       <span class="keywordtype">char</span> funcVarCounterString[10];
<a name="l02736"></a>02736       <span class="keywordtype">int</span> funcVarCounterLength =
<a name="l02737"></a>02737         sprintf(funcVarCounterString, <span class="stringliteral">"%d"</span>, zzfuncVarCounter);
<a name="l02738"></a>02738       varName = (<span class="keywordtype">char</span> *)malloc((strlen(ZZ_FUNCVAR_PREFIX) +
<a name="l02739"></a>02739                                                                 funcVarCounterLength + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l02740"></a>02740       strcpy(varName, ZZ_FUNCVAR_PREFIX);
<a name="l02741"></a>02741       strcat(varName, funcVarCounterString);
<a name="l02742"></a>02742       ++zzfdnumVars;
<a name="l02743"></a>02743       ++zzfuncVarCounter;
<a name="l02744"></a>02744       newVarName = zzgetNewVarName(varName);
<a name="l02745"></a>02745       
<a name="l02746"></a>02746       <a class="code" href="classFunction.html">Function</a>* func = <span class="keyword">new</span> <a class="code" href="classFunction.html">Function</a>(*zzfunc);
<a name="l02747"></a>02747       zzfuncToFuncVarMap[func] = newVarName;
<a name="l02748"></a>02748     }
<a name="l02749"></a>02749       
<a name="l02750"></a>02750         <span class="keywordtype">bool</span> rightNumTerms = <span class="keyword">true</span>;
<a name="l02751"></a>02751         <span class="keywordtype">bool</span> rightType = <span class="keyword">true</span>;
<a name="l02752"></a>02752         <span class="keywordtype">int</span> exp, unexp;
<a name="l02753"></a>02753 
<a name="l02754"></a>02754         <span class="comment">// 2. Create new predicate</span>
<a name="l02755"></a>02755         <span class="comment">// Predicate name is PredicateTemplate::ZZ_RETURN_PREFIX + function name</span>
<a name="l02756"></a>02756         <span class="keywordtype">char</span>* predName;
<a name="l02757"></a>02757         predName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#62e623b43316dadb940ca05273ecb19d">PredicateTemplate::ZZ_RETURN_PREFIX</a>) +
<a name="l02758"></a>02758                                                    strlen(zzfunc-&gt;<a class="code" href="classFunction.html#22517da6cd8a0d6055955e684261f13c">getName</a>()) + 1)*<span class="keyword">sizeof</span>(char));
<a name="l02759"></a>02759         strcpy(predName, <a class="code" href="classPredicateTemplate.html#62e623b43316dadb940ca05273ecb19d">PredicateTemplate::ZZ_RETURN_PREFIX</a>);
<a name="l02760"></a>02760         strcat(predName, zzfunc-&gt;<a class="code" href="classFunction.html#22517da6cd8a0d6055955e684261f13c">getName</a>());
<a name="l02761"></a>02761         
<a name="l02762"></a>02762         <span class="comment">// Only insert predicate declaration, if not yet declared</span>
<a name="l02763"></a>02763         <span class="keywordflow">if</span> (zzdomain-&gt;<a class="code" href="classDomain.html#9dcb8a8aa5bb91ed993cb428f2587ad3">getPredicateId</a>(predName) &lt; 0)
<a name="l02764"></a>02764         {
<a name="l02765"></a>02765           zzassert(zzpredTemplate==NULL,<span class="stringliteral">"expecting zzpredTemplate==NULL"</span>);
<a name="l02766"></a>02766           zzpredTemplate = <span class="keyword">new</span> <a class="code" href="classPredicateTemplate.html">PredicateTemplate</a>();
<a name="l02767"></a>02767           zzpredTemplate-&gt;<a class="code" href="classPredicateTemplate.html#0f9961d21b84e1ca8eb47358dddd59fa">setName</a>(predName);
<a name="l02768"></a>02768                         
<a name="l02769"></a>02769           <span class="comment">// Register the types</span>
<a name="l02770"></a>02770           <span class="comment">// First parameter is the return type</span>
<a name="l02771"></a>02771           <span class="keyword">const</span> <span class="keywordtype">char</span>* ttype = zzfunc-&gt;<a class="code" href="classFunction.html#7f25805c7450a4fac495d6325c08a9ec">getRetTypeName</a>();
<a name="l02772"></a>02772           zzaddType(ttype, zzpredTemplate, NULL, <span class="keyword">false</span>, zzdomain);
<a name="l02773"></a>02773         
<a name="l02774"></a>02774           <span class="comment">// Register the parameter types</span>
<a name="l02775"></a>02775           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; zzfunc-&gt;<a class="code" href="classFunction.html#26a1c0122abee1da8fee665d6fb605b8">getNumTerms</a>(); i++)
<a name="l02776"></a>02776           {
<a name="l02777"></a>02777                 <span class="keyword">const</span> <span class="keywordtype">char</span>* ttype = zzfunc-&gt;<a class="code" href="classFunction.html#d4e0e04bad75da785c52e85ba88cfb49">getTermTypeAsStr</a>(i);
<a name="l02778"></a>02778                 zzaddType(ttype, zzpredTemplate, NULL, <span class="keyword">false</span>, zzdomain);
<a name="l02779"></a>02779           }
<a name="l02780"></a>02780         
<a name="l02781"></a>02781           zzassert(zzpredTemplate, <span class="stringliteral">"not expecting zzpredTemplate==NULL"</span>);
<a name="l02782"></a>02782           <span class="keywordtype">int</span> <span class="keywordtype">id</span> = zzdomain-&gt;<a class="code" href="classDomain.html#3a0e9d73d6e3c2e06c08968fc4d8df98">addPredicateTemplate</a>(zzpredTemplate);
<a name="l02783"></a>02783           zzassert(<span class="keywordtype">id</span> &gt;= 0, <span class="stringliteral">"expecting pred template id &gt;= 0"</span>);
<a name="l02784"></a>02784           zzpredTemplate-&gt;<a class="code" href="classPredicateTemplate.html#8f539d7a139332cf444a3ccb46fd4e09">setId</a>(<span class="keywordtype">id</span>);
<a name="l02785"></a>02785           zzpredTemplate = NULL;
<a name="l02786"></a>02786         }
<a name="l02787"></a>02787 
<a name="l02788"></a>02788         <a class="code" href="classPredicate.html">Predicate</a>* prevPred = zzpred;
<a name="l02789"></a>02789         zzpred = NULL;
<a name="l02790"></a>02790     zzfdnumPreds++;
<a name="l02791"></a>02791         zzcreatePred(zzpred, predName);
<a name="l02792"></a>02792         
<a name="l02793"></a>02793     ListObj* predlo = <span class="keyword">new</span> ListObj;
<a name="l02794"></a>02794     predlo-&gt;<a class="code" href="classListObj.html#0419cac49e66f9dc6d87b0166a23a7ba">append</a>(predName);
<a name="l02795"></a>02795                 
<a name="l02796"></a>02796         <span class="comment">// Put predicate list object in stack to be used in conjunction later</span>
<a name="l02797"></a>02797     zzfuncConjStack.push(predlo);
<a name="l02798"></a>02798     zzfuncConjStr.append(<span class="stringliteral">" ^ "</span>);
<a name="l02799"></a>02799     zzfuncConjStr.append(predName);
<a name="l02800"></a>02800         zzfuncConjStr.append(<span class="stringliteral">"("</span>);
<a name="l02801"></a>02801     zzputVariableInPred(varName, folDbg);
<a name="l02802"></a>02802     zzfuncConjStack.top()-&gt;append(varName);
<a name="l02803"></a>02803     zzfuncConjStr.append(varName);
<a name="l02804"></a>02804         
<a name="l02805"></a>02805         <span class="comment">// Information about the terms is in zzfunc</span>
<a name="l02806"></a>02806         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; zzfunc-&gt;<a class="code" href="classFunction.html#26a1c0122abee1da8fee665d6fb605b8">getNumTerms</a>(); i++)
<a name="l02807"></a>02807         {
<a name="l02808"></a>02808           zzfuncConjStr.append(<span class="stringliteral">", "</span>);
<a name="l02809"></a>02809           <a class="code" href="classTerm.html">Term</a>* term = <span class="keyword">new</span> <a class="code" href="classTerm.html">Term</a>(*zzfunc-&gt;<a class="code" href="classFunction.html#f958b9afddea5b67355930cb6b7a11f0">getTerm</a>(i));
<a name="l02810"></a>02810           zzpred-&gt;<a class="code" href="classPredicate.html#18435d6147604eafd6f0ac092e471b3a">appendTerm</a>(term);
<a name="l02811"></a>02811 
<a name="l02812"></a>02812           <span class="keyword">const</span> <span class="keywordtype">char</span>* name;
<a name="l02813"></a>02813           <span class="keywordflow">if</span> (term-&gt;getType() == Term::VARIABLE)
<a name="l02814"></a>02814           {
<a name="l02815"></a>02815                 name = (*zzpredFuncListObjs.top())[i+1]-&gt;getStr();
<a name="l02816"></a>02816           }
<a name="l02817"></a>02817           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (term-&gt;getType() == Term::CONSTANT)
<a name="l02818"></a>02818           {
<a name="l02819"></a>02819                 name = zzdomain-&gt;<a class="code" href="classDomain.html#05654c441be6afb1ef378d19f3ca0acc">getConstantName</a>(term-&gt;getId());
<a name="l02820"></a>02820           }
<a name="l02821"></a>02821           zzpredFuncListObjs.top()-&gt;append(name);
<a name="l02822"></a>02822           zzfuncConjStack.top()-&gt;append(name);
<a name="l02823"></a>02823           zzfuncConjStr.append(name);
<a name="l02824"></a>02824         }
<a name="l02825"></a>02825         zzfuncConjStr.append(<span class="stringliteral">")"</span>);
<a name="l02826"></a>02826                 
<a name="l02827"></a>02827     <span class="comment">// 4. Append new variable to function in stack or to predicate</span>
<a name="l02828"></a>02828     <span class="keywordflow">if</span> (!zzfuncStack.empty())
<a name="l02829"></a>02829     {
<a name="l02830"></a>02830           <a class="code" href="classFunction.html">Function</a>* prevFunc = zzfuncStack.top(); 
<a name="l02831"></a>02831           zzfuncStack.pop();
<a name="l02832"></a>02832     
<a name="l02833"></a>02833       <span class="comment">// check that we have not exceeded the number of terms</span>
<a name="l02834"></a>02834       <span class="keywordflow">if</span> ((unexp=prevFunc-&gt;getNumTerms()) ==
<a name="l02835"></a>02835           (exp=prevFunc-&gt;getTemplate()-&gt;getNumTerms()))
<a name="l02836"></a>02836       {
<a name="l02837"></a>02837         rightNumTerms = <span class="keyword">false</span>;
<a name="l02838"></a>02838         zzerr(<span class="stringliteral">"Wrong number of terms for function %s. "</span>
<a name="l02839"></a>02839                   <span class="stringliteral">"Expected %d but given %d"</span>, prevFunc-&gt;getName(), exp, unexp+1);
<a name="l02840"></a>02840       }
<a name="l02841"></a>02841       
<a name="l02842"></a>02842       <span class="keywordtype">int</span> varId = -1;      
<a name="l02843"></a>02843       <span class="keywordflow">if</span> (rightNumTerms)
<a name="l02844"></a>02844       {
<a name="l02845"></a>02845         <span class="comment">// check that the variable is of the right type</span>
<a name="l02846"></a>02846         <span class="keywordtype">int</span> typeId = prevFunc-&gt;getTermTypeAsInt(prevFunc-&gt;getNumTerms());
<a name="l02847"></a>02847         rightType = zzcheckRightTypeAndGetVarId(typeId, newVarName.c_str(),
<a name="l02848"></a>02848                                                     varId);
<a name="l02849"></a>02849       }
<a name="l02850"></a>02850 
<a name="l02851"></a>02851       <span class="keywordflow">if</span> (rightNumTerms &amp;&amp; rightType)
<a name="l02852"></a>02852       {
<a name="l02853"></a>02853         prevFunc-&gt;appendTerm(<span class="keyword">new</span> <a class="code" href="classTerm.html">Term</a>(varId, (<span class="keywordtype">void</span>*)prevFunc, <span class="keyword">false</span>));
<a name="l02854"></a>02854         zzpredFuncListObjs.pop();
<a name="l02855"></a>02855         zzpredFuncListObjs.top()-&gt;append(newVarName.c_str());
<a name="l02856"></a>02856       }
<a name="l02857"></a>02857                   
<a name="l02858"></a>02858       zzfunc = prevFunc;
<a name="l02859"></a>02859     }
<a name="l02860"></a>02860         <span class="keywordflow">else</span> <span class="comment">// function stack is empty, so append to predicate</span>
<a name="l02861"></a>02861     {
<a name="l02862"></a>02862       <span class="comment">// check that we have not exceeded the number of terms</span>
<a name="l02863"></a>02863       <span class="keywordflow">if</span> ((unexp=prevPred-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>()) ==
<a name="l02864"></a>02864           (exp=prevPred-&gt;<a class="code" href="classPredicate.html#60bad8cd9e0c09b26041307c4f9e8e79">getTemplate</a>()-&gt;<a class="code" href="classPredicateTemplate.html#73d8dd50d5eb30f021c7a4e6ea8da31b">getNumTerms</a>()))
<a name="l02865"></a>02865       {
<a name="l02866"></a>02866         rightNumTerms = <span class="keyword">false</span>;
<a name="l02867"></a>02867         zzerr(<span class="stringliteral">"Wrong number of terms for predicate %s. "</span>
<a name="l02868"></a>02868               <span class="stringliteral">"Expected %d but given %d"</span>, prevPred-&gt;<a class="code" href="classPredicate.html#4b4157fdc4aea92f25014ca4d14edb59">getName</a>(), exp, unexp+1);
<a name="l02869"></a>02869       }
<a name="l02870"></a>02870         
<a name="l02871"></a>02871       <span class="keywordtype">int</span> varId = -1;
<a name="l02872"></a>02872       <span class="keywordflow">if</span> (rightNumTerms)
<a name="l02873"></a>02873       {
<a name="l02874"></a>02874         <span class="comment">// check that the variable is of the right type</span>
<a name="l02875"></a>02875         <span class="keywordtype">int</span> typeId = prevPred-&gt;<a class="code" href="classPredicate.html#38b27de49bbbc584fd416be7e5391250">getTermTypeAsInt</a>(prevPred-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>());
<a name="l02876"></a>02876         rightType = zzcheckRightTypeAndGetVarId(typeId, newVarName.c_str(),
<a name="l02877"></a>02877                                                                                     varId);
<a name="l02878"></a>02878       }
<a name="l02879"></a>02879       
<a name="l02880"></a>02880           <span class="keywordflow">if</span> (rightNumTerms &amp;&amp; rightType)
<a name="l02881"></a>02881           {
<a name="l02882"></a>02882                 prevPred-&gt;<a class="code" href="classPredicate.html#18435d6147604eafd6f0ac092e471b3a">appendTerm</a>(<span class="keyword">new</span> <a class="code" href="classTerm.html">Term</a>(varId, (<span class="keywordtype">void</span>*)prevPred, <span class="keyword">true</span>));
<a name="l02883"></a>02883 
<a name="l02884"></a>02884                 <span class="comment">// Pop the function from the stack</span>
<a name="l02885"></a>02885                 zzoldFuncLo = zzpredFuncListObjs.top();
<a name="l02886"></a>02886                 zzpredFuncListObjs.pop();
<a name="l02887"></a>02887                 zzpredFuncListObjs.top()-&gt;append(newVarName.c_str());
<a name="l02888"></a>02888                 zzformulaStr.append(varName);
<a name="l02889"></a>02889       }
<a name="l02890"></a>02890           zzfunc = NULL;
<a name="l02891"></a>02891                 
<a name="l02892"></a>02892     }
<a name="l02893"></a>02893     free(varName);
<a name="l02894"></a>02894         free(predName);
<a name="l02895"></a>02895         <span class="comment">//zzformulaStr.append(")");</span>
<a name="l02896"></a>02896 
<a name="l02897"></a>02897     <span class="keyword">delete</span> zzpred;
<a name="l02898"></a>02898         zzpred = prevPred;
<a name="l02899"></a>02899   ;}
<a name="l02900"></a>02900     <span class="keywordflow">break</span>;
<a name="l02901"></a>02901 
<a name="l02902"></a>02902   <span class="keywordflow">case</span> 136:
<a name="l02903"></a>02903 <span class="preprocessor">#line 1845 "../src/parser/fol.y"</span>
<a name="l02904"></a>02904 <span class="preprocessor"></span>    {
<a name="l02905"></a>02905     <span class="keyword">const</span> <span class="keywordtype">char</span>* constName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l02906"></a>02906     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"c2_%s "</span>, constName); 
<a name="l02907"></a>02907     zztermIsConstant(constName);
<a name="l02908"></a>02908     <span class="keywordflow">if</span> (zzfunc) zzfdfuncConstants.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(string(constName));
<a name="l02909"></a>02909     <span class="keywordflow">else</span>        zzfdconstName = constName;
<a name="l02910"></a>02910     <span class="keyword">delete</span> [] constName;
<a name="l02911"></a>02911   ;}
<a name="l02912"></a>02912     <span class="keywordflow">break</span>;
<a name="l02913"></a>02913 
<a name="l02914"></a>02914   <span class="keywordflow">case</span> 137:
<a name="l02915"></a>02915 <span class="preprocessor">#line 1855 "../src/parser/fol.y"</span>
<a name="l02916"></a>02916 <span class="preprocessor"></span>    {
<a name="l02917"></a>02917     <span class="keyword">const</span> <span class="keywordtype">char</span>* constName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l02918"></a>02918     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"c2_%s "</span>, constName); 
<a name="l02919"></a>02919       <span class="keywordflow">if</span> (zzconstantMustBeDeclared)
<a name="l02920"></a>02920         zzerr(<span class="stringliteral">"Constant %s must be declared before it is used"</span>, constName);
<a name="l02921"></a>02921     zztermIsConstant(constName);
<a name="l02922"></a>02922     <span class="keywordflow">if</span> (zzfunc) zzfdfuncConstants.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(string(constName));
<a name="l02923"></a>02923     <span class="keywordflow">else</span>        zzfdconstName = constName;
<a name="l02924"></a>02924     <span class="keyword">delete</span> [] constName;
<a name="l02925"></a>02925   ;}
<a name="l02926"></a>02926     <span class="keywordflow">break</span>;
<a name="l02927"></a>02927 
<a name="l02928"></a>02928   <span class="keywordflow">case</span> 138:
<a name="l02929"></a>02929 <span class="preprocessor">#line 1867 "../src/parser/fol.y"</span>
<a name="l02930"></a>02930 <span class="preprocessor"></span>    {
<a name="l02931"></a>02931     <span class="keyword">const</span> <span class="keywordtype">char</span>* intStr = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l02932"></a>02932     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"c3_%s "</span>, intStr);
<a name="l02933"></a>02933 
<a name="l02934"></a>02934     <span class="keywordtype">char</span> constName[100];
<a name="l02935"></a>02935     zzcreateAndCheckIntConstant(intStr, zzfunc, zzpred, zzdomain, constName);
<a name="l02936"></a>02936     <span class="keywordflow">if</span> (constName == NULL) { <span class="keywordflow">break</span>; <span class="keyword">delete</span> [] intStr; }
<a name="l02937"></a>02937 
<a name="l02938"></a>02938     zztermIsConstant(constName);
<a name="l02939"></a>02939     <span class="keywordflow">if</span> (zzfunc) zzfdfuncConstants.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(string(constName));
<a name="l02940"></a>02940     <span class="keywordflow">else</span>        zzfdconstName = constName;
<a name="l02941"></a>02941     <span class="keyword">delete</span> [] intStr;
<a name="l02942"></a>02942   ;}
<a name="l02943"></a>02943     <span class="keywordflow">break</span>;
<a name="l02944"></a>02944 
<a name="l02945"></a>02945   <span class="keywordflow">case</span> 139:
<a name="l02946"></a>02946 <span class="preprocessor">#line 1882 "../src/parser/fol.y"</span>
<a name="l02947"></a>02947 <span class="preprocessor"></span>    {
<a name="l02948"></a>02948     zztermIsVariable(folDbg);
<a name="l02949"></a>02949     <span class="keywordflow">if</span> (zzisPlus) zzisPlus = <span class="keyword">false</span>;
<a name="l02950"></a>02950   ;}
<a name="l02951"></a>02951     <span class="keywordflow">break</span>;
<a name="l02952"></a>02952 
<a name="l02953"></a>02953   <span class="keywordflow">case</span> 140:
<a name="l02954"></a>02954 <span class="preprocessor">#line 1888 "../src/parser/fol.y"</span>
<a name="l02955"></a>02955 <span class="preprocessor"></span>    {
<a name="l02956"></a>02956     zztermIsVariable(folDbg);
<a name="l02957"></a>02957 
<a name="l02958"></a>02958     zzconsumeToken(zztokenList, <span class="stringliteral">"!"</span>);
<a name="l02959"></a>02959     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"! "</span>); 
<a name="l02960"></a>02960     <span class="keywordflow">if</span> (zzisPlus) { zzisPlus = <span class="keyword">false</span>; zzerr(<span class="stringliteral">"'+' cannot be used with '!'"</span>); }
<a name="l02961"></a>02961     <span class="keywordflow">if</span> (zzfunc) zzerr(<span class="stringliteral">"'+' cannot be used in a function"</span>);
<a name="l02962"></a>02962     <span class="keywordflow">if</span> (zzpred)
<a name="l02963"></a>02963     {
<a name="l02964"></a>02964       <span class="keywordflow">if</span> (!zzpred-&gt;<a class="code" href="classPredicate.html#f248210839bae63c2aba17c99f09ba6a">getSense</a>())
<a name="l02965"></a>02965         zzerr(<span class="stringliteral">"'!' cannot be used on a variable of a negated predicate."</span>);
<a name="l02966"></a>02966       <span class="keywordtype">int</span> termIdx = zzpred-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>()-1;
<a name="l02967"></a>02967       <span class="keywordflow">if</span> (zzpred-&gt;<a class="code" href="classPredicate.html#064cafc2e853fb1a77ceed8c02ed8c12">getTerm</a>(termIdx)-&gt;<a class="code" href="classTerm.html#f75a935cc37faf88ecfda77ba21aee85">isConstant</a>())
<a name="l02968"></a>02968         zzerr(<span class="stringliteral">"'!' cannot be used with a constant term."</span>);
<a name="l02969"></a>02969       zzuniqueVarIndexes.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(termIdx);
<a name="l02970"></a>02970     }
<a name="l02971"></a>02971     <span class="keywordflow">else</span>
<a name="l02972"></a>02972     { zzexit(<span class="stringliteral">"zzpred is NULL in 'not' grammar rule"</span>); }
<a name="l02973"></a>02973 
<a name="l02974"></a>02974     zzformulaStr.append(<span class="stringliteral">"!"</span>);    
<a name="l02975"></a>02975   ;}
<a name="l02976"></a>02976     <span class="keywordflow">break</span>;
<a name="l02977"></a>02977 
<a name="l02978"></a>02978   <span class="keywordflow">case</span> 142:
<a name="l02979"></a>02979 <span class="preprocessor">#line 1914 "../src/parser/fol.y"</span>
<a name="l02980"></a>02980 <span class="preprocessor"></span>    { 
<a name="l02981"></a>02981     zzconsumeToken(zztokenList, <span class="stringliteral">"+"</span>);
<a name="l02982"></a>02982     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"+ "</span>); 
<a name="l02983"></a>02983     zzassert(!zzisPlus,<span class="stringliteral">"expecting !zzisPlus"</span>);
<a name="l02984"></a>02984     zzisPlus = <span class="keyword">true</span>;
<a name="l02985"></a>02985     zzformulaStr.append(<span class="stringliteral">"+"</span>);
<a name="l02986"></a>02986   ;}
<a name="l02987"></a>02987     <span class="keywordflow">break</span>;
<a name="l02988"></a>02988 
<a name="l02989"></a>02989   <span class="keywordflow">case</span> 143:
<a name="l02990"></a>02990 <span class="preprocessor">#line 1925 "../src/parser/fol.y"</span>
<a name="l02991"></a>02991 <span class="preprocessor"></span>    {
<a name="l02992"></a>02992     <span class="keyword">const</span> <span class="keywordtype">char</span>* funcName = zztokenList.<a class="code" href="classStrFifoList.html#3d24c9c8dc73e2964ae2ff669b0e0083">removeLast</a>();
<a name="l02993"></a>02993     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"f_%s "</span>, funcName);
<a name="l02994"></a>02994     <span class="keywordflow">if</span> (zzfunc != NULL) { zzfuncStack.push(zzfunc); zzfunc = NULL; }
<a name="l02995"></a>02995     ++zzfdnumFuncs;
<a name="l02996"></a>02996     zzfdfuncName = funcName;
<a name="l02997"></a>02997 
<a name="l02998"></a>02998     ListObj* funclo = <span class="keyword">new</span> ListObj;
<a name="l02999"></a>02999 
<a name="l03000"></a>03000           <span class="comment">// Check if internal function</span>
<a name="l03001"></a>03001         <span class="keywordflow">if</span> (<a class="code" href="classFunctionTemplate.html#c1fb1d9722a09d64e4e4710f3793c780">FunctionTemplate::isInternalFunctionTemplateName</a>(funcName))
<a name="l03002"></a>03002         {
<a name="l03003"></a>03003           zzinfixFuncName = (<span class="keywordtype">char</span> *)malloc((strlen(funcName)
<a name="l03004"></a>03004                                                                         + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l03005"></a>03005           strcpy(zzinfixFuncName, funcName);
<a name="l03006"></a>03006           <span class="keyword">const</span> <a class="code" href="classFunctionTemplate.html">FunctionTemplate</a>* t;
<a name="l03007"></a>03007           <span class="keywordflow">if</span> (<a class="code" href="classFunctionTemplate.html#9038e41760a7b4b333854f076c50cbaa">FunctionTemplate::isInternalFunctionUnaryTemplateName</a>(funcName))
<a name="l03008"></a>03008                 t = zzdomain-&gt;<a class="code" href="classDomain.html#daa14ea00bced12dad9b4799ab79581b">getEmptyFunctionUnaryTemplate</a>();
<a name="l03009"></a>03009           <span class="keywordflow">else</span>
<a name="l03010"></a>03010                 t = zzdomain-&gt;<a class="code" href="classDomain.html#64d5ad6a501e79540cf4b77ca574afe2">getEmptyFunctionBinaryTemplate</a>();
<a name="l03011"></a>03011       zzassert(zzfunc == NULL,<span class="stringliteral">"expecting zzfunc==NULL"</span>);
<a name="l03012"></a>03012       zzfunc = <span class="keyword">new</span> <a class="code" href="classFunction.html">Function</a>(t);
<a name="l03013"></a>03013       funclo-&gt;<a class="code" href="classListObj.html#0419cac49e66f9dc6d87b0166a23a7ba">append</a>(<a class="code" href="classFunctionTemplate.html#4a7cf5c6d39f0f09af372aef30d21b8f">FunctionTemplate::EMPTY_FTEMPLATE_NAME</a>);
<a name="l03014"></a>03014         }
<a name="l03015"></a>03015         <span class="keywordflow">else</span>
<a name="l03016"></a>03016         {
<a name="l03017"></a>03017           zzcreateFunc(zzfunc, funcName); 
<a name="l03018"></a>03018           funclo-&gt;<a class="code" href="classListObj.html#0419cac49e66f9dc6d87b0166a23a7ba">append</a>(funcName);
<a name="l03019"></a>03019         }
<a name="l03020"></a>03020         
<a name="l03021"></a>03021     zzpredFuncListObjs.push(funclo);
<a name="l03022"></a>03022     <span class="comment">//zzformulaStr.append(funcName);</span>
<a name="l03023"></a>03023 
<a name="l03024"></a>03024     <span class="keyword">delete</span> [] funcName;
<a name="l03025"></a>03025   ;}
<a name="l03026"></a>03026     <span class="keywordflow">break</span>;
<a name="l03027"></a>03027 
<a name="l03028"></a>03028   <span class="keywordflow">case</span> 144:
<a name="l03029"></a>03029 <span class="preprocessor">#line 1961 "../src/parser/fol.y"</span>
<a name="l03030"></a>03030 <span class="preprocessor"></span>    {
<a name="l03031"></a>03031     zzconsumeToken(zztokenList, <span class="stringliteral">"("</span>);
<a name="l03032"></a>03032     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"( "</span>); 
<a name="l03033"></a>03033     <span class="keywordflow">if</span> (folDbg &gt;= 2) printf(<span class="stringliteral">"term: terms\n"</span>);
<a name="l03034"></a>03034   ;}
<a name="l03035"></a>03035     <span class="keywordflow">break</span>;
<a name="l03036"></a>03036 
<a name="l03037"></a>03037   <span class="keywordflow">case</span> 145:
<a name="l03038"></a>03038 <span class="preprocessor">#line 1967 "../src/parser/fol.y"</span>
<a name="l03039"></a>03039 <span class="preprocessor"></span>    {
<a name="l03040"></a>03040           <span class="comment">//If an internal func., then need to determine type</span>
<a name="l03041"></a>03041         <span class="keywordflow">if</span> (zzinfixFuncName)
<a name="l03042"></a>03042         {
<a name="l03043"></a>03043           ListObj* funclo = zzpredFuncListObjs.top();
<a name="l03044"></a>03044       funclo-&gt;<a class="code" href="classListObj.html#c38530b0c3c331d3147040726987ec7e">replace</a>(<a class="code" href="classFunctionTemplate.html#4a7cf5c6d39f0f09af372aef30d21b8f">FunctionTemplate::EMPTY_FTEMPLATE_NAME</a>, zzinfixFuncName);
<a name="l03045"></a>03045           <span class="keyword">const</span> <a class="code" href="classFunctionTemplate.html">FunctionTemplate</a>* t = zzgetGenericInternalFunctionTemplate(zzinfixFuncName);
<a name="l03046"></a>03046                 <span class="comment">// If in a pred. (not LHS of infix pred.), then we know the return type</span>
<a name="l03047"></a>03047           <span class="keywordflow">if</span> (zzpred)
<a name="l03048"></a>03048           {
<a name="l03049"></a>03049                 ((<a class="code" href="classFunctionTemplate.html">FunctionTemplate</a>*)t)-&gt;setRetTypeId(
<a name="l03050"></a>03050                         zzpred-&gt;<a class="code" href="classPredicate.html#38b27de49bbbc584fd416be7e5391250">getTermTypeAsInt</a>(zzpred-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>()), zzdomain);
<a name="l03051"></a>03051           }
<a name="l03052"></a>03052           zzfunc-&gt;<a class="code" href="classFunction.html#e94ed93f2dccc3a7c33f46911c37630a">setTemplate</a>((<a class="code" href="classFunctionTemplate.html">FunctionTemplate</a>*)t);
<a name="l03053"></a>03053 
<a name="l03054"></a>03054                 <span class="comment">// types are possibly unknown</span>
<a name="l03055"></a>03055           <span class="keywordtype">bool</span> unknownTypes = <span class="keyword">false</span>;
<a name="l03056"></a>03056                 
<a name="l03057"></a>03057                 <span class="comment">// First element is return type</span>
<a name="l03058"></a>03058           <a class="code" href="classArray.html">Array&lt;int&gt;</a> typeIds(zzfunc-&gt;<a class="code" href="classFunction.html#26a1c0122abee1da8fee665d6fb605b8">getNumTerms</a>() + 1);
<a name="l03059"></a>03059           typeIds.append(zzfunc-&gt;<a class="code" href="classFunction.html#dbcf54b241f98d3b1fd4c5001cb62e80">getRetTypeId</a>());
<a name="l03060"></a>03060           <span class="keywordflow">if</span> (typeIds[0] &lt;= 0) unknownTypes = <span class="keyword">true</span>;
<a name="l03061"></a>03061                 
<a name="l03062"></a>03062                 <span class="comment">// Then term types</span>
<a name="l03063"></a>03063           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= zzfunc-&gt;<a class="code" href="classFunction.html#26a1c0122abee1da8fee665d6fb605b8">getNumTerms</a>(); i++)
<a name="l03064"></a>03064           {
<a name="l03065"></a>03065                 typeIds.append(zzgetTypeId(zzfunc-&gt;<a class="code" href="classFunction.html#f958b9afddea5b67355930cb6b7a11f0">getTerm</a>(i-1), (*funclo)[i]-&gt;getStr()));
<a name="l03066"></a>03066                 <span class="keywordflow">if</span> (typeIds[i] &lt;= 0) unknownTypes = <span class="keyword">true</span>;
<a name="l03067"></a>03067           }
<a name="l03068"></a>03068 
<a name="l03069"></a>03069                 <span class="comment">// If all types are known</span>
<a name="l03070"></a>03070           <span class="keywordflow">if</span> (!unknownTypes)
<a name="l03071"></a>03071           {
<a name="l03072"></a>03072                 zzsetInternalFuncTypeName(zzinfixFuncName, typeIds);
<a name="l03073"></a>03073           }
<a name="l03074"></a>03074       <span class="keywordflow">else</span> <span class="comment">// Not all types are known, delay processing</span>
<a name="l03075"></a>03075       {
<a name="l03076"></a>03076         <a class="code" href="classArray.html">Array&lt;string&gt;</a> varNames(typeIds.size());
<a name="l03077"></a>03077         
<a name="l03078"></a>03078         <span class="keywordtype">char</span>* varName;
<a name="l03079"></a>03079         <span class="keywordtype">char</span> funcVarCounterString[10];
<a name="l03080"></a>03080         <span class="keywordtype">int</span> funcVarCounterLength =
<a name="l03081"></a>03081                 sprintf(funcVarCounterString, <span class="stringliteral">"%d"</span>, zzfuncVarCounter);
<a name="l03082"></a>03082         varName = (<span class="keywordtype">char</span> *)malloc((strlen(ZZ_FUNCVAR_PREFIX) +
<a name="l03083"></a>03083                                                                   funcVarCounterLength + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l03084"></a>03084                 strcpy(varName, ZZ_FUNCVAR_PREFIX);
<a name="l03085"></a>03085                 strcat(varName, funcVarCounterString);
<a name="l03086"></a>03086             string newVarName = zzgetNewVarName(varName);
<a name="l03087"></a>03087         
<a name="l03088"></a>03088         varNames.append(newVarName);
<a name="l03089"></a>03089         
<a name="l03090"></a>03090         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; typeIds.size(); i++)
<a name="l03091"></a>03091           varNames[i] = (*funclo)[i]-&gt;getStr();
<a name="l03092"></a>03092 
<a name="l03093"></a>03093                 <span class="comment">// Predicate name is PredicateTemplate::ZZ_RETURN_PREFIX + function name</span>
<a name="l03094"></a>03094                 <span class="keywordtype">char</span>* predName;
<a name="l03095"></a>03095                 predName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#62e623b43316dadb940ca05273ecb19d">PredicateTemplate::ZZ_RETURN_PREFIX</a>) +
<a name="l03096"></a>03096                                                    strlen(zzfunc-&gt;<a class="code" href="classFunction.html#22517da6cd8a0d6055955e684261f13c">getName</a>()) + 1)*<span class="keyword">sizeof</span>(char));
<a name="l03097"></a>03097                 strcpy(predName, <a class="code" href="classPredicateTemplate.html#62e623b43316dadb940ca05273ecb19d">PredicateTemplate::ZZ_RETURN_PREFIX</a>);
<a name="l03098"></a>03098                 strcat(predName, zzinfixFuncName);
<a name="l03099"></a>03099         
<a name="l03100"></a>03100         string unknownIntFuncName =
<a name="l03101"></a>03101                   zzappendWithUnderscore(predName, zzintFuncTypeCounter++);
<a name="l03102"></a>03102         zzintFuncList.push_back(<a class="code" href="structZZUnknownIntFuncInfo.html">ZZUnknownIntFuncInfo</a>(unknownIntFuncName, varNames));
<a name="l03103"></a>03103         <span class="comment">//funclo-&gt;replace(zzinfixFuncName, unknownIntFuncName.c_str());</span>
<a name="l03104"></a>03104                 free(predName);
<a name="l03105"></a>03105                 free(varName);
<a name="l03106"></a>03106       }
<a name="l03107"></a>03107           free(zzinfixFuncName);
<a name="l03108"></a>03108       zzinfixFuncName = NULL;
<a name="l03109"></a>03109         }
<a name="l03110"></a>03110         
<a name="l03111"></a>03111     zzconsumeToken(zztokenList, <span class="stringliteral">")"</span>);
<a name="l03112"></a>03112     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">") "</span>);
<a name="l03113"></a>03113   ;}
<a name="l03114"></a>03114     <span class="keywordflow">break</span>;
<a name="l03115"></a>03115 
<a name="l03116"></a>03116   <span class="keywordflow">case</span> 146:
<a name="l03117"></a>03117 <span class="preprocessor">#line 2043 "../src/parser/fol.y"</span>
<a name="l03118"></a>03118 <span class="preprocessor"></span>    {
<a name="l03119"></a>03119     <span class="comment">// Make an "empty" function</span>
<a name="l03120"></a>03120     <span class="keyword">const</span> <span class="keywordtype">char</span>* funcName = <a class="code" href="classFunctionTemplate.html#4a7cf5c6d39f0f09af372aef30d21b8f">FunctionTemplate::EMPTY_FTEMPLATE_NAME</a>;
<a name="l03121"></a>03121     <span class="keywordflow">if</span> (zzfunc != NULL) { zzfuncStack.push(zzfunc); zzfunc = NULL; }
<a name="l03122"></a>03122     ++zzfdnumFuncs;
<a name="l03123"></a>03123     zzfdfuncName = funcName;
<a name="l03124"></a>03124     <span class="comment">//zzcreateFunc(zzfunc, funcName);</span>
<a name="l03125"></a>03125         <span class="keyword">const</span> <a class="code" href="classFunctionTemplate.html">FunctionTemplate</a>* t = zzdomain-&gt;<a class="code" href="classDomain.html#64d5ad6a501e79540cf4b77ca574afe2">getEmptyFunctionBinaryTemplate</a>();
<a name="l03126"></a>03126         zzassert(zzfunc == NULL, <span class="stringliteral">"expect zzfunc == NULL"</span>);
<a name="l03127"></a>03127         zzfunc = <span class="keyword">new</span> <a class="code" href="classFunction.html">Function</a>(t);
<a name="l03128"></a>03128 
<a name="l03129"></a>03129     ListObj* funclo = <span class="keyword">new</span> ListObj;
<a name="l03130"></a>03130     funclo-&gt;<a class="code" href="classListObj.html#0419cac49e66f9dc6d87b0166a23a7ba">append</a>(funcName);
<a name="l03131"></a>03131     zzpredFuncListObjs.push(funclo);
<a name="l03132"></a>03132   ;}
<a name="l03133"></a>03133     <span class="keywordflow">break</span>;
<a name="l03134"></a>03134 
<a name="l03135"></a>03135   <span class="keywordflow">case</span> 147:
<a name="l03136"></a>03136 <span class="preprocessor">#line 2059 "../src/parser/fol.y"</span>
<a name="l03137"></a>03137 <span class="preprocessor"></span>    {
<a name="l03138"></a>03138     zzconsumeToken(zztokenList, <span class="stringliteral">"("</span>);
<a name="l03139"></a>03139     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"( "</span>);
<a name="l03140"></a>03140   ;}
<a name="l03141"></a>03141     <span class="keywordflow">break</span>;
<a name="l03142"></a>03142 
<a name="l03143"></a>03143   <span class="keywordflow">case</span> 148:
<a name="l03144"></a>03144 <span class="preprocessor">#line 2064 "../src/parser/fol.y"</span>
<a name="l03145"></a>03145 <span class="preprocessor"></span>    {
<a name="l03146"></a>03146     <span class="comment">//Replace empty function with function sign just parsed</span>
<a name="l03147"></a>03147     <span class="comment">//zzcreateInternalFuncTemplate(zzinfixFuncName);</span>
<a name="l03148"></a>03148     <span class="comment">//const FunctionTemplate* t = zzdomain-&gt;getFunctionTemplate(zzinfixFuncName);</span>
<a name="l03149"></a>03149         <span class="comment">//zzfunc-&gt;setTemplate((FunctionTemplate*)t);</span>
<a name="l03150"></a>03150     
<a name="l03151"></a>03151     <span class="comment">//ListObj* funclo = zzpredFuncListObjs.top();</span>
<a name="l03152"></a>03152     <span class="comment">//funclo-&gt;replace(FunctionTemplate::EMPTY_FTEMPLATE_NAME, zzinfixFuncName);</span>
<a name="l03153"></a>03153     
<a name="l03154"></a>03154     <span class="comment">//delete [] zzinfixFuncName;</span>
<a name="l03155"></a>03155   ;}
<a name="l03156"></a>03156     <span class="keywordflow">break</span>;
<a name="l03157"></a>03157 
<a name="l03158"></a>03158   <span class="keywordflow">case</span> 149:
<a name="l03159"></a>03159 <span class="preprocessor">#line 2076 "../src/parser/fol.y"</span>
<a name="l03160"></a>03160 <span class="preprocessor"></span>    {
<a name="l03161"></a>03161         ListObj* funclo = zzpredFuncListObjs.top();
<a name="l03162"></a>03162     funclo-&gt;<a class="code" href="classListObj.html#c38530b0c3c331d3147040726987ec7e">replace</a>(<a class="code" href="classFunctionTemplate.html#4a7cf5c6d39f0f09af372aef30d21b8f">FunctionTemplate::EMPTY_FTEMPLATE_NAME</a>, zzinfixFuncName);
<a name="l03163"></a>03163     <span class="keyword">const</span> <a class="code" href="classFunctionTemplate.html">FunctionTemplate</a>* t = zzgetGenericInternalFunctionTemplate(zzinfixFuncName);
<a name="l03164"></a>03164           <span class="comment">// If in a pred. (not LHS of infix pred.), then we know the return type</span>
<a name="l03165"></a>03165         <span class="keywordflow">if</span> (zzpred)
<a name="l03166"></a>03166           ((<a class="code" href="classFunctionTemplate.html">FunctionTemplate</a>*)t)-&gt;setRetTypeId(
<a name="l03167"></a>03167                 zzpred-&gt;<a class="code" href="classPredicate.html#38b27de49bbbc584fd416be7e5391250">getTermTypeAsInt</a>(zzpred-&gt;<a class="code" href="classPredicate.html#3606c1168d32d59ae76853ea65f9587a">getNumTerms</a>()), zzdomain);
<a name="l03168"></a>03168         zzfunc-&gt;<a class="code" href="classFunction.html#e94ed93f2dccc3a7c33f46911c37630a">setTemplate</a>((<a class="code" href="classFunctionTemplate.html">FunctionTemplate</a>*)t);
<a name="l03169"></a>03169 
<a name="l03170"></a>03170           <span class="comment">// types are possibly unknown</span>
<a name="l03171"></a>03171         <span class="keywordtype">bool</span> unknownTypes = <span class="keyword">false</span>;
<a name="l03172"></a>03172                 
<a name="l03173"></a>03173           <span class="comment">// First element is return type</span>
<a name="l03174"></a>03174         <a class="code" href="classArray.html">Array&lt;int&gt;</a> typeIds(zzfunc-&gt;<a class="code" href="classFunction.html#26a1c0122abee1da8fee665d6fb605b8">getNumTerms</a>() + 1);
<a name="l03175"></a>03175         typeIds.append(zzfunc-&gt;<a class="code" href="classFunction.html#dbcf54b241f98d3b1fd4c5001cb62e80">getRetTypeId</a>());
<a name="l03176"></a>03176         <span class="keywordflow">if</span> (typeIds[0] &lt;= 0) unknownTypes = <span class="keyword">true</span>;
<a name="l03177"></a>03177                 
<a name="l03178"></a>03178           <span class="comment">// Then term types</span>
<a name="l03179"></a>03179         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= zzfunc-&gt;<a class="code" href="classFunction.html#26a1c0122abee1da8fee665d6fb605b8">getNumTerms</a>(); i++)
<a name="l03180"></a>03180         {
<a name="l03181"></a>03181           typeIds.append(zzgetTypeId(zzfunc-&gt;<a class="code" href="classFunction.html#f958b9afddea5b67355930cb6b7a11f0">getTerm</a>(i-1), (*funclo)[i]-&gt;getStr()));
<a name="l03182"></a>03182           <span class="keywordflow">if</span> (typeIds[i] &lt;= 0) unknownTypes = <span class="keyword">true</span>;
<a name="l03183"></a>03183         }
<a name="l03184"></a>03184 
<a name="l03185"></a>03185           <span class="comment">// If all types are known</span>
<a name="l03186"></a>03186         <span class="keywordflow">if</span> (!unknownTypes)
<a name="l03187"></a>03187         {
<a name="l03188"></a>03188           zzsetInternalFuncTypeName(zzinfixFuncName, typeIds);
<a name="l03189"></a>03189         }
<a name="l03190"></a>03190     <span class="keywordflow">else</span> <span class="comment">// Not all types are known, delay processing</span>
<a name="l03191"></a>03191     {
<a name="l03192"></a>03192       <a class="code" href="classArray.html">Array&lt;string&gt;</a> varNames(typeIds.size());
<a name="l03193"></a>03193         
<a name="l03194"></a>03194       <span class="keywordtype">char</span>* varName;
<a name="l03195"></a>03195       <span class="keywordtype">char</span> funcVarCounterString[10];
<a name="l03196"></a>03196       <span class="keywordtype">int</span> funcVarCounterLength =
<a name="l03197"></a>03197                 sprintf(funcVarCounterString, <span class="stringliteral">"%d"</span>, zzfuncVarCounter);
<a name="l03198"></a>03198       varName = (<span class="keywordtype">char</span> *)malloc((strlen(ZZ_FUNCVAR_PREFIX) +
<a name="l03199"></a>03199                                                                 funcVarCounterLength + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l03200"></a>03200           strcpy(varName, ZZ_FUNCVAR_PREFIX);
<a name="l03201"></a>03201           strcat(varName, funcVarCounterString);
<a name="l03202"></a>03202           string newVarName = zzgetNewVarName(varName);
<a name="l03203"></a>03203         
<a name="l03204"></a>03204       varNames.append(newVarName);
<a name="l03205"></a>03205         
<a name="l03206"></a>03206       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; typeIds.size(); i++)
<a name="l03207"></a>03207         varNames[i] = (*funclo)[i]-&gt;getStr();
<a name="l03208"></a>03208                 <span class="comment">// Predicate name is PredicateTemplate::ZZ_RETURN_PREFIX + function name</span>
<a name="l03209"></a>03209           <span class="keywordtype">char</span>* predName;
<a name="l03210"></a>03210           predName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#62e623b43316dadb940ca05273ecb19d">PredicateTemplate::ZZ_RETURN_PREFIX</a>) +
<a name="l03211"></a>03211                                                      strlen(zzfunc-&gt;<a class="code" href="classFunction.html#22517da6cd8a0d6055955e684261f13c">getName</a>()) + 1)*<span class="keyword">sizeof</span>(char));
<a name="l03212"></a>03212           strcpy(predName, <a class="code" href="classPredicateTemplate.html#62e623b43316dadb940ca05273ecb19d">PredicateTemplate::ZZ_RETURN_PREFIX</a>);
<a name="l03213"></a>03213           strcat(predName, zzinfixFuncName);
<a name="l03214"></a>03214         
<a name="l03215"></a>03215       string unknownIntFuncName =
<a name="l03216"></a>03216           zzappendWithUnderscore(predName, zzintFuncTypeCounter++);
<a name="l03217"></a>03217       zzintFuncList.push_back(<a class="code" href="structZZUnknownIntFuncInfo.html">ZZUnknownIntFuncInfo</a>(unknownIntFuncName, varNames));
<a name="l03218"></a>03218         <span class="comment">//funclo-&gt;replace(zzinfixFuncName, unknownIntFuncName.c_str());</span>
<a name="l03219"></a>03219           free(predName);
<a name="l03220"></a>03220           free(varName);
<a name="l03221"></a>03221     }
<a name="l03222"></a>03222         free(zzinfixFuncName);
<a name="l03223"></a>03223     zzinfixFuncName = NULL;
<a name="l03224"></a>03224 
<a name="l03225"></a>03225     zzconsumeToken(zztokenList, <span class="stringliteral">")"</span>);
<a name="l03226"></a>03226     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">") "</span>);
<a name="l03227"></a>03227   ;}
<a name="l03228"></a>03228     <span class="keywordflow">break</span>;
<a name="l03229"></a>03229 
<a name="l03230"></a>03230   <span class="keywordflow">case</span> 150:
<a name="l03231"></a>03231 <span class="preprocessor">#line 2149 "../src/parser/fol.y"</span>
<a name="l03232"></a>03232 <span class="preprocessor"></span>    {
<a name="l03233"></a>03233         zzconsumeToken(zztokenList, <span class="stringliteral">"+"</span>);
<a name="l03234"></a>03234     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"+ "</span>); 
<a name="l03235"></a>03235     zzinfixFuncName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#34999006780a853d62e63460d1adbc8f">PredicateTemplate::PLUS_NAME</a>)
<a name="l03236"></a>03236                                                                   + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l03237"></a>03237         strcpy(zzinfixFuncName, <a class="code" href="classPredicateTemplate.html#34999006780a853d62e63460d1adbc8f">PredicateTemplate::PLUS_NAME</a>);
<a name="l03238"></a>03238   ;}
<a name="l03239"></a>03239     <span class="keywordflow">break</span>;
<a name="l03240"></a>03240 
<a name="l03241"></a>03241   <span class="keywordflow">case</span> 151:
<a name="l03242"></a>03242 <span class="preprocessor">#line 2158 "../src/parser/fol.y"</span>
<a name="l03243"></a>03243 <span class="preprocessor"></span>    {
<a name="l03244"></a>03244         zzconsumeToken(zztokenList, <span class="stringliteral">"-"</span>);
<a name="l03245"></a>03245     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"- "</span>); 
<a name="l03246"></a>03246     zzinfixFuncName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#c2e3bd818b78e3eb18fe636186355b56">PredicateTemplate::MINUS_NAME</a>)
<a name="l03247"></a>03247                                                                   + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l03248"></a>03248         strcpy(zzinfixFuncName, <a class="code" href="classPredicateTemplate.html#c2e3bd818b78e3eb18fe636186355b56">PredicateTemplate::MINUS_NAME</a>);
<a name="l03249"></a>03249   ;}
<a name="l03250"></a>03250     <span class="keywordflow">break</span>;
<a name="l03251"></a>03251 
<a name="l03252"></a>03252   <span class="keywordflow">case</span> 152:
<a name="l03253"></a>03253 <span class="preprocessor">#line 2167 "../src/parser/fol.y"</span>
<a name="l03254"></a>03254 <span class="preprocessor"></span>    {
<a name="l03255"></a>03255         zzconsumeToken(zztokenList, <span class="stringliteral">"*"</span>);
<a name="l03256"></a>03256     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"* "</span>);
<a name="l03257"></a>03257     zzinfixFuncName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#98a00542beb7c650751efa3cd4c3df12">PredicateTemplate::TIMES_NAME</a>)
<a name="l03258"></a>03258                                                                   + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l03259"></a>03259         strcpy(zzinfixFuncName, <a class="code" href="classPredicateTemplate.html#98a00542beb7c650751efa3cd4c3df12">PredicateTemplate::TIMES_NAME</a>);
<a name="l03260"></a>03260   ;}
<a name="l03261"></a>03261     <span class="keywordflow">break</span>;
<a name="l03262"></a>03262 
<a name="l03263"></a>03263   <span class="keywordflow">case</span> 153:
<a name="l03264"></a>03264 <span class="preprocessor">#line 2176 "../src/parser/fol.y"</span>
<a name="l03265"></a>03265 <span class="preprocessor"></span>    {
<a name="l03266"></a>03266         zzconsumeToken(zztokenList, <span class="stringliteral">"/"</span>);
<a name="l03267"></a>03267     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"/ "</span>);
<a name="l03268"></a>03268     zzinfixFuncName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#cf3a4e49f84fd43efcbec6b32326db1a">PredicateTemplate::DIVIDEDBY_NAME</a>)
<a name="l03269"></a>03269                                                                   + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l03270"></a>03270         strcpy(zzinfixFuncName, <a class="code" href="classPredicateTemplate.html#cf3a4e49f84fd43efcbec6b32326db1a">PredicateTemplate::DIVIDEDBY_NAME</a>);
<a name="l03271"></a>03271   ;}
<a name="l03272"></a>03272     <span class="keywordflow">break</span>;
<a name="l03273"></a>03273 
<a name="l03274"></a>03274   <span class="keywordflow">case</span> 154:
<a name="l03275"></a>03275 <span class="preprocessor">#line 2185 "../src/parser/fol.y"</span>
<a name="l03276"></a>03276 <span class="preprocessor"></span>    {
<a name="l03277"></a>03277         zzconsumeToken(zztokenList, <span class="stringliteral">"%"</span>);
<a name="l03278"></a>03278     <span class="keywordflow">if</span> (folDbg &gt;= 1) printf(<span class="stringliteral">"%% "</span>);
<a name="l03279"></a>03279     zzinfixFuncName = (<span class="keywordtype">char</span> *)malloc((strlen(<a class="code" href="classPredicateTemplate.html#7af7a32a520ab308ff0134d735aaffc7">PredicateTemplate::MOD_NAME</a>)
<a name="l03280"></a>03280                                                                   + 1)*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l03281"></a>03281         strcpy(zzinfixFuncName, <a class="code" href="classPredicateTemplate.html#7af7a32a520ab308ff0134d735aaffc7">PredicateTemplate::MOD_NAME</a>);
<a name="l03282"></a>03282   ;}
<a name="l03283"></a>03283     <span class="keywordflow">break</span>;
<a name="l03284"></a>03284 
<a name="l03285"></a>03285 
<a name="l03286"></a>03286       <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l03287"></a>03287     }
<a name="l03288"></a>03288 
<a name="l03289"></a>03289   <span class="keywordflow">return</span> yyok;
<a name="l03290"></a>03290 <span class="preprocessor"># undef yyerrok</span>
<a name="l03291"></a>03291 <span class="preprocessor"></span><span class="preprocessor"># undef YYABORT</span>
<a name="l03292"></a>03292 <span class="preprocessor"></span><span class="preprocessor"># undef YYACCEPT</span>
<a name="l03293"></a>03293 <span class="preprocessor"></span><span class="preprocessor"># undef YYERROR</span>
<a name="l03294"></a>03294 <span class="preprocessor"></span><span class="preprocessor"># undef YYBACKUP</span>
<a name="l03295"></a>03295 <span class="preprocessor"></span><span class="preprocessor"># undef yyclearin</span>
<a name="l03296"></a>03296 <span class="preprocessor"></span><span class="preprocessor"># undef YYRECOVERING</span>
<a name="l03297"></a>03297 <span class="preprocessor"></span><span class="comment">/* Line 872 of glr.c.  */</span>
<a name="l03298"></a>03298 <span class="preprocessor">#line 3299 "fol.cpp"</span>
<a name="l03299"></a>03299 <span class="preprocessor"></span>}
<a name="l03300"></a>03300 
<a name="l03301"></a>03301 
<a name="l03302"></a>03302 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03303"></a>03303 yyuserMerge (<span class="keywordtype">int</span> yyn, YYSTYPE* yy0, YYSTYPE* yy1)
<a name="l03304"></a>03304 {
<a name="l03305"></a>03305   <span class="comment">/* `Use' the arguments.  */</span>
<a name="l03306"></a>03306   (void) yy0;
<a name="l03307"></a>03307   (void) yy1;
<a name="l03308"></a>03308 
<a name="l03309"></a>03309   <span class="keywordflow">switch</span> (yyn)
<a name="l03310"></a>03310     {
<a name="l03311"></a>03311       
<a name="l03312"></a>03312       <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l03313"></a>03313     }
<a name="l03314"></a>03314 }
<a name="l03315"></a>03315 
<a name="l03316"></a>03316                               <span class="comment">/* Bison grammar-table manipulation.  */</span>
<a name="l03317"></a>03317 
<a name="l03318"></a>03318 <span class="comment">/*-----------------------------------------------.</span>
<a name="l03319"></a>03319 <span class="comment">| Release the memory associated to this symbol.  |</span>
<a name="l03320"></a>03320 <span class="comment">`-----------------------------------------------*/</span>
<a name="l03321"></a>03321 
<a name="l03322"></a>03322 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03323"></a>03323 yydestruct (<span class="keyword">const</span> <span class="keywordtype">char</span> *yymsg, <span class="keywordtype">int</span> yytype, YYSTYPE *yyvaluep)
<a name="l03324"></a>03324 {
<a name="l03325"></a>03325   <span class="comment">/* Pacify ``unused variable'' warnings.  */</span>
<a name="l03326"></a>03326   (void) yyvaluep;
<a name="l03327"></a>03327 
<a name="l03328"></a>03328   <span class="keywordflow">if</span> (!yymsg)
<a name="l03329"></a>03329     yymsg = <span class="stringliteral">"Deleting"</span>;
<a name="l03330"></a>03330   YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
<a name="l03331"></a>03331 
<a name="l03332"></a>03332   <span class="keywordflow">switch</span> (yytype)
<a name="l03333"></a>03333     {
<a name="l03334"></a>03334 
<a name="l03335"></a>03335       <span class="keywordflow">default</span>:
<a name="l03336"></a>03336         <span class="keywordflow">break</span>;
<a name="l03337"></a>03337     }
<a name="l03338"></a>03338 }
<a name="l03339"></a>03339 
<a name="l03341"></a>03341 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span>
<a name="l03342"></a>03342 yyrhsLength (yyRuleNum yyrule)
<a name="l03343"></a>03343 {
<a name="l03344"></a>03344   <span class="keywordflow">return</span> yyr2[yyrule];
<a name="l03345"></a>03345 }
<a name="l03346"></a>03346 
<a name="l03347"></a>03347 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03348"></a>03348 yydestroyGLRState (<span class="keywordtype">char</span> <span class="keyword">const</span> *yymsg, yyGLRState *yys)
<a name="l03349"></a>03349 {
<a name="l03350"></a>03350   <span class="keywordflow">if</span> (yys-&gt;<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a>)
<a name="l03351"></a>03351     yydestruct (yymsg, yystos[yys-&gt;<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>],
<a name="l03352"></a>03352                 &amp;yys-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">yysval</a>);
<a name="l03353"></a>03353   <span class="keywordflow">else</span>
<a name="l03354"></a>03354     {
<a name="l03355"></a>03355 <span class="preprocessor">#if YYDEBUG</span>
<a name="l03356"></a>03356 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (yydebug)
<a name="l03357"></a>03357         {
<a name="l03358"></a>03358           YYFPRINTF (stderr, <span class="stringliteral">"%s unresolved "</span>, yymsg);
<a name="l03359"></a>03359           yysymprint (stderr, yystos[yys-&gt;<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>],
<a name="l03360"></a>03360                       &amp;yys-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">yysval</a>);
<a name="l03361"></a>03361           YYFPRINTF (stderr, <span class="stringliteral">"\n"</span>);
<a name="l03362"></a>03362         }
<a name="l03363"></a>03363 <span class="preprocessor">#endif</span>
<a name="l03364"></a>03364 <span class="preprocessor"></span>
<a name="l03365"></a>03365       <span class="keywordflow">if</span> (yys-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a>)
<a name="l03366"></a>03366         {
<a name="l03367"></a>03367           yySemanticOption *yyoption = yys-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a>;
<a name="l03368"></a>03368           yyGLRState *yyrh;
<a name="l03369"></a>03369           <span class="keywordtype">int</span> yyn;
<a name="l03370"></a>03370           <span class="keywordflow">for</span> (yyrh = yyoption-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>, yyn = yyrhsLength (yyoption-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>);
<a name="l03371"></a>03371                yyn &gt; 0;
<a name="l03372"></a>03372                yyrh = yyrh-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>, yyn -= 1)
<a name="l03373"></a>03373             yydestroyGLRState (yymsg, yyrh);
<a name="l03374"></a>03374         }
<a name="l03375"></a>03375     }
<a name="l03376"></a>03376 }
<a name="l03377"></a>03377 
<a name="l03379"></a>03379 <span class="keyword">static</span> <span class="keyword">inline</span> yySymbol
<a name="l03380"></a>03380 yylhsNonterm (yyRuleNum yyrule)
<a name="l03381"></a>03381 {
<a name="l03382"></a>03382   <span class="keywordflow">return</span> yyr1[yyrule];
<a name="l03383"></a>03383 }
<a name="l03384"></a>03384 
<a name="l03385"></a>03385 <span class="preprocessor">#define yyis_pact_ninf(yystate) \</span>
<a name="l03386"></a>03386 <span class="preprocessor">  ((yystate) == YYPACT_NINF)</span>
<a name="l03387"></a>03387 <span class="preprocessor"></span>
<a name="l03390"></a>03390 <span class="keyword">static</span> <span class="keyword">inline</span> yybool
<a name="l03391"></a>03391 yyisDefaultedState (yyStateNum yystate)
<a name="l03392"></a>03392 {
<a name="l03393"></a>03393   <span class="keywordflow">return</span> yyis_pact_ninf (yypact[yystate]);
<a name="l03394"></a>03394 }
<a name="l03395"></a>03395 
<a name="l03397"></a>03397 <span class="keyword">static</span> <span class="keyword">inline</span> yyRuleNum
<a name="l03398"></a>03398 yydefaultAction (yyStateNum yystate)
<a name="l03399"></a>03399 {
<a name="l03400"></a>03400   <span class="keywordflow">return</span> yydefact[yystate];
<a name="l03401"></a>03401 }
<a name="l03402"></a>03402 
<a name="l03403"></a>03403 <span class="preprocessor">#define yyis_table_ninf(yytable_value) \</span>
<a name="l03404"></a>03404 <span class="preprocessor">  0</span>
<a name="l03405"></a>03405 <span class="preprocessor"></span>
<a name="l03414"></a>03414 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l03415"></a>03415 yygetLRActions (yyStateNum yystate, <span class="keywordtype">int</span> yytoken,
<a name="l03416"></a>03416                 <span class="keywordtype">int</span>* yyaction, <span class="keyword">const</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span>** yyconflicts)
<a name="l03417"></a>03417 {
<a name="l03418"></a>03418   <span class="keywordtype">int</span> yyindex = yypact[yystate] + yytoken;
<a name="l03419"></a>03419   <span class="keywordflow">if</span> (yyindex &lt; 0 || YYLAST &lt; yyindex || yycheck[yyindex] != yytoken)
<a name="l03420"></a>03420     {
<a name="l03421"></a>03421       *yyaction = -yydefact[yystate];
<a name="l03422"></a>03422       *yyconflicts = yyconfl;
<a name="l03423"></a>03423     }
<a name="l03424"></a>03424   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (! yyis_table_ninf (yytable[yyindex]))
<a name="l03425"></a>03425     {
<a name="l03426"></a>03426       *yyaction = yytable[yyindex];
<a name="l03427"></a>03427       *yyconflicts = yyconfl + yyconflp[yyindex];
<a name="l03428"></a>03428     }
<a name="l03429"></a>03429   <span class="keywordflow">else</span>
<a name="l03430"></a>03430     {
<a name="l03431"></a>03431       *yyaction = 0;
<a name="l03432"></a>03432       *yyconflicts = yyconfl + yyconflp[yyindex];
<a name="l03433"></a>03433     }
<a name="l03434"></a>03434 }
<a name="l03435"></a>03435 
<a name="l03436"></a>03436 <span class="keyword">static</span> <span class="keyword">inline</span> yyStateNum
<a name="l03437"></a>03437 yyLRgotoState (yyStateNum yystate, yySymbol yylhs)
<a name="l03438"></a>03438 {
<a name="l03439"></a>03439   <span class="keywordtype">int</span> yyr;
<a name="l03440"></a>03440   yyr = yypgoto[yylhs - YYNTOKENS] + yystate;
<a name="l03441"></a>03441   <span class="keywordflow">if</span> (0 &lt;= yyr &amp;&amp; yyr &lt;= YYLAST &amp;&amp; yycheck[yyr] == yystate)
<a name="l03442"></a>03442     <span class="keywordflow">return</span> yytable[yyr];
<a name="l03443"></a>03443   <span class="keywordflow">else</span>
<a name="l03444"></a>03444     <span class="keywordflow">return</span> yydefgoto[yylhs - YYNTOKENS];
<a name="l03445"></a>03445 }
<a name="l03446"></a>03446 
<a name="l03447"></a>03447 <span class="keyword">static</span> <span class="keyword">inline</span> yybool
<a name="l03448"></a>03448 yyisShiftAction (<span class="keywordtype">int</span> yyaction)
<a name="l03449"></a>03449 {
<a name="l03450"></a>03450   <span class="keywordflow">return</span> 0 &lt; yyaction;
<a name="l03451"></a>03451 }
<a name="l03452"></a>03452 
<a name="l03453"></a>03453 <span class="keyword">static</span> <span class="keyword">inline</span> yybool
<a name="l03454"></a>03454 yyisErrorAction (<span class="keywordtype">int</span> yyaction)
<a name="l03455"></a>03455 {
<a name="l03456"></a>03456   <span class="keywordflow">return</span> yyaction == 0;
<a name="l03457"></a>03457 }
<a name="l03458"></a>03458 
<a name="l03459"></a>03459                                 <span class="comment">/* GLRStates */</span>
<a name="l03460"></a>03460 
<a name="l03461"></a>03461 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03462"></a>03462 yyaddDeferredAction (yyGLRStack* yystack, yyGLRState* yystate,
<a name="l03463"></a>03463                      yyGLRState* rhs, yyRuleNum yyrule)
<a name="l03464"></a>03464 {
<a name="l03465"></a>03465   yySemanticOption* yynewItem;
<a name="l03466"></a>03466   yynewItem = &amp;yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a>-&gt;<a class="code" href="unionyyGLRStackItem.html#3d0f2eae1a1434c0ea04b183df701cc3">yyoption</a>;
<a name="l03467"></a>03467   yystack-&gt;<a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a> -= 1;
<a name="l03468"></a>03468   yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a> += 1;
<a name="l03469"></a>03469   yynewItem-&gt;<a class="code" href="structyySemanticOption.html#01f332a0b1efba6c627889e849d34e63">yyisState</a> = yyfalse;
<a name="l03470"></a>03470   yynewItem-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a> = rhs;
<a name="l03471"></a>03471   yynewItem-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a> = yyrule;
<a name="l03472"></a>03472   yynewItem-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a> = yystate-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a>;
<a name="l03473"></a>03473   yystate-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a> = yynewItem;
<a name="l03474"></a>03474   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a> &lt; YYHEADROOM)
<a name="l03475"></a>03475     yyexpandGLRStack (yystack);
<a name="l03476"></a>03476 }
<a name="l03477"></a>03477 
<a name="l03478"></a>03478                                 <span class="comment">/* GLRStacks */</span>
<a name="l03479"></a>03479 
<a name="l03481"></a>03481 <span class="keyword">static</span> yybool
<a name="l03482"></a>03482 yyinitStateSet (yyGLRStateSet* yyset)
<a name="l03483"></a>03483 {
<a name="l03484"></a>03484   yyset-&gt;<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a> = 1;
<a name="l03485"></a>03485   yyset-&gt;<a class="code" href="structyyGLRStateSet.html#7aa2c0441b518c4be69b712943b263af">yycapacity</a> = 16;
<a name="l03486"></a>03486   yyset-&gt;<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a> = (yyGLRState**) YYMALLOC (16 * <span class="keyword">sizeof</span> yyset-&gt;<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[0]);
<a name="l03487"></a>03487   <span class="keywordflow">if</span> (! yyset-&gt;<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>)
<a name="l03488"></a>03488     <span class="keywordflow">return</span> yyfalse;
<a name="l03489"></a>03489   yyset-&gt;<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[0] = NULL;
<a name="l03490"></a>03490   <span class="keywordflow">return</span> yytrue;
<a name="l03491"></a>03491 }
<a name="l03492"></a>03492 
<a name="l03493"></a>03493 <span class="keyword">static</span> <span class="keywordtype">void</span> yyfreeStateSet (yyGLRStateSet* yyset)
<a name="l03494"></a>03494 {
<a name="l03495"></a>03495   YYFREE (yyset-&gt;<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>);
<a name="l03496"></a>03496 }
<a name="l03497"></a>03497 
<a name="l03500"></a>03500 <span class="keyword">static</span> yybool
<a name="l03501"></a>03501 yyinitGLRStack (yyGLRStack* yystack, size_t yysize)
<a name="l03502"></a>03502 {
<a name="l03503"></a>03503   yystack-&gt;<a class="code" href="structyyGLRStack.html#ed6f3ec7244916a7970aefd460d1b9bd">yyerrState</a> = 0;
<a name="l03504"></a>03504   yynerrs = 0;
<a name="l03505"></a>03505   yystack-&gt;<a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a> = yysize;
<a name="l03506"></a>03506   yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a> =
<a name="l03507"></a>03507     (yyGLRStackItem*) YYMALLOC (yysize * <span class="keyword">sizeof</span> yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a>[0]);
<a name="l03508"></a>03508   <span class="keywordflow">if</span> (!yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>)
<a name="l03509"></a>03509     <span class="keywordflow">return</span> yyfalse;
<a name="l03510"></a>03510   yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a> = yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>;
<a name="l03511"></a>03511   yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> = NULL;
<a name="l03512"></a>03512   yystack-&gt;<a class="code" href="structyyGLRStack.html#142add5df99046684b32fc4a1aaff471">yylastDeleted</a> = NULL;
<a name="l03513"></a>03513   <span class="keywordflow">return</span> yyinitStateSet (&amp;yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>);
<a name="l03514"></a>03514 }
<a name="l03515"></a>03515 
<a name="l03516"></a>03516 <span class="preprocessor">#define YYRELOC(YYFROMITEMS,YYTOITEMS,YYX,YYTYPE) \</span>
<a name="l03517"></a>03517 <span class="preprocessor">  &amp;((YYTOITEMS) - ((YYFROMITEMS) - (yyGLRStackItem*) (YYX)))-&gt;YYTYPE</span>
<a name="l03518"></a>03518 <span class="preprocessor"></span>
<a name="l03524"></a>03524 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03525"></a>03525 yyexpandGLRStack (yyGLRStack* yystack)
<a name="l03526"></a>03526 {
<a name="l03527"></a>03527 <span class="preprocessor">#if YYSTACKEXPANDABLE</span>
<a name="l03528"></a>03528 <span class="preprocessor"></span>  yyGLRStackItem* yynewItems;
<a name="l03529"></a>03529   yyGLRStackItem* yyp0, *yyp1;
<a name="l03530"></a>03530   size_t yysize, yynewSize;
<a name="l03531"></a>03531   size_t yyn;
<a name="l03532"></a>03532   yysize = yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a> - yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>;
<a name="l03533"></a>03533   <span class="keywordflow">if</span> (YYMAXDEPTH &lt;= yysize)
<a name="l03534"></a>03534     yyMemoryExhausted (yystack);
<a name="l03535"></a>03535   yynewSize = 2*yysize;
<a name="l03536"></a>03536   <span class="keywordflow">if</span> (YYMAXDEPTH &lt; yynewSize)
<a name="l03537"></a>03537     yynewSize = YYMAXDEPTH;
<a name="l03538"></a>03538   yynewItems = (yyGLRStackItem*) YYMALLOC (yynewSize * <span class="keyword">sizeof</span> yynewItems[0]);
<a name="l03539"></a>03539   <span class="keywordflow">if</span> (! yynewItems)
<a name="l03540"></a>03540     yyMemoryExhausted (yystack);
<a name="l03541"></a>03541   <span class="keywordflow">for</span> (yyp0 = yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>, yyp1 = yynewItems, yyn = yysize;
<a name="l03542"></a>03542        0 &lt; yyn;
<a name="l03543"></a>03543        yyn -= 1, yyp0 += 1, yyp1 += 1)
<a name="l03544"></a>03544     {
<a name="l03545"></a>03545       *yyp1 = *yyp0;
<a name="l03546"></a>03546       <span class="keywordflow">if</span> (*(yybool *) yyp0)
<a name="l03547"></a>03547         {
<a name="l03548"></a>03548           yyGLRState* yys0 = &amp;yyp0-&gt;yystate;
<a name="l03549"></a>03549           yyGLRState* yys1 = &amp;yyp1-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>;
<a name="l03550"></a>03550           <span class="keywordflow">if</span> (yys0-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a> != NULL)
<a name="l03551"></a>03551             yys1-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a> =
<a name="l03552"></a>03552               YYRELOC (yyp0, yyp1, yys0-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>, yystate);
<a name="l03553"></a>03553           <span class="keywordflow">if</span> (! yys0-&gt;<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a> &amp;&amp; yys0-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a> != NULL)
<a name="l03554"></a>03554             yys1-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a> =
<a name="l03555"></a>03555               YYRELOC(yyp0, yyp1, yys0-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a>, yyoption);
<a name="l03556"></a>03556         }
<a name="l03557"></a>03557       <span class="keywordflow">else</span>
<a name="l03558"></a>03558         {
<a name="l03559"></a>03559           yySemanticOption* yyv0 = &amp;yyp0-&gt;yyoption;
<a name="l03560"></a>03560           yySemanticOption* yyv1 = &amp;yyp1-&gt;<a class="code" href="unionyyGLRStackItem.html#3d0f2eae1a1434c0ea04b183df701cc3">yyoption</a>;
<a name="l03561"></a>03561           <span class="keywordflow">if</span> (yyv0-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a> != NULL)
<a name="l03562"></a>03562             yyv1-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a> = YYRELOC (yyp0, yyp1, yyv0-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>, yystate);
<a name="l03563"></a>03563           <span class="keywordflow">if</span> (yyv0-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a> != NULL)
<a name="l03564"></a>03564             yyv1-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a> = YYRELOC (yyp0, yyp1, yyv0-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a>, yyoption);
<a name="l03565"></a>03565         }
<a name="l03566"></a>03566     }
<a name="l03567"></a>03567   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> != NULL)
<a name="l03568"></a>03568     yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> = YYRELOC (yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>, yynewItems,
<a name="l03569"></a>03569                                  yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a>, yystate);
<a name="l03570"></a>03570 
<a name="l03571"></a>03571   <span class="keywordflow">for</span> (yyn = 0; yyn &lt; yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a>; yyn += 1)
<a name="l03572"></a>03572     <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyn] != NULL)
<a name="l03573"></a>03573       yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyn] =
<a name="l03574"></a>03574         YYRELOC (yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>, yynewItems,
<a name="l03575"></a>03575                  yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyn], yystate);
<a name="l03576"></a>03576   YYFREE (yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>);
<a name="l03577"></a>03577   yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a> = yynewItems;
<a name="l03578"></a>03578   yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a> = yynewItems + yysize;
<a name="l03579"></a>03579   yystack-&gt;<a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a> = yynewSize - yysize;
<a name="l03580"></a>03580 
<a name="l03581"></a>03581 #<span class="keywordflow">else</span>
<a name="l03582"></a>03582   yyMemoryExhausted (yystack);
<a name="l03583"></a>03583 <span class="preprocessor">#endif</span>
<a name="l03584"></a>03584 <span class="preprocessor"></span>}
<a name="l03585"></a>03585 
<a name="l03586"></a>03586 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03587"></a>03587 yyfreeGLRStack (yyGLRStack* yystack)
<a name="l03588"></a>03588 {
<a name="l03589"></a>03589   YYFREE (yystack-&gt;yyitems);
<a name="l03590"></a>03590   yyfreeStateSet (&amp;yystack-&gt;yytops);
<a name="l03591"></a>03591 }
<a name="l03592"></a>03592 
<a name="l03596"></a>03596 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l03597"></a>03597 yyupdateSplit (yyGLRStack* yystack, yyGLRState* yys)
<a name="l03598"></a>03598 {
<a name="l03599"></a>03599   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> != NULL &amp;&amp; yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> &gt; yys)
<a name="l03600"></a>03600     yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> = yys;
<a name="l03601"></a>03601 }
<a name="l03602"></a>03602 
<a name="l03604"></a>03604 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l03605"></a>03605 yymarkStackDeleted (yyGLRStack* yystack, size_t yyk)
<a name="l03606"></a>03606 {
<a name="l03607"></a>03607   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk] != NULL)
<a name="l03608"></a>03608     yystack-&gt;<a class="code" href="structyyGLRStack.html#142add5df99046684b32fc4a1aaff471">yylastDeleted</a> = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk];
<a name="l03609"></a>03609   yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk] = NULL;
<a name="l03610"></a>03610 }
<a name="l03611"></a>03611 
<a name="l03615"></a>03615 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03616"></a>03616 yyundeleteLastStack (yyGLRStack* yystack)
<a name="l03617"></a>03617 {
<a name="l03618"></a>03618   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#142add5df99046684b32fc4a1aaff471">yylastDeleted</a> == NULL || yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a> != 0)
<a name="l03619"></a>03619     <span class="keywordflow">return</span>;
<a name="l03620"></a>03620   yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[0] = yystack-&gt;<a class="code" href="structyyGLRStack.html#142add5df99046684b32fc4a1aaff471">yylastDeleted</a>;
<a name="l03621"></a>03621   yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a> = 1;
<a name="l03622"></a>03622   YYDPRINTF ((stderr, <span class="stringliteral">"Restoring last deleted stack as stack #0.\n"</span>));
<a name="l03623"></a>03623   yystack-&gt;<a class="code" href="structyyGLRStack.html#142add5df99046684b32fc4a1aaff471">yylastDeleted</a> = NULL;
<a name="l03624"></a>03624 }
<a name="l03625"></a>03625 
<a name="l03626"></a>03626 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l03627"></a>03627 yyremoveDeletes (yyGLRStack* yystack)
<a name="l03628"></a>03628 {
<a name="l03629"></a>03629   size_t yyi, yyj;
<a name="l03630"></a>03630   yyi = yyj = 0;
<a name="l03631"></a>03631   <span class="keywordflow">while</span> (yyj &lt; yystack-&gt;yytops.yysize)
<a name="l03632"></a>03632     {
<a name="l03633"></a>03633       <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyi] == NULL)
<a name="l03634"></a>03634         {
<a name="l03635"></a>03635           <span class="keywordflow">if</span> (yyi == yyj)
<a name="l03636"></a>03636             {
<a name="l03637"></a>03637               YYDPRINTF ((stderr, <span class="stringliteral">"Removing dead stacks.\n"</span>));
<a name="l03638"></a>03638             }
<a name="l03639"></a>03639           yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a> -= 1;
<a name="l03640"></a>03640         }
<a name="l03641"></a>03641       <span class="keywordflow">else</span>
<a name="l03642"></a>03642         {
<a name="l03643"></a>03643           yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyj] = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyi];
<a name="l03644"></a>03644           <span class="keywordflow">if</span> (yyj != yyi)
<a name="l03645"></a>03645             {
<a name="l03646"></a>03646               YYDPRINTF ((stderr, <span class="stringliteral">"Rename stack %lu -&gt; %lu.\n"</span>,
<a name="l03647"></a>03647                           (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyi, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyj));
<a name="l03648"></a>03648             }
<a name="l03649"></a>03649           yyj += 1;
<a name="l03650"></a>03650         }
<a name="l03651"></a>03651       yyi += 1;
<a name="l03652"></a>03652     }
<a name="l03653"></a>03653 }
<a name="l03654"></a>03654 
<a name="l03657"></a>03657 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l03658"></a>03658 yyglrShift (yyGLRStack* yystack, size_t yyk, yyStateNum yylrState,
<a name="l03659"></a>03659             size_t yyposn,
<a name="l03660"></a>03660             YYSTYPE yysval, <a class="code" href="structYYLTYPE.html">YYLTYPE</a>* yylocp)
<a name="l03661"></a>03661 {
<a name="l03662"></a>03662   yyGLRStackItem* yynewItem;
<a name="l03663"></a>03663 
<a name="l03664"></a>03664   yynewItem = yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a>;
<a name="l03665"></a>03665   yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a> += 1;
<a name="l03666"></a>03666   yystack-&gt;<a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a> -= 1;
<a name="l03667"></a>03667   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#3188b3d0b913f2f6f2ff1c56dc8b8231">yyisState</a> = yytrue;
<a name="l03668"></a>03668   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a> = yylrState;
<a name="l03669"></a>03669   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a> = yyposn;
<a name="l03670"></a>03670   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a> = yytrue;
<a name="l03671"></a>03671   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a> = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk];
<a name="l03672"></a>03672   yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk] = &amp;yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>;
<a name="l03673"></a>03673   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">yysval</a> = yysval;
<a name="l03674"></a>03674   yylocp-&gt;<a class="code" href="structYYLTYPE.html#23416f288b2d6553b6757640465eb29b">yydummy</a> = <span class="charliteral">'a'</span>; yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#c6143618fb4276d3f8d6030b2f61f26d">yyloc</a> = *yylocp;
<a name="l03675"></a>03675   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a> &lt; YYHEADROOM)
<a name="l03676"></a>03676     yyexpandGLRStack (yystack);
<a name="l03677"></a>03677 }
<a name="l03678"></a>03678 
<a name="l03682"></a>03682 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l03683"></a>03683 yyglrShiftDefer (yyGLRStack* yystack, size_t yyk, yyStateNum yylrState,
<a name="l03684"></a>03684                  size_t yyposn, yyGLRState* rhs, yyRuleNum yyrule)
<a name="l03685"></a>03685 {
<a name="l03686"></a>03686   yyGLRStackItem* yynewItem;
<a name="l03687"></a>03687 
<a name="l03688"></a>03688   yynewItem = yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a>;
<a name="l03689"></a>03689   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#3188b3d0b913f2f6f2ff1c56dc8b8231">yyisState</a> = yytrue;
<a name="l03690"></a>03690   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a> = yylrState;
<a name="l03691"></a>03691   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a> = yyposn;
<a name="l03692"></a>03692   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a> = yyfalse;
<a name="l03693"></a>03693   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a> = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk];
<a name="l03694"></a>03694   yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a> = NULL;
<a name="l03695"></a>03695   yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk] = &amp;yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>;
<a name="l03696"></a>03696   yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a> += 1;
<a name="l03697"></a>03697   yystack-&gt;<a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a> -= 1;
<a name="l03698"></a>03698   yyaddDeferredAction (yystack, &amp;yynewItem-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>, rhs, yyrule);
<a name="l03699"></a>03699 }
<a name="l03700"></a>03700 
<a name="l03707"></a>03707 <span class="keyword">static</span> <span class="keyword">inline</span> YYRESULTTAG
<a name="l03708"></a>03708 yydoAction (yyGLRStack* yystack, size_t yyk, yyRuleNum yyrule,
<a name="l03709"></a>03709             YYSTYPE* yyvalp, <a class="code" href="structYYLTYPE.html">YYLTYPE</a>* yylocp)
<a name="l03710"></a>03710 {
<a name="l03711"></a>03711   <span class="keywordtype">int</span> yynrhs = yyrhsLength (yyrule);
<a name="l03712"></a>03712 
<a name="l03713"></a>03713   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> == NULL)
<a name="l03714"></a>03714     {
<a name="l03715"></a>03715       <span class="comment">/* Standard special case: single stack. */</span>
<a name="l03716"></a>03716       yyGLRStackItem* rhs = (yyGLRStackItem*) yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk];
<a name="l03717"></a>03717       YYASSERT (yyk == 0);
<a name="l03718"></a>03718       yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a> -= yynrhs;
<a name="l03719"></a>03719       yystack-&gt;<a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a> += yynrhs;
<a name="l03720"></a>03720       yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[0] = &amp; yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a>[-1].<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>;
<a name="l03721"></a>03721       <span class="keywordflow">return</span> yyuserAction (yyrule, yynrhs, rhs,
<a name="l03722"></a>03722                            yyvalp, yylocp, yystack);
<a name="l03723"></a>03723     }
<a name="l03724"></a>03724   <span class="keywordflow">else</span>
<a name="l03725"></a>03725     {
<a name="l03726"></a>03726       <span class="keywordtype">int</span> yyi;
<a name="l03727"></a>03727       yyGLRState* yys;
<a name="l03728"></a>03728       yyGLRStackItem yyrhsVals[YYMAXRHS + YYMAXLEFT + 1];
<a name="l03729"></a>03729       yys = yyrhsVals[YYMAXRHS + YYMAXLEFT].<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>
<a name="l03730"></a>03730         = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk];
<a name="l03731"></a>03731       <span class="keywordflow">for</span> (yyi = 0; yyi &lt; yynrhs; yyi += 1)
<a name="l03732"></a>03732         {
<a name="l03733"></a>03733           yys = yys-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>;
<a name="l03734"></a>03734           YYASSERT (yys);
<a name="l03735"></a>03735         }
<a name="l03736"></a>03736       yyupdateSplit (yystack, yys);
<a name="l03737"></a>03737       yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk] = yys;
<a name="l03738"></a>03738       <span class="keywordflow">return</span> yyuserAction (yyrule, yynrhs, yyrhsVals + YYMAXRHS + YYMAXLEFT - 1,
<a name="l03739"></a>03739                            yyvalp, yylocp, yystack);
<a name="l03740"></a>03740     }
<a name="l03741"></a>03741 }
<a name="l03742"></a>03742 
<a name="l03743"></a>03743 <span class="preprocessor">#if !YYDEBUG</span>
<a name="l03744"></a>03744 <span class="preprocessor"></span><span class="preprocessor"># define YY_REDUCE_PRINT(K, Rule)</span>
<a name="l03745"></a>03745 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l03746"></a>03746 <span class="preprocessor"></span><span class="preprocessor"># define YY_REDUCE_PRINT(K, Rule)       \</span>
<a name="l03747"></a>03747 <span class="preprocessor">do {                                    \</span>
<a name="l03748"></a>03748 <span class="preprocessor">  if (yydebug)                          \</span>
<a name="l03749"></a>03749 <span class="preprocessor">    yy_reduce_print (K, Rule);          \</span>
<a name="l03750"></a>03750 <span class="preprocessor">} while (0)</span>
<a name="l03751"></a>03751 <span class="preprocessor"></span>
<a name="l03752"></a>03752 <span class="comment">/*----------------------------------------------------------.</span>
<a name="l03753"></a>03753 <span class="comment">| Report that the RULE is going to be reduced on stack #K.  |</span>
<a name="l03754"></a>03754 <span class="comment">`----------------------------------------------------------*/</span>
<a name="l03755"></a>03755 
<a name="l03756"></a>03756 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l03757"></a>03757 yy_reduce_print (size_t yyk, yyRuleNum yyrule)
<a name="l03758"></a>03758 {
<a name="l03759"></a>03759   <span class="keywordtype">int</span> yyi;
<a name="l03760"></a>03760   YYFPRINTF (stderr, <span class="stringliteral">"Reducing stack %lu by rule %d (line %lu), "</span>,
<a name="l03761"></a>03761              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyk, yyrule - 1,
<a name="l03762"></a>03762              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyrline[yyrule]);
<a name="l03763"></a>03763   <span class="comment">/* Print the symbols being reduced, and their result.  */</span>
<a name="l03764"></a>03764   <span class="keywordflow">for</span> (yyi = yyprhs[yyrule]; 0 &lt;= yyrhs[yyi]; yyi++)
<a name="l03765"></a>03765     YYFPRINTF (stderr, <span class="stringliteral">"%s "</span>, yytokenName (yyrhs[yyi]));
<a name="l03766"></a>03766   YYFPRINTF (stderr, <span class="stringliteral">"-&gt; %s\n"</span>, yytokenName (yyr1[yyrule]));
<a name="l03767"></a>03767 }
<a name="l03768"></a>03768 <span class="preprocessor">#endif</span>
<a name="l03769"></a>03769 <span class="preprocessor"></span>
<a name="l03781"></a>03781 <span class="keyword">static</span> <span class="keyword">inline</span> YYRESULTTAG
<a name="l03782"></a>03782 yyglrReduce (yyGLRStack* yystack, size_t yyk, yyRuleNum yyrule,
<a name="l03783"></a>03783              yybool yyforceEval)
<a name="l03784"></a>03784 {
<a name="l03785"></a>03785   size_t yyposn = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk]-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a>;
<a name="l03786"></a>03786 
<a name="l03787"></a>03787   <span class="keywordflow">if</span> (yyforceEval || yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> == NULL)
<a name="l03788"></a>03788     {
<a name="l03789"></a>03789       YYSTYPE yysval;
<a name="l03790"></a>03790       <a class="code" href="structYYLTYPE.html">YYLTYPE</a> yyloc;
<a name="l03791"></a>03791 
<a name="l03792"></a>03792       YY_REDUCE_PRINT (yyk, yyrule);
<a name="l03793"></a>03793       YYCHK (yydoAction (yystack, yyk, yyrule, &amp;yysval, &amp;yyloc));
<a name="l03794"></a>03794       yyglrShift (yystack, yyk,
<a name="l03795"></a>03795                   yyLRgotoState (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk]-&gt;<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>,
<a name="l03796"></a>03796                                  yylhsNonterm (yyrule)),
<a name="l03797"></a>03797                   yyposn, yysval, &amp;yyloc);
<a name="l03798"></a>03798     }
<a name="l03799"></a>03799   <span class="keywordflow">else</span>
<a name="l03800"></a>03800     {
<a name="l03801"></a>03801       size_t yyi;
<a name="l03802"></a>03802       <span class="keywordtype">int</span> yyn;
<a name="l03803"></a>03803       yyGLRState* yys, *yys0 = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk];
<a name="l03804"></a>03804       yyStateNum yynewLRState;
<a name="l03805"></a>03805 
<a name="l03806"></a>03806       <span class="keywordflow">for</span> (yys = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk], yyn = yyrhsLength (yyrule);
<a name="l03807"></a>03807            0 &lt; yyn; yyn -= 1)
<a name="l03808"></a>03808         {
<a name="l03809"></a>03809           yys = yys-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>;
<a name="l03810"></a>03810           YYASSERT (yys);
<a name="l03811"></a>03811         }
<a name="l03812"></a>03812       yyupdateSplit (yystack, yys);
<a name="l03813"></a>03813       yynewLRState = yyLRgotoState (yys-&gt;<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>, yylhsNonterm (yyrule));
<a name="l03814"></a>03814       YYDPRINTF ((stderr,
<a name="l03815"></a>03815                   <span class="stringliteral">"Reduced stack %lu by rule #%d; action deferred. Now in state %d.\n"</span>,
<a name="l03816"></a>03816                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyk, yyrule - 1, yynewLRState));
<a name="l03817"></a>03817       <span class="keywordflow">for</span> (yyi = 0; yyi &lt; yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a>; yyi += 1)
<a name="l03818"></a>03818         <span class="keywordflow">if</span> (yyi != yyk &amp;&amp; yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyi] != NULL)
<a name="l03819"></a>03819           {
<a name="l03820"></a>03820             yyGLRState* yyp, *yysplit = yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a>;
<a name="l03821"></a>03821             yyp = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyi];
<a name="l03822"></a>03822             while (yyp != yys &amp;&amp; yyp != yysplit &amp;&amp; yyp-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a> &gt;= yyposn)
<a name="l03823"></a>03823               {
<a name="l03824"></a>03824                 if (yyp-&gt;yylrState == yynewLRState &amp;&amp; yyp-&gt;yypred == yys)
<a name="l03825"></a>03825                   {
<a name="l03826"></a>03826                     yyaddDeferredAction (yystack, yyp, yys0, yyrule);
<a name="l03827"></a>03827                     yymarkStackDeleted (yystack, yyk);
<a name="l03828"></a>03828                     YYDPRINTF ((stderr, <span class="stringliteral">"Merging stack %lu into stack %lu.\n"</span>,
<a name="l03829"></a>03829                                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyk,
<a name="l03830"></a>03830                                 (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyi));
<a name="l03831"></a>03831                     <span class="keywordflow">return</span> yyok;
<a name="l03832"></a>03832                   }
<a name="l03833"></a>03833                 yyp = yyp-&gt;yypred;
<a name="l03834"></a>03834               }
<a name="l03835"></a>03835           }
<a name="l03836"></a>03836       yystack-&gt;yytops.yystates[yyk] = yys;
<a name="l03837"></a>03837       yyglrShiftDefer (yystack, yyk, yynewLRState, yyposn, yys0, yyrule);
<a name="l03838"></a>03838     }
<a name="l03839"></a>03839   <span class="keywordflow">return</span> yyok;
<a name="l03840"></a>03840 }
<a name="l03841"></a>03841 
<a name="l03842"></a>03842 <span class="keyword">static</span> size_t
<a name="l03843"></a>03843 yysplitStack (yyGLRStack* yystack, size_t yyk)
<a name="l03844"></a>03844 {
<a name="l03845"></a>03845   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> == NULL)
<a name="l03846"></a>03846     {
<a name="l03847"></a>03847       YYASSERT (yyk == 0);
<a name="l03848"></a>03848       yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk];
<a name="l03849"></a>03849     }
<a name="l03850"></a>03850   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a> &gt;= yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#7aa2c0441b518c4be69b712943b263af">yycapacity</a>)
<a name="l03851"></a>03851     {
<a name="l03852"></a>03852       yyGLRState** yynewStates;
<a name="l03853"></a>03853       <span class="keywordflow">if</span> (! ((yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#7aa2c0441b518c4be69b712943b263af">yycapacity</a>
<a name="l03854"></a>03854               &lt;= (YYSIZEMAX / (2 * <span class="keyword">sizeof</span> yynewStates[0])))
<a name="l03855"></a>03855              &amp;&amp; (yynewStates =
<a name="l03856"></a>03856                  (yyGLRState**) YYREALLOC (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>,
<a name="l03857"></a>03857                                            ((yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#7aa2c0441b518c4be69b712943b263af">yycapacity</a> *= 2)
<a name="l03858"></a>03858                                             * <span class="keyword">sizeof</span> yynewStates[0])))))
<a name="l03859"></a>03859         yyMemoryExhausted (yystack);
<a name="l03860"></a>03860       yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a> = yynewStates;
<a name="l03861"></a>03861     }
<a name="l03862"></a>03862   yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a>]
<a name="l03863"></a>03863     = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk];
<a name="l03864"></a>03864   yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a> += 1;
<a name="l03865"></a>03865   <span class="keywordflow">return</span> yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a>-1;
<a name="l03866"></a>03866 }
<a name="l03867"></a>03867 
<a name="l03871"></a>03871 <span class="keyword">static</span> yybool
<a name="l03872"></a>03872 yyidenticalOptions (yySemanticOption* yyy0, yySemanticOption* yyy1)
<a name="l03873"></a>03873 {
<a name="l03874"></a>03874   <span class="keywordflow">if</span> (yyy0-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a> == yyy1-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>)
<a name="l03875"></a>03875     {
<a name="l03876"></a>03876       yyGLRState *yys0, *yys1;
<a name="l03877"></a>03877       <span class="keywordtype">int</span> yyn;
<a name="l03878"></a>03878       <span class="keywordflow">for</span> (yys0 = yyy0-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>, yys1 = yyy1-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>,
<a name="l03879"></a>03879            yyn = yyrhsLength (yyy0-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>);
<a name="l03880"></a>03880            yyn &gt; 0;
<a name="l03881"></a>03881            yys0 = yys0-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>, yys1 = yys1-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>, yyn -= 1)
<a name="l03882"></a>03882         <span class="keywordflow">if</span> (yys0-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a> != yys1-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a>)
<a name="l03883"></a>03883           <span class="keywordflow">return</span> yyfalse;
<a name="l03884"></a>03884       <span class="keywordflow">return</span> yytrue;
<a name="l03885"></a>03885     }
<a name="l03886"></a>03886   <span class="keywordflow">else</span>
<a name="l03887"></a>03887     <span class="keywordflow">return</span> yyfalse;
<a name="l03888"></a>03888 }
<a name="l03889"></a>03889 
<a name="l03892"></a>03892 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l03893"></a>03893 yymergeOptionSets (yySemanticOption* yyy0, yySemanticOption* yyy1)
<a name="l03894"></a>03894 {
<a name="l03895"></a>03895   yyGLRState *yys0, *yys1;
<a name="l03896"></a>03896   <span class="keywordtype">int</span> yyn;
<a name="l03897"></a>03897   <span class="keywordflow">for</span> (yys0 = yyy0-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>, yys1 = yyy1-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>,
<a name="l03898"></a>03898        yyn = yyrhsLength (yyy0-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>);
<a name="l03899"></a>03899        yyn &gt; 0;
<a name="l03900"></a>03900        yys0 = yys0-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>, yys1 = yys1-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>, yyn -= 1)
<a name="l03901"></a>03901     {
<a name="l03902"></a>03902       <span class="keywordflow">if</span> (yys0 == yys1)
<a name="l03903"></a>03903         <span class="keywordflow">break</span>;
<a name="l03904"></a>03904       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (yys0-&gt;<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a>)
<a name="l03905"></a>03905         {
<a name="l03906"></a>03906           yys1-&gt;<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a> = yytrue;
<a name="l03907"></a>03907           yys1-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">yysval</a> = yys0-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">yysval</a>;
<a name="l03908"></a>03908         }
<a name="l03909"></a>03909       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (yys1-&gt;<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a>)
<a name="l03910"></a>03910         {
<a name="l03911"></a>03911           yys0-&gt;<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a> = yytrue;
<a name="l03912"></a>03912           yys0-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">yysval</a> = yys1-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">yysval</a>;
<a name="l03913"></a>03913         }
<a name="l03914"></a>03914       <span class="keywordflow">else</span>
<a name="l03915"></a>03915         {
<a name="l03916"></a>03916           yySemanticOption** yyz0p;
<a name="l03917"></a>03917           yySemanticOption* yyz1;
<a name="l03918"></a>03918           yyz0p = &amp;yys0-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a>;
<a name="l03919"></a>03919           yyz1 = yys1-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a>;
<a name="l03920"></a>03920           <span class="keywordflow">while</span> (yytrue)
<a name="l03921"></a>03921             {
<a name="l03922"></a>03922               <span class="keywordflow">if</span> (yyz1 == *yyz0p || yyz1 == NULL)
<a name="l03923"></a>03923                 <span class="keywordflow">break</span>;
<a name="l03924"></a>03924               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*yyz0p == NULL)
<a name="l03925"></a>03925                 {
<a name="l03926"></a>03926                   *yyz0p = yyz1;
<a name="l03927"></a>03927                   <span class="keywordflow">break</span>;
<a name="l03928"></a>03928                 }
<a name="l03929"></a>03929               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*yyz0p &lt; yyz1)
<a name="l03930"></a>03930                 {
<a name="l03931"></a>03931                   yySemanticOption* yyz = *yyz0p;
<a name="l03932"></a>03932                   *yyz0p = yyz1;
<a name="l03933"></a>03933                   yyz1 = yyz1-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a>;
<a name="l03934"></a>03934                   (*yyz0p)-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a> = yyz;
<a name="l03935"></a>03935                 }
<a name="l03936"></a>03936               yyz0p = &amp;(*yyz0p)-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a>;
<a name="l03937"></a>03937             }
<a name="l03938"></a>03938           yys1-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a> = yys0-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a>;
<a name="l03939"></a>03939         }
<a name="l03940"></a>03940     }
<a name="l03941"></a>03941 }
<a name="l03942"></a>03942 
<a name="l03946"></a>03946 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l03947"></a>03947 yypreference (yySemanticOption* y0, yySemanticOption* y1)
<a name="l03948"></a>03948 {
<a name="l03949"></a>03949   yyRuleNum r0 = y0-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>, r1 = y1-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>;
<a name="l03950"></a>03950   <span class="keywordtype">int</span> p0 = yydprec[r0], p1 = yydprec[r1];
<a name="l03951"></a>03951 
<a name="l03952"></a>03952   <span class="keywordflow">if</span> (p0 == p1)
<a name="l03953"></a>03953     {
<a name="l03954"></a>03954       <span class="keywordflow">if</span> (yymerger[r0] == 0 || yymerger[r0] != yymerger[r1])
<a name="l03955"></a>03955         <span class="keywordflow">return</span> 0;
<a name="l03956"></a>03956       <span class="keywordflow">else</span>
<a name="l03957"></a>03957         <span class="keywordflow">return</span> 1;
<a name="l03958"></a>03958     }
<a name="l03959"></a>03959   <span class="keywordflow">if</span> (p0 == 0 || p1 == 0)
<a name="l03960"></a>03960     <span class="keywordflow">return</span> 0;
<a name="l03961"></a>03961   <span class="keywordflow">if</span> (p0 &lt; p1)
<a name="l03962"></a>03962     <span class="keywordflow">return</span> 3;
<a name="l03963"></a>03963   <span class="keywordflow">if</span> (p1 &lt; p0)
<a name="l03964"></a>03964     <span class="keywordflow">return</span> 2;
<a name="l03965"></a>03965   <span class="keywordflow">return</span> 0;
<a name="l03966"></a>03966 }
<a name="l03967"></a>03967 
<a name="l03968"></a>03968 <span class="keyword">static</span> YYRESULTTAG yyresolveValue (yySemanticOption* yyoptionList,
<a name="l03969"></a>03969                                    yyGLRStack* yystack, YYSTYPE* yyvalp,
<a name="l03970"></a>03970                                    <a class="code" href="structYYLTYPE.html">YYLTYPE</a>* yylocp);
<a name="l03971"></a>03971 
<a name="l03972"></a>03972 <span class="keyword">static</span> YYRESULTTAG
<a name="l03973"></a>03973 yyresolveStates (yyGLRState* yys, <span class="keywordtype">int</span> yyn, yyGLRStack* yystack)
<a name="l03974"></a>03974 {
<a name="l03975"></a>03975   YYRESULTTAG yyflag;
<a name="l03976"></a>03976   <span class="keywordflow">if</span> (0 &lt; yyn)
<a name="l03977"></a>03977     {
<a name="l03978"></a>03978       YYASSERT (yys-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>);
<a name="l03979"></a>03979       yyflag = yyresolveStates (yys-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>, yyn-1, yystack);
<a name="l03980"></a>03980       <span class="keywordflow">if</span> (yyflag != yyok)
<a name="l03981"></a>03981         <span class="keywordflow">return</span> yyflag;
<a name="l03982"></a>03982       <span class="keywordflow">if</span> (! yys-&gt;<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a>)
<a name="l03983"></a>03983         {
<a name="l03984"></a>03984           yyflag = yyresolveValue (yys-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a>, yystack,
<a name="l03985"></a>03985                                    &amp;yys-&gt;<a class="code" href="structyyGLRState.html#0787e47fc93c6580b70867d7b81a9e4a">yysemantics</a>.<a class="code" href="structyyGLRState.html#6b9130ce09b81165144a1b3a832fbaf6">yysval</a>, &amp;yys-&gt;<a class="code" href="structyyGLRState.html#c6143618fb4276d3f8d6030b2f61f26d">yyloc</a>
<a name="l03986"></a>03986                                   );
<a name="l03987"></a>03987           <span class="keywordflow">if</span> (yyflag != yyok)
<a name="l03988"></a>03988             <span class="keywordflow">return</span> yyflag;
<a name="l03989"></a>03989           yys-&gt;<a class="code" href="structyyGLRState.html#a1d02568620891777e1018dfead1d7c1">yyresolved</a> = yytrue;
<a name="l03990"></a>03990         }
<a name="l03991"></a>03991     }
<a name="l03992"></a>03992   <span class="keywordflow">return</span> yyok;
<a name="l03993"></a>03993 }
<a name="l03994"></a>03994 
<a name="l03995"></a>03995 <span class="keyword">static</span> YYRESULTTAG
<a name="l03996"></a>03996 yyresolveAction (yySemanticOption* yyopt, yyGLRStack* yystack,
<a name="l03997"></a>03997                  YYSTYPE* yyvalp, <a class="code" href="structYYLTYPE.html">YYLTYPE</a>* yylocp)
<a name="l03998"></a>03998 {
<a name="l03999"></a>03999   yyGLRStackItem yyrhsVals[YYMAXRHS + YYMAXLEFT + 1];
<a name="l04000"></a>04000   <span class="keywordtype">int</span> yynrhs;
<a name="l04001"></a>04001 
<a name="l04002"></a>04002   yynrhs = yyrhsLength (yyopt-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>);
<a name="l04003"></a>04003   YYCHK (yyresolveStates (yyopt-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>, yynrhs, yystack));
<a name="l04004"></a>04004   yyrhsVals[YYMAXRHS + YYMAXLEFT].<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a> = yyopt-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>;
<a name="l04005"></a>04005   <span class="keywordflow">return</span> yyuserAction (yyopt-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>, yynrhs,
<a name="l04006"></a>04006                        yyrhsVals + YYMAXRHS + YYMAXLEFT - 1,
<a name="l04007"></a>04007                        yyvalp, yylocp, yystack);
<a name="l04008"></a>04008 }
<a name="l04009"></a>04009 
<a name="l04010"></a>04010 <span class="preprocessor">#if YYDEBUG</span>
<a name="l04011"></a>04011 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04012"></a>04012 yyreportTree (yySemanticOption* yyx, <span class="keywordtype">int</span> yyindent)
<a name="l04013"></a>04013 {
<a name="l04014"></a>04014   <span class="keywordtype">int</span> yynrhs = yyrhsLength (yyx-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>);
<a name="l04015"></a>04015   <span class="keywordtype">int</span> yyi;
<a name="l04016"></a>04016   yyGLRState* yys;
<a name="l04017"></a>04017   yyGLRState* yystates[YYMAXRHS];
<a name="l04018"></a>04018   yyGLRState yyleftmost_state;
<a name="l04019"></a>04019 
<a name="l04020"></a>04020   <span class="keywordflow">for</span> (yyi = yynrhs, yys = yyx-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>; 0 &lt; yyi; yyi -= 1, yys = yys-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>)
<a name="l04021"></a>04021     yystates[yyi] = yys;
<a name="l04022"></a>04022   <span class="keywordflow">if</span> (yys == NULL)
<a name="l04023"></a>04023     {
<a name="l04024"></a>04024       yyleftmost_state.<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a> = 0;
<a name="l04025"></a>04025       yystates[0] = &amp;yyleftmost_state;
<a name="l04026"></a>04026     }
<a name="l04027"></a>04027   <span class="keywordflow">else</span>
<a name="l04028"></a>04028     yystates[0] = yys;
<a name="l04029"></a>04029 
<a name="l04030"></a>04030   <span class="keywordflow">if</span> (yyx-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a> &lt; yys-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a> + 1)
<a name="l04031"></a>04031     YYFPRINTF (stderr, <span class="stringliteral">"%*s%s -&gt; &lt;Rule %d, empty&gt;\n"</span>,
<a name="l04032"></a>04032                yyindent, <span class="stringliteral">""</span>, yytokenName (yylhsNonterm (yyx-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>)),
<a name="l04033"></a>04033                yyx-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>);
<a name="l04034"></a>04034   <span class="keywordflow">else</span>
<a name="l04035"></a>04035     YYFPRINTF (stderr, <span class="stringliteral">"%*s%s -&gt; &lt;Rule %d, tokens %lu .. %lu&gt;\n"</span>,
<a name="l04036"></a>04036                yyindent, <span class="stringliteral">""</span>, yytokenName (yylhsNonterm (yyx-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>)),
<a name="l04037"></a>04037                yyx-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) (yys-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a> + 1),
<a name="l04038"></a>04038                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyx-&gt;<a class="code" href="structyySemanticOption.html#e7db40c9a568a62ba5ae2bf247f9772b">yystate</a>-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a>);
<a name="l04039"></a>04039   <span class="keywordflow">for</span> (yyi = 1; yyi &lt;= yynrhs; yyi += 1)
<a name="l04040"></a>04040     {
<a name="l04041"></a>04041       <span class="keywordflow">if</span> (yystates[yyi]-&gt;yyresolved)
<a name="l04042"></a>04042         {
<a name="l04043"></a>04043           <span class="keywordflow">if</span> (yystates[yyi-1]-&gt;yyposn+1 &gt; yystates[yyi]-&gt;yyposn)
<a name="l04044"></a>04044             YYFPRINTF (stderr, <span class="stringliteral">"%*s%s &lt;empty&gt;\n"</span>, yyindent+2, <span class="stringliteral">""</span>,
<a name="l04045"></a>04045                        yytokenName (yyrhs[yyprhs[yyx-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>]+yyi-1]));
<a name="l04046"></a>04046           <span class="keywordflow">else</span>
<a name="l04047"></a>04047             YYFPRINTF (stderr, <span class="stringliteral">"%*s%s &lt;tokens %lu .. %lu&gt;\n"</span>, yyindent+2, <span class="stringliteral">""</span>,
<a name="l04048"></a>04048                        yytokenName (yyrhs[yyprhs[yyx-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>]+yyi-1]),
<a name="l04049"></a>04049                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) (yystates[yyi - 1]-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a> + 1),
<a name="l04050"></a>04050                        (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yystates[yyi]-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a>);
<a name="l04051"></a>04051         }
<a name="l04052"></a>04052       <span class="keywordflow">else</span>
<a name="l04053"></a>04053         yyreportTree (yystates[yyi]-&gt;yysemantics.<a class="code" href="structyyGLRState.html#9094e3f2dfd19aff831da15728a2c6d8">yyfirstVal</a>, yyindent+2);
<a name="l04054"></a>04054     }
<a name="l04055"></a>04055 }
<a name="l04056"></a>04056 <span class="preprocessor">#endif</span>
<a name="l04057"></a>04057 <span class="preprocessor"></span>
<a name="l04058"></a>04058 <span class="keyword">static</span> <span class="keywordtype">void</span> yyreportAmbiguity (yySemanticOption* yyx0, yySemanticOption* yyx1,
<a name="l04059"></a>04059                                yyGLRStack* yystack)
<a name="l04060"></a>04060   __attribute__ ((__noreturn__));
<a name="l04061"></a>04061 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04062"></a>04062 yyreportAmbiguity (yySemanticOption* yyx0, yySemanticOption* yyx1,
<a name="l04063"></a>04063                    yyGLRStack* yystack)
<a name="l04064"></a>04064 {
<a name="l04065"></a>04065   <span class="comment">/* `Unused' warnings.  */</span>
<a name="l04066"></a>04066   (void) yyx0;
<a name="l04067"></a>04067   (void) yyx1;
<a name="l04068"></a>04068 
<a name="l04069"></a>04069 <span class="preprocessor">#if YYDEBUG</span>
<a name="l04070"></a>04070 <span class="preprocessor"></span>  YYFPRINTF (stderr, <span class="stringliteral">"Ambiguity detected.\n"</span>);
<a name="l04071"></a>04071   YYFPRINTF (stderr, <span class="stringliteral">"Option 1,\n"</span>);
<a name="l04072"></a>04072   yyreportTree (yyx0, 2);
<a name="l04073"></a>04073   YYFPRINTF (stderr, <span class="stringliteral">"\nOption 2,\n"</span>);
<a name="l04074"></a>04074   yyreportTree (yyx1, 2);
<a name="l04075"></a>04075   YYFPRINTF (stderr, <span class="stringliteral">"\n"</span>);
<a name="l04076"></a>04076 <span class="preprocessor">#endif</span>
<a name="l04077"></a>04077 <span class="preprocessor"></span>  yyFail (yystack, YY_(<span class="stringliteral">"syntax is ambiguous"</span>));
<a name="l04078"></a>04078 }
<a name="l04079"></a>04079 
<a name="l04080"></a>04080 
<a name="l04083"></a>04083 <span class="keyword">static</span> YYRESULTTAG
<a name="l04084"></a>04084 yyresolveValue (yySemanticOption* yyoptionList, yyGLRStack* yystack,
<a name="l04085"></a>04085                 YYSTYPE* yyvalp, <a class="code" href="structYYLTYPE.html">YYLTYPE</a>* yylocp)
<a name="l04086"></a>04086 {
<a name="l04087"></a>04087   yySemanticOption* yybest;
<a name="l04088"></a>04088   yySemanticOption** yypp;
<a name="l04089"></a>04089   yybool yymerge;
<a name="l04090"></a>04090 
<a name="l04091"></a>04091   yybest = yyoptionList;
<a name="l04092"></a>04092   yymerge = yyfalse;
<a name="l04093"></a>04093   <span class="keywordflow">for</span> (yypp = &amp;yyoptionList-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a>; *yypp != NULL; )
<a name="l04094"></a>04094     {
<a name="l04095"></a>04095       yySemanticOption* yyp = *yypp;
<a name="l04096"></a>04096 
<a name="l04097"></a>04097       <span class="keywordflow">if</span> (yyidenticalOptions (yybest, yyp))
<a name="l04098"></a>04098         {
<a name="l04099"></a>04099           yymergeOptionSets (yybest, yyp);
<a name="l04100"></a>04100           *yypp = yyp-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a>;
<a name="l04101"></a>04101         }
<a name="l04102"></a>04102       <span class="keywordflow">else</span>
<a name="l04103"></a>04103         {
<a name="l04104"></a>04104           <span class="keywordflow">switch</span> (yypreference (yybest, yyp))
<a name="l04105"></a>04105             {
<a name="l04106"></a>04106             <span class="keywordflow">case</span> 0:
<a name="l04107"></a>04107               yyreportAmbiguity (yybest, yyp, yystack);
<a name="l04108"></a>04108               <span class="keywordflow">break</span>;
<a name="l04109"></a>04109             <span class="keywordflow">case</span> 1:
<a name="l04110"></a>04110               yymerge = yytrue;
<a name="l04111"></a>04111               <span class="keywordflow">break</span>;
<a name="l04112"></a>04112             <span class="keywordflow">case</span> 2:
<a name="l04113"></a>04113               <span class="keywordflow">break</span>;
<a name="l04114"></a>04114             <span class="keywordflow">case</span> 3:
<a name="l04115"></a>04115               yybest = yyp;
<a name="l04116"></a>04116               yymerge = yyfalse;
<a name="l04117"></a>04117               <span class="keywordflow">break</span>;
<a name="l04118"></a>04118             <span class="keywordflow">default</span>:
<a name="l04119"></a>04119               <span class="comment">/* This cannot happen so it is not worth a YYASSERT (yyfalse),</span>
<a name="l04120"></a>04120 <span class="comment">                 but some compilers complain if the default case is</span>
<a name="l04121"></a>04121 <span class="comment">                 omitted.  */</span>
<a name="l04122"></a>04122               <span class="keywordflow">break</span>;
<a name="l04123"></a>04123             }
<a name="l04124"></a>04124           yypp = &amp;yyp-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a>;
<a name="l04125"></a>04125         }
<a name="l04126"></a>04126     }
<a name="l04127"></a>04127 
<a name="l04128"></a>04128   <span class="keywordflow">if</span> (yymerge)
<a name="l04129"></a>04129     {
<a name="l04130"></a>04130       yySemanticOption* yyp;
<a name="l04131"></a>04131       <span class="keywordtype">int</span> yyprec = yydprec[yybest-&gt;yyrule];
<a name="l04132"></a>04132       YYCHK (yyresolveAction (yybest, yystack, yyvalp, yylocp));
<a name="l04133"></a>04133       <span class="keywordflow">for</span> (yyp = yybest-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a>; yyp != NULL; yyp = yyp-&gt;<a class="code" href="structyySemanticOption.html#080f99284e2f347b3914c8f78e103a49">yynext</a>)
<a name="l04134"></a>04134         {
<a name="l04135"></a>04135           <span class="keywordflow">if</span> (yyprec == yydprec[yyp-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>])
<a name="l04136"></a>04136             {
<a name="l04137"></a>04137               YYSTYPE yyval1;
<a name="l04138"></a>04138               <a class="code" href="structYYLTYPE.html">YYLTYPE</a> yydummy;
<a name="l04139"></a>04139               YYCHK (yyresolveAction (yyp, yystack, &amp;yyval1, &amp;yydummy));
<a name="l04140"></a>04140               yyuserMerge (yymerger[yyp-&gt;<a class="code" href="structyySemanticOption.html#9d991de87f669d1cf858f9a7a1cda24b">yyrule</a>], yyvalp, &amp;yyval1);
<a name="l04141"></a>04141             }
<a name="l04142"></a>04142         }
<a name="l04143"></a>04143       <span class="keywordflow">return</span> yyok;
<a name="l04144"></a>04144     }
<a name="l04145"></a>04145   <span class="keywordflow">else</span>
<a name="l04146"></a>04146     <span class="keywordflow">return</span> yyresolveAction (yybest, yystack, yyvalp, yylocp);
<a name="l04147"></a>04147 }
<a name="l04148"></a>04148 
<a name="l04149"></a>04149 <span class="keyword">static</span> YYRESULTTAG
<a name="l04150"></a>04150 yyresolveStack (yyGLRStack* yystack)
<a name="l04151"></a>04151 {
<a name="l04152"></a>04152   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> != NULL)
<a name="l04153"></a>04153     {
<a name="l04154"></a>04154       yyGLRState* yys;
<a name="l04155"></a>04155       <span class="keywordtype">int</span> yyn;
<a name="l04156"></a>04156 
<a name="l04157"></a>04157       <span class="keywordflow">for</span> (yyn = 0, yys = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[0];
<a name="l04158"></a>04158            yys != yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a>;
<a name="l04159"></a>04159            yys = yys-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>, yyn += 1)
<a name="l04160"></a>04160         <span class="keywordflow">continue</span>;
<a name="l04161"></a>04161       YYCHK (yyresolveStates (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[0], yyn, yystack
<a name="l04162"></a>04162                              ));
<a name="l04163"></a>04163     }
<a name="l04164"></a>04164   <span class="keywordflow">return</span> yyok;
<a name="l04165"></a>04165 }
<a name="l04166"></a>04166 
<a name="l04167"></a>04167 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04168"></a>04168 yycompressStack (yyGLRStack* yystack)
<a name="l04169"></a>04169 {
<a name="l04170"></a>04170   yyGLRState* yyp, *yyq, *yyr;
<a name="l04171"></a>04171 
<a name="l04172"></a>04172   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a> != 1 || yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> == NULL)
<a name="l04173"></a>04173     <span class="keywordflow">return</span>;
<a name="l04174"></a>04174 
<a name="l04175"></a>04175   <span class="keywordflow">for</span> (yyp = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[0], yyq = yyp-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>, yyr = NULL;
<a name="l04176"></a>04176        yyp != yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a>;
<a name="l04177"></a>04177        yyr = yyp, yyp = yyq, yyq = yyp-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>)
<a name="l04178"></a>04178     yyp-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a> = yyr;
<a name="l04179"></a>04179 
<a name="l04180"></a>04180   yystack-&gt;<a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a> += yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a> - yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>;
<a name="l04181"></a>04181   yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a> = ((yyGLRStackItem*) yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a>) + 1;
<a name="l04182"></a>04182   yystack-&gt;<a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a> -= yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a> - yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>;
<a name="l04183"></a>04183   yystack-&gt;<a class="code" href="structyyGLRStack.html#c68e5f71594e3c4bea86dcd0d9b86779">yysplitPoint</a> = NULL;
<a name="l04184"></a>04184   yystack-&gt;<a class="code" href="structyyGLRStack.html#142add5df99046684b32fc4a1aaff471">yylastDeleted</a> = NULL;
<a name="l04185"></a>04185 
<a name="l04186"></a>04186   <span class="keywordflow">while</span> (yyr != NULL)
<a name="l04187"></a>04187     {
<a name="l04188"></a>04188       yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a>-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a> = *yyr;
<a name="l04189"></a>04189       yyr = yyr-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>;
<a name="l04190"></a>04190       yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a>-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>.<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a> = &amp; yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a>[-1].<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>;
<a name="l04191"></a>04191       yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[0] = &amp;yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a>-&gt;<a class="code" href="unionyyGLRStackItem.html#74dc73f93a0ff87bb28cf8bce78b9a37">yystate</a>;
<a name="l04192"></a>04192       yystack-&gt;<a class="code" href="structyyGLRStack.html#a9e4355b838328a166af140c504294bc">yynextFree</a> += 1;
<a name="l04193"></a>04193       yystack-&gt;<a class="code" href="structyyGLRStack.html#682c5de5e4664c6e4cc1d9e880139d98">yyspaceLeft</a> -= 1;
<a name="l04194"></a>04194     }
<a name="l04195"></a>04195 }
<a name="l04196"></a>04196 
<a name="l04197"></a>04197 <span class="keyword">static</span> YYRESULTTAG
<a name="l04198"></a>04198 yyprocessOneStack (yyGLRStack* yystack, size_t yyk,
<a name="l04199"></a>04199                    size_t yyposn, YYSTYPE* yylvalp, <a class="code" href="structYYLTYPE.html">YYLTYPE</a>* yyllocp
<a name="l04200"></a>04200                   )
<a name="l04201"></a>04201 {
<a name="l04202"></a>04202   <span class="keywordtype">int</span> yyaction;
<a name="l04203"></a>04203   <span class="keyword">const</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span>* yyconflicts;
<a name="l04204"></a>04204   yyRuleNum yyrule;
<a name="l04205"></a>04205   yySymbol* <span class="keyword">const</span> yytokenp = yystack-&gt;<a class="code" href="structyyGLRStack.html#37f2d643591b4f494ada5e3e96dcf873">yytokenp</a>;
<a name="l04206"></a>04206 
<a name="l04207"></a>04207   <span class="keywordflow">while</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk] != NULL)
<a name="l04208"></a>04208     {
<a name="l04209"></a>04209       yyStateNum yystate = yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk]-&gt;<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>;
<a name="l04210"></a>04210       YYDPRINTF ((stderr, <span class="stringliteral">"Stack %lu Entering state %d\n"</span>,
<a name="l04211"></a>04211                   (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyk, yystate));
<a name="l04212"></a>04212 
<a name="l04213"></a>04213       YYASSERT (yystate != YYFINAL);
<a name="l04214"></a>04214 
<a name="l04215"></a>04215       <span class="keywordflow">if</span> (yyisDefaultedState (yystate))
<a name="l04216"></a>04216         {
<a name="l04217"></a>04217           yyrule = yydefaultAction (yystate);
<a name="l04218"></a>04218           <span class="keywordflow">if</span> (yyrule == 0)
<a name="l04219"></a>04219             {
<a name="l04220"></a>04220               YYDPRINTF ((stderr, <span class="stringliteral">"Stack %lu dies.\n"</span>,
<a name="l04221"></a>04221                           (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyk));
<a name="l04222"></a>04222               yymarkStackDeleted (yystack, yyk);
<a name="l04223"></a>04223               <span class="keywordflow">return</span> yyok;
<a name="l04224"></a>04224             }
<a name="l04225"></a>04225           YYCHK (yyglrReduce (yystack, yyk, yyrule, yyfalse));
<a name="l04226"></a>04226         }
<a name="l04227"></a>04227       <span class="keywordflow">else</span>
<a name="l04228"></a>04228         {
<a name="l04229"></a>04229           <span class="keywordflow">if</span> (*yytokenp == YYEMPTY)
<a name="l04230"></a>04230             {
<a name="l04231"></a>04231               YYDPRINTF ((stderr, <span class="stringliteral">"Reading a token: "</span>));
<a name="l04232"></a>04232               yychar = YYLEX;
<a name="l04233"></a>04233               *yytokenp = YYTRANSLATE (yychar);
<a name="l04234"></a>04234               YY_SYMBOL_PRINT (<span class="stringliteral">"Next token is"</span>, *yytokenp, yylvalp, yyllocp);
<a name="l04235"></a>04235             }
<a name="l04236"></a>04236           yygetLRActions (yystate, *yytokenp, &amp;yyaction, &amp;yyconflicts);
<a name="l04237"></a>04237 
<a name="l04238"></a>04238           <span class="keywordflow">while</span> (*yyconflicts != 0)
<a name="l04239"></a>04239             {
<a name="l04240"></a>04240               size_t yynewStack = yysplitStack (yystack, yyk);
<a name="l04241"></a>04241               YYDPRINTF ((stderr, <span class="stringliteral">"Splitting off stack %lu from %lu.\n"</span>,
<a name="l04242"></a>04242                           (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yynewStack,
<a name="l04243"></a>04243                           (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyk));
<a name="l04244"></a>04244               YYCHK (yyglrReduce (yystack, yynewStack,
<a name="l04245"></a>04245                                   *yyconflicts, yyfalse));
<a name="l04246"></a>04246               YYCHK (yyprocessOneStack (yystack, yynewStack, yyposn,
<a name="l04247"></a>04247                                         yylvalp, yyllocp));
<a name="l04248"></a>04248               yyconflicts += 1;
<a name="l04249"></a>04249             }
<a name="l04250"></a>04250 
<a name="l04251"></a>04251           <span class="keywordflow">if</span> (yyisShiftAction (yyaction))
<a name="l04252"></a>04252             {
<a name="l04253"></a>04253               YYDPRINTF ((stderr, <span class="stringliteral">"On stack %lu, "</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyk));
<a name="l04254"></a>04254               YY_SYMBOL_PRINT (<span class="stringliteral">"shifting"</span>, *yytokenp, yylvalp, yyllocp);
<a name="l04255"></a>04255               yyglrShift (yystack, yyk, yyaction, yyposn+1,
<a name="l04256"></a>04256                           *yylvalp, yyllocp);
<a name="l04257"></a>04257               YYDPRINTF ((stderr, <span class="stringliteral">"Stack %lu now in state #%d\n"</span>,
<a name="l04258"></a>04258                           (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyk,
<a name="l04259"></a>04259                           yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk]-&gt;<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>));
<a name="l04260"></a>04260               <span class="keywordflow">break</span>;
<a name="l04261"></a>04261             }
<a name="l04262"></a>04262           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (yyisErrorAction (yyaction))
<a name="l04263"></a>04263             {
<a name="l04264"></a>04264               YYDPRINTF ((stderr, <span class="stringliteral">"Stack %lu dies.\n"</span>,
<a name="l04265"></a>04265                           (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyk));
<a name="l04266"></a>04266               yymarkStackDeleted (yystack, yyk);
<a name="l04267"></a>04267               <span class="keywordflow">break</span>;
<a name="l04268"></a>04268             }
<a name="l04269"></a>04269           <span class="keywordflow">else</span>
<a name="l04270"></a>04270             YYCHK (yyglrReduce (yystack, yyk, -yyaction, yyfalse));
<a name="l04271"></a>04271         }
<a name="l04272"></a>04272     }
<a name="l04273"></a>04273   <span class="keywordflow">return</span> yyok;
<a name="l04274"></a>04274 }
<a name="l04275"></a>04275 
<a name="l04276"></a>04276 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04277"></a>04277 yyreportSyntaxError (yyGLRStack* yystack,
<a name="l04278"></a>04278                      YYSTYPE* yylvalp, <a class="code" href="structYYLTYPE.html">YYLTYPE</a>* yyllocp)
<a name="l04279"></a>04279 {
<a name="l04280"></a>04280   <span class="comment">/* `Unused' warnings. */</span>
<a name="l04281"></a>04281   (void) yylvalp;
<a name="l04282"></a>04282   (void) yyllocp;
<a name="l04283"></a>04283 
<a name="l04284"></a>04284   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#ed6f3ec7244916a7970aefd460d1b9bd">yyerrState</a> == 0)
<a name="l04285"></a>04285     {
<a name="l04286"></a>04286 <span class="preprocessor">#if YYERROR_VERBOSE</span>
<a name="l04287"></a>04287 <span class="preprocessor"></span>      yySymbol* <span class="keyword">const</span> yytokenp = yystack-&gt;<a class="code" href="structyyGLRStack.html#37f2d643591b4f494ada5e3e96dcf873">yytokenp</a>;
<a name="l04288"></a>04288       <span class="keywordtype">int</span> yyn;
<a name="l04289"></a>04289       yyn = yypact[yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[0]-&gt;<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>];
<a name="l04290"></a>04290       <span class="keywordflow">if</span> (YYPACT_NINF &lt; yyn &amp;&amp; yyn &lt; YYLAST)
<a name="l04291"></a>04291         {
<a name="l04292"></a>04292           size_t yysize0 = yytnamerr (NULL, yytokenName (*yytokenp));
<a name="l04293"></a>04293           size_t yysize = yysize0;
<a name="l04294"></a>04294           size_t yysize1;
<a name="l04295"></a>04295           yybool yysize_overflow = yyfalse;
<a name="l04296"></a>04296           <span class="keywordtype">char</span>* yymsg = NULL;
<a name="l04297"></a>04297           <span class="keyword">enum</span> { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
<a name="l04298"></a>04298           <span class="keywordtype">char</span> <span class="keyword">const</span> *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
<a name="l04299"></a>04299           <span class="keywordtype">int</span> yyx;
<a name="l04300"></a>04300           <span class="keywordtype">char</span> *yyfmt;
<a name="l04301"></a>04301           <span class="keywordtype">char</span> <span class="keyword">const</span> *yyf;
<a name="l04302"></a>04302           <span class="keyword">static</span> <span class="keywordtype">char</span> <span class="keyword">const</span> yyunexpected[] = <span class="stringliteral">"parse error, unexpected %s"</span>;
<a name="l04303"></a>04303           <span class="keyword">static</span> <span class="keywordtype">char</span> <span class="keyword">const</span> yyexpecting[] = <span class="stringliteral">", expecting %s"</span>;
<a name="l04304"></a>04304           <span class="keyword">static</span> <span class="keywordtype">char</span> <span class="keyword">const</span> yyor[] = <span class="stringliteral">" or %s"</span>;
<a name="l04305"></a>04305           <span class="keywordtype">char</span> yyformat[<span class="keyword">sizeof</span> yyunexpected
<a name="l04306"></a>04306                         + <span class="keyword">sizeof</span> yyexpecting - 1
<a name="l04307"></a>04307                         + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
<a name="l04308"></a>04308                            * (<span class="keyword">sizeof</span> yyor - 1))];
<a name="l04309"></a>04309           <span class="keywordtype">char</span> <span class="keyword">const</span> *yyprefix = yyexpecting;
<a name="l04310"></a>04310 
<a name="l04311"></a>04311           <span class="comment">/* Start YYX at -YYN if negative to avoid negative indexes in</span>
<a name="l04312"></a>04312 <span class="comment">             YYCHECK.  */</span>
<a name="l04313"></a>04313           <span class="keywordtype">int</span> yyxbegin = yyn &lt; 0 ? -yyn : 0;
<a name="l04314"></a>04314 
<a name="l04315"></a>04315           <span class="comment">/* Stay within bounds of both yycheck and yytname.  */</span>
<a name="l04316"></a>04316           <span class="keywordtype">int</span> yychecklim = YYLAST - yyn;
<a name="l04317"></a>04317           <span class="keywordtype">int</span> yyxend = yychecklim &lt; YYNTOKENS ? yychecklim : YYNTOKENS;
<a name="l04318"></a>04318           <span class="keywordtype">int</span> yycount = 1;
<a name="l04319"></a>04319 
<a name="l04320"></a>04320           yyarg[0] = yytokenName (*yytokenp);
<a name="l04321"></a>04321           yyfmt = yystpcpy (yyformat, yyunexpected);
<a name="l04322"></a>04322 
<a name="l04323"></a>04323           <span class="keywordflow">for</span> (yyx = yyxbegin; yyx &lt; yyxend; ++yyx)
<a name="l04324"></a>04324             <span class="keywordflow">if</span> (yycheck[yyx + yyn] == yyx &amp;&amp; yyx != YYTERROR)
<a name="l04325"></a>04325               {
<a name="l04326"></a>04326                 <span class="keywordflow">if</span> (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
<a name="l04327"></a>04327                   {
<a name="l04328"></a>04328                     yycount = 1;
<a name="l04329"></a>04329                     yysize = yysize0;
<a name="l04330"></a>04330                     yyformat[<span class="keyword">sizeof</span> yyunexpected - 1] = <span class="charliteral">'\0'</span>;
<a name="l04331"></a>04331                     <span class="keywordflow">break</span>;
<a name="l04332"></a>04332                   }
<a name="l04333"></a>04333                 yyarg[yycount++] = yytokenName (yyx);
<a name="l04334"></a>04334                 yysize1 = yysize + yytnamerr (NULL, yytokenName (yyx));
<a name="l04335"></a>04335                 yysize_overflow |= yysize1 &lt; yysize;
<a name="l04336"></a>04336                 yysize = yysize1;
<a name="l04337"></a>04337                 yyfmt = yystpcpy (yyfmt, yyprefix);
<a name="l04338"></a>04338                 yyprefix = yyor;
<a name="l04339"></a>04339               }
<a name="l04340"></a>04340 
<a name="l04341"></a>04341           yyf = YY_(yyformat);
<a name="l04342"></a>04342           yysize1 = yysize + strlen (yyf);
<a name="l04343"></a>04343           yysize_overflow |= yysize1 &lt; yysize;
<a name="l04344"></a>04344           yysize = yysize1;
<a name="l04345"></a>04345 
<a name="l04346"></a>04346           <span class="keywordflow">if</span> (!yysize_overflow)
<a name="l04347"></a>04347             yymsg = (<span class="keywordtype">char</span> *) YYMALLOC (yysize);
<a name="l04348"></a>04348 
<a name="l04349"></a>04349           <span class="keywordflow">if</span> (yymsg)
<a name="l04350"></a>04350             {
<a name="l04351"></a>04351               <span class="keywordtype">char</span> *yyp = yymsg;
<a name="l04352"></a>04352               <span class="keywordtype">int</span> yyi = 0;
<a name="l04353"></a>04353               <span class="keywordflow">while</span> ((*yyp = *yyf))
<a name="l04354"></a>04354                 {
<a name="l04355"></a>04355                   <span class="keywordflow">if</span> (*yyp == <span class="charliteral">'%'</span> &amp;&amp; yyf[1] == <span class="charliteral">'s'</span> &amp;&amp; yyi &lt; yycount)
<a name="l04356"></a>04356                     {
<a name="l04357"></a>04357                       yyp += yytnamerr (yyp, yyarg[yyi++]);
<a name="l04358"></a>04358                       yyf += 2;
<a name="l04359"></a>04359                     }
<a name="l04360"></a>04360                   <span class="keywordflow">else</span>
<a name="l04361"></a>04361                     {
<a name="l04362"></a>04362                       yyp++;
<a name="l04363"></a>04363                       yyf++;
<a name="l04364"></a>04364                     }
<a name="l04365"></a>04365                 }
<a name="l04366"></a>04366               yyerror (yymsg);
<a name="l04367"></a>04367               YYFREE (yymsg);
<a name="l04368"></a>04368             }
<a name="l04369"></a>04369           <span class="keywordflow">else</span>
<a name="l04370"></a>04370             {
<a name="l04371"></a>04371               yyerror (YY_(<span class="stringliteral">"parse error"</span>));
<a name="l04372"></a>04372               yyMemoryExhausted (yystack);
<a name="l04373"></a>04373             }
<a name="l04374"></a>04374         }
<a name="l04375"></a>04375       <span class="keywordflow">else</span>
<a name="l04376"></a>04376 <span class="preprocessor">#endif </span><span class="comment">/* YYERROR_VERBOSE */</span>
<a name="l04377"></a>04377         yyerror (YY_(<span class="stringliteral">"parse error"</span>));
<a name="l04378"></a>04378       yynerrs += 1;
<a name="l04379"></a>04379     }
<a name="l04380"></a>04380 }
<a name="l04381"></a>04381 
<a name="l04382"></a>04382 <span class="comment">/* Recover from a parse error on YYSTACK, assuming that YYTOKENP,</span>
<a name="l04383"></a>04383 <span class="comment">   YYLVALP, and YYLLOCP point to the syntactic category, semantic</span>
<a name="l04384"></a>04384 <span class="comment">   value, and location of the look-ahead.  */</span>
<a name="l04385"></a>04385 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04386"></a>04386 yyrecoverSyntaxError (yyGLRStack* yystack,
<a name="l04387"></a>04387                       YYSTYPE* yylvalp,
<a name="l04388"></a>04388                       <a class="code" href="structYYLTYPE.html">YYLTYPE</a>* YYOPTIONAL_LOC (yyllocp)
<a name="l04389"></a>04389                       )
<a name="l04390"></a>04390 {
<a name="l04391"></a>04391   yySymbol* <span class="keyword">const</span> yytokenp = yystack-&gt;<a class="code" href="structyyGLRStack.html#37f2d643591b4f494ada5e3e96dcf873">yytokenp</a>;
<a name="l04392"></a>04392   size_t yyk;
<a name="l04393"></a>04393   <span class="keywordtype">int</span> yyj;
<a name="l04394"></a>04394 
<a name="l04395"></a>04395   <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#ed6f3ec7244916a7970aefd460d1b9bd">yyerrState</a> == 3)
<a name="l04396"></a>04396     <span class="comment">/* We just shifted the error token and (perhaps) took some</span>
<a name="l04397"></a>04397 <span class="comment">       reductions.  Skip tokens until we can proceed.  */</span>
<a name="l04398"></a>04398     <span class="keywordflow">while</span> (yytrue)
<a name="l04399"></a>04399       {
<a name="l04400"></a>04400         <span class="keywordflow">if</span> (*yytokenp == YYEOF)
<a name="l04401"></a>04401           yyFail (yystack, NULL);
<a name="l04402"></a>04402         <span class="keywordflow">if</span> (*yytokenp != YYEMPTY)
<a name="l04403"></a>04403           {
<a name="l04404"></a>04404             yydestruct (<span class="stringliteral">"Error: discarding"</span>,
<a name="l04405"></a>04405                         *yytokenp, yylvalp);
<a name="l04406"></a>04406           }
<a name="l04407"></a>04407         YYDPRINTF ((stderr, <span class="stringliteral">"Reading a token: "</span>));
<a name="l04408"></a>04408         yychar = YYLEX;
<a name="l04409"></a>04409         *yytokenp = YYTRANSLATE (yychar);
<a name="l04410"></a>04410         YY_SYMBOL_PRINT (<span class="stringliteral">"Next token is"</span>, *yytokenp, yylvalp, yyllocp);
<a name="l04411"></a>04411         yyj = yypact[yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[0]-&gt;<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>];
<a name="l04412"></a>04412         <span class="keywordflow">if</span> (yyis_pact_ninf (yyj))
<a name="l04413"></a>04413           <span class="keywordflow">return</span>;
<a name="l04414"></a>04414         yyj += *yytokenp;
<a name="l04415"></a>04415         <span class="keywordflow">if</span> (yyj &lt; 0 || YYLAST &lt; yyj || yycheck[yyj] != *yytokenp)
<a name="l04416"></a>04416           {
<a name="l04417"></a>04417             <span class="keywordflow">if</span> (yydefact[yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[0]-&gt;<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>] != 0)
<a name="l04418"></a>04418               <span class="keywordflow">return</span>;
<a name="l04419"></a>04419           }
<a name="l04420"></a>04420         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (yytable[yyj] != 0 &amp;&amp; ! yyis_table_ninf (yytable[yyj]))
<a name="l04421"></a>04421           <span class="keywordflow">return</span>;
<a name="l04422"></a>04422       }
<a name="l04423"></a>04423 
<a name="l04424"></a>04424   <span class="comment">/* Reduce to one stack.  */</span>
<a name="l04425"></a>04425   <span class="keywordflow">for</span> (yyk = 0; yyk &lt; yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a>; yyk += 1)
<a name="l04426"></a>04426     <span class="keywordflow">if</span> (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk] != NULL)
<a name="l04427"></a>04427       <span class="keywordflow">break</span>;
<a name="l04428"></a>04428   if (yyk &gt;= yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a>)
<a name="l04429"></a>04429     yyFail (yystack, NULL);
<a name="l04430"></a>04430   <span class="keywordflow">for</span> (yyk += 1; yyk &lt; yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a>; yyk += 1)
<a name="l04431"></a>04431     yymarkStackDeleted (yystack, yyk);
<a name="l04432"></a>04432   yyremoveDeletes (yystack);
<a name="l04433"></a>04433   yycompressStack (yystack);
<a name="l04434"></a>04434 
<a name="l04435"></a>04435   <span class="comment">/* Now pop stack until we find a state that shifts the error token. */</span>
<a name="l04436"></a>04436   yystack-&gt;yyerrState = 3;
<a name="l04437"></a>04437   <span class="keywordflow">while</span> (yystack-&gt;yytops.yystates[0] != NULL)
<a name="l04438"></a>04438     {
<a name="l04439"></a>04439       yyGLRState *yys = yystack-&gt;yytops.yystates[0];
<a name="l04440"></a>04440       yyj = yypact[yys-&gt;<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>];
<a name="l04441"></a>04441       <span class="keywordflow">if</span> (! yyis_pact_ninf (yyj))
<a name="l04442"></a>04442         {
<a name="l04443"></a>04443           yyj += YYTERROR;
<a name="l04444"></a>04444           <span class="keywordflow">if</span> (0 &lt;= yyj &amp;&amp; yyj &lt;= YYLAST &amp;&amp; yycheck[yyj] == YYTERROR
<a name="l04445"></a>04445               &amp;&amp; yyisShiftAction (yytable[yyj]))
<a name="l04446"></a>04446             {
<a name="l04447"></a>04447               <span class="comment">/* Shift the error token having adjusted its location.  */</span>
<a name="l04448"></a>04448               <a class="code" href="structYYLTYPE.html">YYLTYPE</a> yyerrloc;
<a name="l04449"></a>04449               YY_SYMBOL_PRINT (<span class="stringliteral">"Shifting"</span>, yystos[yytable[yyj]],
<a name="l04450"></a>04450                                yylvalp, &amp;yyerrloc);
<a name="l04451"></a>04451               yyglrShift (yystack, 0, yytable[yyj],
<a name="l04452"></a>04452                           yys-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a>, *yylvalp, &amp;yyerrloc);
<a name="l04453"></a>04453               yys = yystack-&gt;yytops.yystates[0];
<a name="l04454"></a>04454               <span class="keywordflow">break</span>;
<a name="l04455"></a>04455             }
<a name="l04456"></a>04456         }
<a name="l04457"></a>04457 
<a name="l04458"></a>04458       yydestroyGLRState (<span class="stringliteral">"Error: popping"</span>, yys);
<a name="l04459"></a>04459       yystack-&gt;yytops.yystates[0] = yys-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>;
<a name="l04460"></a>04460       yystack-&gt;yynextFree -= 1;
<a name="l04461"></a>04461       yystack-&gt;yyspaceLeft += 1;
<a name="l04462"></a>04462     }
<a name="l04463"></a>04463   <span class="keywordflow">if</span> (yystack-&gt;yytops.yystates[0] == NULL)
<a name="l04464"></a>04464     yyFail (yystack, NULL);
<a name="l04465"></a>04465 }
<a name="l04466"></a>04466 
<a name="l04467"></a>04467 <span class="preprocessor">#define YYCHK1(YYE)                                                          \</span>
<a name="l04468"></a>04468 <span class="preprocessor">  do {                                                                       \</span>
<a name="l04469"></a>04469 <span class="preprocessor">    switch (YYE) {                                                           \</span>
<a name="l04470"></a>04470 <span class="preprocessor">    case yyok:                                                               \</span>
<a name="l04471"></a>04471 <span class="preprocessor">      break;                                                                 \</span>
<a name="l04472"></a>04472 <span class="preprocessor">    case yyabort:                                                            \</span>
<a name="l04473"></a>04473 <span class="preprocessor">      goto yyabortlab;                                                       \</span>
<a name="l04474"></a>04474 <span class="preprocessor">    case yyaccept:                                                           \</span>
<a name="l04475"></a>04475 <span class="preprocessor">      goto yyacceptlab;                                                      \</span>
<a name="l04476"></a>04476 <span class="preprocessor">    case yyerr:                                                              \</span>
<a name="l04477"></a>04477 <span class="preprocessor">      goto yyuser_error;                                                     \</span>
<a name="l04478"></a>04478 <span class="preprocessor">    default:                                                                 \</span>
<a name="l04479"></a>04479 <span class="preprocessor">      goto yybuglab;                                                         \</span>
<a name="l04480"></a>04480 <span class="preprocessor">    }                                                                        \</span>
<a name="l04481"></a>04481 <span class="preprocessor">  } while (0)</span>
<a name="l04482"></a>04482 <span class="preprocessor"></span>
<a name="l04483"></a>04483 
<a name="l04484"></a>04484 <span class="comment">/*----------.</span>
<a name="l04485"></a>04485 <span class="comment">| yyparse.  |</span>
<a name="l04486"></a>04486 <span class="comment">`----------*/</span>
<a name="l04487"></a>04487 
<a name="l04488"></a>04488 <span class="keywordtype">int</span>
<a name="l04489"></a>04489 yyparse (<span class="keywordtype">void</span>)
<a name="l04490"></a>04490 {
<a name="l04491"></a>04491   <span class="keywordtype">int</span> yyresult;
<a name="l04492"></a>04492   yySymbol yytoken;
<a name="l04493"></a>04493   yyGLRStack yystack;
<a name="l04494"></a>04494   size_t yyposn;
<a name="l04495"></a>04495 
<a name="l04496"></a>04496 
<a name="l04497"></a>04497   YYSTYPE* <span class="keyword">const</span> yylvalp = &amp;yylval;
<a name="l04498"></a>04498   <a class="code" href="structYYLTYPE.html">YYLTYPE</a>* <span class="keyword">const</span> yyllocp = &amp;yylloc;
<a name="l04499"></a>04499 
<a name="l04500"></a>04500   YYDPRINTF ((stderr, <span class="stringliteral">"Starting parse\n"</span>));
<a name="l04501"></a>04501 
<a name="l04502"></a>04502   yytoken = YYEMPTY;
<a name="l04503"></a>04503   yylval = yyval_default;
<a name="l04504"></a>04504 
<a name="l04505"></a>04505 
<a name="l04506"></a>04506   <span class="keywordflow">if</span> (! yyinitGLRStack (&amp;yystack, YYINITDEPTH))
<a name="l04507"></a>04507     <span class="keywordflow">goto</span> yyexhaustedlab;
<a name="l04508"></a>04508   <span class="keywordflow">switch</span> (YYSETJMP (yystack.yyexception_buffer))
<a name="l04509"></a>04509     {
<a name="l04510"></a>04510     <span class="keywordflow">case</span> 0: <span class="keywordflow">break</span>;
<a name="l04511"></a>04511     <span class="keywordflow">case</span> 1: <span class="keywordflow">goto</span> yyabortlab;
<a name="l04512"></a>04512     <span class="keywordflow">case</span> 2: <span class="keywordflow">goto</span> yyexhaustedlab;
<a name="l04513"></a>04513     <span class="keywordflow">default</span>: <span class="keywordflow">goto</span> yybuglab;
<a name="l04514"></a>04514     }
<a name="l04515"></a>04515   yystack.yytokenp = &amp;yytoken;
<a name="l04516"></a>04516   yyglrShift (&amp;yystack, 0, 0, 0, yylval, &amp;yylloc);
<a name="l04517"></a>04517   yyposn = 0;
<a name="l04518"></a>04518 
<a name="l04519"></a>04519   <span class="keywordflow">while</span> (yytrue)
<a name="l04520"></a>04520     {
<a name="l04521"></a>04521       <span class="comment">/* For efficiency, we have two loops, the first of which is</span>
<a name="l04522"></a>04522 <span class="comment">         specialized to deterministic operation (single stack, no</span>
<a name="l04523"></a>04523 <span class="comment">         potential ambiguity).  */</span>
<a name="l04524"></a>04524       <span class="comment">/* Standard mode */</span>
<a name="l04525"></a>04525       <span class="keywordflow">while</span> (yytrue)
<a name="l04526"></a>04526         {
<a name="l04527"></a>04527           yyRuleNum yyrule;
<a name="l04528"></a>04528           <span class="keywordtype">int</span> yyaction;
<a name="l04529"></a>04529           <span class="keyword">const</span> <span class="keywordtype">short</span> <span class="keywordtype">int</span>* yyconflicts;
<a name="l04530"></a>04530 
<a name="l04531"></a>04531           yyStateNum yystate = yystack.yytops.yystates[0]-&gt;yylrState;
<a name="l04532"></a>04532           YYDPRINTF ((stderr, <span class="stringliteral">"Entering state %d\n"</span>, yystate));
<a name="l04533"></a>04533           <span class="keywordflow">if</span> (yystate == YYFINAL)
<a name="l04534"></a>04534             <span class="keywordflow">goto</span> yyacceptlab;
<a name="l04535"></a>04535           <span class="keywordflow">if</span> (yyisDefaultedState (yystate))
<a name="l04536"></a>04536             {
<a name="l04537"></a>04537               yyrule = yydefaultAction (yystate);
<a name="l04538"></a>04538               <span class="keywordflow">if</span> (yyrule == 0)
<a name="l04539"></a>04539                 {
<a name="l04540"></a>04540 
<a name="l04541"></a>04541                   yyreportSyntaxError (&amp;yystack, yylvalp, yyllocp);
<a name="l04542"></a>04542                   <span class="keywordflow">goto</span> yyuser_error;
<a name="l04543"></a>04543                 }
<a name="l04544"></a>04544               YYCHK1 (yyglrReduce (&amp;yystack, 0, yyrule, yytrue));
<a name="l04545"></a>04545             }
<a name="l04546"></a>04546           <span class="keywordflow">else</span>
<a name="l04547"></a>04547             {
<a name="l04548"></a>04548               <span class="keywordflow">if</span> (yytoken == YYEMPTY)
<a name="l04549"></a>04549                 {
<a name="l04550"></a>04550                   YYDPRINTF ((stderr, <span class="stringliteral">"Reading a token: "</span>));
<a name="l04551"></a>04551                   yychar = YYLEX;
<a name="l04552"></a>04552                   yytoken = YYTRANSLATE (yychar);
<a name="l04553"></a>04553                   YY_SYMBOL_PRINT (<span class="stringliteral">"Next token is"</span>, yytoken, yylvalp, yyllocp);
<a name="l04554"></a>04554                 }
<a name="l04555"></a>04555               yygetLRActions (yystate, yytoken, &amp;yyaction, &amp;yyconflicts);
<a name="l04556"></a>04556               <span class="keywordflow">if</span> (*yyconflicts != 0)
<a name="l04557"></a>04557                 <span class="keywordflow">break</span>;
<a name="l04558"></a>04558               <span class="keywordflow">if</span> (yyisShiftAction (yyaction))
<a name="l04559"></a>04559                 {
<a name="l04560"></a>04560                   YY_SYMBOL_PRINT (<span class="stringliteral">"Shifting"</span>, yytoken, yylvalp, yyllocp);
<a name="l04561"></a>04561                   <span class="keywordflow">if</span> (yytoken != YYEOF)
<a name="l04562"></a>04562                     yytoken = YYEMPTY;
<a name="l04563"></a>04563                   yyposn += 1;
<a name="l04564"></a>04564                   yyglrShift (&amp;yystack, 0, yyaction, yyposn, yylval, yyllocp);
<a name="l04565"></a>04565                   <span class="keywordflow">if</span> (0 &lt; yystack.yyerrState)
<a name="l04566"></a>04566                     yystack.yyerrState -= 1;
<a name="l04567"></a>04567                 }
<a name="l04568"></a>04568               <span class="keywordflow">else</span> <span class="keywordflow">if</span> (yyisErrorAction (yyaction))
<a name="l04569"></a>04569                 {
<a name="l04570"></a>04570 
<a name="l04571"></a>04571                   yyreportSyntaxError (&amp;yystack, yylvalp, yyllocp);
<a name="l04572"></a>04572                   <span class="keywordflow">goto</span> yyuser_error;
<a name="l04573"></a>04573                 }
<a name="l04574"></a>04574               <span class="keywordflow">else</span>
<a name="l04575"></a>04575                 YYCHK1 (yyglrReduce (&amp;yystack, 0, -yyaction, yytrue));
<a name="l04576"></a>04576             }
<a name="l04577"></a>04577         }
<a name="l04578"></a>04578 
<a name="l04579"></a>04579       <span class="keywordflow">while</span> (yytrue)
<a name="l04580"></a>04580         {
<a name="l04581"></a>04581           size_t yys;
<a name="l04582"></a>04582           size_t yyn = yystack.yytops.yysize;
<a name="l04583"></a>04583           <span class="keywordflow">for</span> (yys = 0; yys &lt; yyn; yys += 1)
<a name="l04584"></a>04584             YYCHK1 (yyprocessOneStack (&amp;yystack, yys, yyposn,
<a name="l04585"></a>04585                                        yylvalp, yyllocp));
<a name="l04586"></a>04586           yytoken = YYEMPTY;
<a name="l04587"></a>04587           yyposn += 1;
<a name="l04588"></a>04588           yyremoveDeletes (&amp;yystack);
<a name="l04589"></a>04589           <span class="keywordflow">if</span> (yystack.yytops.yysize == 0)
<a name="l04590"></a>04590             {
<a name="l04591"></a>04591               yyundeleteLastStack (&amp;yystack);
<a name="l04592"></a>04592               <span class="keywordflow">if</span> (yystack.yytops.yysize == 0)
<a name="l04593"></a>04593                 yyFail (&amp;yystack, YY_(<span class="stringliteral">"parse error"</span>));
<a name="l04594"></a>04594               YYCHK1 (yyresolveStack (&amp;yystack));
<a name="l04595"></a>04595               YYDPRINTF ((stderr, <span class="stringliteral">"Returning to deterministic operation.\n"</span>));
<a name="l04596"></a>04596 
<a name="l04597"></a>04597               yyreportSyntaxError (&amp;yystack, yylvalp, yyllocp);
<a name="l04598"></a>04598               <span class="keywordflow">goto</span> yyuser_error;
<a name="l04599"></a>04599             }
<a name="l04600"></a>04600           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (yystack.yytops.yysize == 1)
<a name="l04601"></a>04601             {
<a name="l04602"></a>04602               YYCHK1 (yyresolveStack (&amp;yystack));
<a name="l04603"></a>04603               YYDPRINTF ((stderr, <span class="stringliteral">"Returning to deterministic operation.\n"</span>));
<a name="l04604"></a>04604               yycompressStack (&amp;yystack);
<a name="l04605"></a>04605               <span class="keywordflow">break</span>;
<a name="l04606"></a>04606             }
<a name="l04607"></a>04607         }
<a name="l04608"></a>04608       <span class="keywordflow">continue</span>;
<a name="l04609"></a>04609     yyuser_error:
<a name="l04610"></a>04610       yyrecoverSyntaxError (&amp;yystack, yylvalp, yyllocp);
<a name="l04611"></a>04611       yyposn = yystack.yytops.yystates[0]-&gt;yyposn;
<a name="l04612"></a>04612     }
<a name="l04613"></a>04613 
<a name="l04614"></a>04614  yyacceptlab:
<a name="l04615"></a>04615   yyresult = 0;
<a name="l04616"></a>04616   <span class="keywordflow">goto</span> yyreturn;
<a name="l04617"></a>04617 
<a name="l04618"></a>04618  yybuglab:
<a name="l04619"></a>04619   YYASSERT (yyfalse);
<a name="l04620"></a>04620   <span class="comment">/* Fall through.  */</span>
<a name="l04621"></a>04621 
<a name="l04622"></a>04622  yyabortlab:
<a name="l04623"></a>04623   yyresult = 1;
<a name="l04624"></a>04624   <span class="keywordflow">goto</span> yyreturn;
<a name="l04625"></a>04625 
<a name="l04626"></a>04626  yyexhaustedlab:
<a name="l04627"></a>04627   yyerror (YY_(<span class="stringliteral">"memory exhausted"</span>));
<a name="l04628"></a>04628   yyresult = 2;
<a name="l04629"></a>04629   <span class="comment">/* Fall through.  */</span>
<a name="l04630"></a>04630 
<a name="l04631"></a>04631  yyreturn:
<a name="l04632"></a>04632   <span class="keywordflow">if</span> (yytoken != YYEOF &amp;&amp; yytoken != YYEMPTY)
<a name="l04633"></a>04633     yydestruct (<span class="stringliteral">"Cleanup: discarding lookahead"</span>,
<a name="l04634"></a>04634                 yytoken, yylvalp);
<a name="l04635"></a>04635 
<a name="l04636"></a>04636   <span class="comment">/* If the stack is well-formed, pop the stack until it is empty,</span>
<a name="l04637"></a>04637 <span class="comment">     destroying its entries as we go.  But free the stack regardless</span>
<a name="l04638"></a>04638 <span class="comment">     of whether it is well-formed.  */</span>
<a name="l04639"></a>04639   <span class="keywordflow">if</span> (yystack.yyitems)
<a name="l04640"></a>04640     {
<a name="l04641"></a>04641       yyGLRState** yystates = yystack.yytops.yystates;
<a name="l04642"></a>04642       <span class="keywordflow">if</span> (yystates)
<a name="l04643"></a>04643         <span class="keywordflow">while</span> (yystates[0])
<a name="l04644"></a>04644           {
<a name="l04645"></a>04645             yyGLRState *yys = yystates[0];
<a name="l04646"></a>04646             yydestroyGLRState (<span class="stringliteral">"Cleanup: popping"</span>, yys);
<a name="l04647"></a>04647             yystates[0] = yys-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>;
<a name="l04648"></a>04648             yystack.yynextFree -= 1;
<a name="l04649"></a>04649             yystack.yyspaceLeft += 1;
<a name="l04650"></a>04650           }
<a name="l04651"></a>04651       yyfreeGLRStack (&amp;yystack);
<a name="l04652"></a>04652     }
<a name="l04653"></a>04653 
<a name="l04654"></a>04654   <span class="keywordflow">return</span> yyresult;
<a name="l04655"></a>04655 }
<a name="l04656"></a>04656 
<a name="l04657"></a>04657 <span class="comment">/* DEBUGGING ONLY */</span>
<a name="l04658"></a>04658 <span class="preprocessor">#ifdef YYDEBUG</span>
<a name="l04659"></a>04659 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> yypstack (yyGLRStack* yystack, size_t yyk)
<a name="l04660"></a>04660   __attribute__ ((__unused__));
<a name="l04661"></a>04661 <span class="keyword">static</span> <span class="keywordtype">void</span> yypdumpstack (yyGLRStack* yystack) __attribute__ ((__unused__));
<a name="l04662"></a>04662 
<a name="l04663"></a>04663 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04664"></a>04664 yy_yypstack (yyGLRState* yys)
<a name="l04665"></a>04665 {
<a name="l04666"></a>04666   <span class="keywordflow">if</span> (yys-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>)
<a name="l04667"></a>04667     {
<a name="l04668"></a>04668       yy_yypstack (yys-&gt;<a class="code" href="structyyGLRState.html#13e93405d18f40c6bd78e04699327e61">yypred</a>);
<a name="l04669"></a>04669       fprintf (stderr, <span class="stringliteral">" -&gt; "</span>);
<a name="l04670"></a>04670     }
<a name="l04671"></a>04671   fprintf (stderr, <span class="stringliteral">"%d@%lu"</span>, yys-&gt;<a class="code" href="structyyGLRState.html#ccc49d0dd24e0d781b0c3a3212ab1d45">yylrState</a>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yys-&gt;<a class="code" href="structyyGLRState.html#0cb891d9e927c1809a36352034995e10">yyposn</a>);
<a name="l04672"></a>04672 }
<a name="l04673"></a>04673 
<a name="l04674"></a>04674 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04675"></a>04675 yypstates (yyGLRState* yyst)
<a name="l04676"></a>04676 {
<a name="l04677"></a>04677   <span class="keywordflow">if</span> (yyst == NULL)
<a name="l04678"></a>04678     fprintf (stderr, <span class="stringliteral">"&lt;null&gt;"</span>);
<a name="l04679"></a>04679   <span class="keywordflow">else</span>
<a name="l04680"></a>04680     yy_yypstack (yyst);
<a name="l04681"></a>04681   fprintf (stderr, <span class="stringliteral">"\n"</span>);
<a name="l04682"></a>04682 }
<a name="l04683"></a>04683 
<a name="l04684"></a>04684 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04685"></a>04685 yypstack (yyGLRStack* yystack, size_t yyk)
<a name="l04686"></a>04686 {
<a name="l04687"></a>04687   yypstates (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyk]);
<a name="l04688"></a>04688 }
<a name="l04689"></a>04689 
<a name="l04690"></a>04690 <span class="preprocessor">#define YYINDEX(YYX)                                                         \</span>
<a name="l04691"></a>04691 <span class="preprocessor">    ((YYX) == NULL ? -1 : (yyGLRStackItem*) (YYX) - yystack-&gt;yyitems)</span>
<a name="l04692"></a>04692 <span class="preprocessor"></span>
<a name="l04693"></a>04693 
<a name="l04694"></a>04694 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l04695"></a>04695 yypdumpstack (yyGLRStack* yystack)
<a name="l04696"></a>04696 {
<a name="l04697"></a>04697   yyGLRStackItem* yyp;
<a name="l04698"></a>04698   size_t yyi;
<a name="l04699"></a>04699   <span class="keywordflow">for</span> (yyp = yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>; yyp &lt; yystack-&gt;yynextFree; yyp += 1)
<a name="l04700"></a>04700     {
<a name="l04701"></a>04701       fprintf (stderr, <span class="stringliteral">"%3lu. "</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) (yyp - yystack-&gt;<a class="code" href="structyyGLRStack.html#47c85435abcf4c27d4dfef2786e7b69b">yyitems</a>));
<a name="l04702"></a>04702       <span class="keywordflow">if</span> (*(yybool *) yyp)
<a name="l04703"></a>04703         {
<a name="l04704"></a>04704           fprintf (stderr, <span class="stringliteral">"Res: %d, LR State: %d, posn: %lu, pred: %ld"</span>,
<a name="l04705"></a>04705                    yyp-&gt;yystate.yyresolved, yyp-&gt;yystate.yylrState,
<a name="l04706"></a>04706                    (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyp-&gt;yystate.yyposn,
<a name="l04707"></a>04707                    (<span class="keywordtype">long</span> <span class="keywordtype">int</span>) YYINDEX (yyp-&gt;yystate.yypred));
<a name="l04708"></a>04708           <span class="keywordflow">if</span> (! yyp-&gt;yystate.yyresolved)
<a name="l04709"></a>04709             fprintf (stderr, <span class="stringliteral">", firstVal: %ld"</span>,
<a name="l04710"></a>04710                      (<span class="keywordtype">long</span> <span class="keywordtype">int</span>) YYINDEX (yyp-&gt;yystate.yysemantics.yyfirstVal));
<a name="l04711"></a>04711         }
<a name="l04712"></a>04712       <span class="keywordflow">else</span>
<a name="l04713"></a>04713         {
<a name="l04714"></a>04714           fprintf (stderr, <span class="stringliteral">"Option. rule: %d, state: %ld, next: %ld"</span>,
<a name="l04715"></a>04715                    yyp-&gt;yyoption.yyrule,
<a name="l04716"></a>04716                    (<span class="keywordtype">long</span> <span class="keywordtype">int</span>) YYINDEX (yyp-&gt;yyoption.yystate),
<a name="l04717"></a>04717                    (<span class="keywordtype">long</span> <span class="keywordtype">int</span>) YYINDEX (yyp-&gt;yyoption.yynext));
<a name="l04718"></a>04718         }
<a name="l04719"></a>04719       fprintf (stderr, <span class="stringliteral">"\n"</span>);
<a name="l04720"></a>04720     }
<a name="l04721"></a>04721   fprintf (stderr, <span class="stringliteral">"Tops:"</span>);
<a name="l04722"></a>04722   <span class="keywordflow">for</span> (yyi = 0; yyi &lt; yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#3837c4acf1225b4089ba4e91b5638a34">yysize</a>; yyi += 1)
<a name="l04723"></a>04723     fprintf (stderr, <span class="stringliteral">"%lu: %ld; "</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>) yyi,
<a name="l04724"></a>04724              (<span class="keywordtype">long</span> <span class="keywordtype">int</span>) YYINDEX (yystack-&gt;<a class="code" href="structyyGLRStack.html#cde2c59a28317967e930a06a1facaa6a">yytops</a>.<a class="code" href="structyyGLRStateSet.html#ec22ad1a095584003efee3ecbe03093c">yystates</a>[yyi]));
<a name="l04725"></a>04725   fprintf (stderr, <span class="stringliteral">"\n"</span>);
<a name="l04726"></a>04726 }
<a name="l04727"></a>04727 <span class="preprocessor">#endif</span>
<a name="l04728"></a>04728 <span class="preprocessor"></span>
<a name="l04729"></a>04729 
<a name="l04730"></a>04730 <span class="preprocessor">#line 2195 "../src/parser/fol.y"</span>
<a name="l04731"></a>04731 <span class="preprocessor"></span>
<a name="l04732"></a>04732 
<a name="l04733"></a>04733 <span class="comment">/******************* function definitions ****************************/</span>
<a name="l04734"></a>04734 
<a name="l04735"></a>04735   <span class="comment">//warnDuplicates set to true by default</span>
<a name="l04736"></a>04736 <span class="keywordtype">bool</span> runYYParser(<a class="code" href="classMLN.html">MLN</a>* <span class="keyword">const</span> &amp; mln, <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; dom,
<a name="l04737"></a>04737                  <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> &amp; fileName, 
<a name="l04738"></a>04738                  <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; allPredsExceptQueriesAreClosedWorld,
<a name="l04739"></a>04739                  <span class="keyword">const</span> <a class="code" href="classHashArray.html">StringHashArray</a>* <span class="keyword">const</span> &amp; openWorldPredNames,
<a name="l04740"></a>04740                  <span class="keyword">const</span> <a class="code" href="classHashArray.html">StringHashArray</a>* <span class="keyword">const</span> &amp; queryPredNames,
<a name="l04741"></a>04741                  <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; addUnitClauses, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; warnDuplicates,
<a name="l04742"></a>04742                  <span class="keyword">const</span> <span class="keywordtype">double</span>&amp; defaultWt, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; mustHaveWtOrFullStop,
<a name="l04743"></a>04743                  <span class="keyword">const</span> <a class="code" href="classDomain.html">Domain</a>* <span class="keyword">const</span> &amp; domain0, <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; lazyInference,
<a name="l04744"></a>04744                  <span class="keyword">const</span> <span class="keywordtype">bool</span>&amp; flipWtsOfFlippedClause)
<a name="l04745"></a>04745 {
<a name="l04746"></a>04746   zzinit();
<a name="l04747"></a>04747   <span class="keywordflow">if</span> (fileName) { yyin = fopen(fileName, <span class="stringliteral">"r"</span> ); zzinFileName = fileName; }
<a name="l04748"></a>04748   <span class="keywordflow">else</span>            yyin = stdin;
<a name="l04749"></a>04749   <span class="keywordflow">if</span> (yyin == NULL) zzexit(<span class="stringliteral">"Failed to open file %s."</span>, fileName);
<a name="l04750"></a>04750 
<a name="l04751"></a>04751   signal(SIGFPE,zzsigHandler);
<a name="l04752"></a>04752   signal(SIGABRT,zzsigHandler);
<a name="l04753"></a>04753   signal(SIGILL,zzsigHandler);
<a name="l04754"></a>04754   signal(SIGSEGV,zzsigHandler);
<a name="l04755"></a>04755 
<a name="l04756"></a>04756   zzwarnDuplicates = warnDuplicates;
<a name="l04757"></a>04757   zzdefaultWt = defaultWt;
<a name="l04758"></a>04758   zzmustHaveWtOrFullStop = mustHaveWtOrFullStop;
<a name="l04759"></a>04759   zzflipWtsOfFlippedClause = flipWtsOfFlippedClause;
<a name="l04760"></a>04760 
<a name="l04761"></a>04761   ungetc(<span class="charliteral">'\n'</span>, yyin); <span class="comment">// pretend that file begin with a newline</span>
<a name="l04762"></a>04762   zzmln = mln;
<a name="l04763"></a>04763   zzdomain = dom;
<a name="l04764"></a>04764 
<a name="l04765"></a>04765   zzanyTypeId = zzdomain-&gt;<a class="code" href="classDomain.html#2f9db0681da93d0406502d592ec27d63">getTypeId</a>(<a class="code" href="classPredicateTemplate.html#46bde6795534f69dff6b64f4621eb6fc">PredicateTemplate::ANY_TYPE_NAME</a>);
<a name="l04766"></a>04766   zzassert(zzanyTypeId &gt;= 0, <span class="stringliteral">"expecting zzanyTypeId &gt;= 0"</span>);
<a name="l04767"></a>04767 
<a name="l04768"></a>04768   <span class="comment">// Declare internally implemented predicates and functions</span>
<a name="l04769"></a>04769   <span class="comment">//declareInternalPredicatesAndFunctions();</span>
<a name="l04770"></a>04770 
<a name="l04771"></a>04771   zzisParsing = <span class="keyword">true</span>;
<a name="l04772"></a>04772   yyparse();
<a name="l04773"></a>04773   zzisParsing = <span class="keyword">false</span>;
<a name="l04774"></a>04774 
<a name="l04775"></a>04775   zzcheckAllTypesHaveConstants(zzdomain);
<a name="l04776"></a>04776 
<a name="l04777"></a>04777   <span class="comment">// Insert groundings generated from internally implemented functions and predicates</span>
<a name="l04778"></a>04778   zzgenerateGroundingsFromInternalPredicatesAndFunctions();
<a name="l04779"></a>04779 
<a name="l04780"></a>04780   <span class="comment">// Insert groundings generated from linked-in predicates</span>
<a name="l04781"></a>04781   <span class="keywordflow">if</span> (zzusingLinkedPredicates) zzgenerateGroundingsFromLinkedPredicates(zzdomain);
<a name="l04782"></a>04782 
<a name="l04783"></a>04783   <span class="comment">// Insert groundings generated from linked-in functions</span>
<a name="l04784"></a>04784   <span class="keywordflow">if</span> (zzusingLinkedFunctions) zzgenerateGroundingsFromLinkedFunctions(zzdomain);
<a name="l04785"></a>04785 
<a name="l04786"></a>04786   <span class="keywordflow">if</span> (zzok)
<a name="l04787"></a>04787   {
<a name="l04788"></a>04788       <span class="comment">//append the formulas to MLN and set the weights of the hard clauses</span>
<a name="l04789"></a>04789     cout &lt;&lt; <span class="stringliteral">"Adding clauses to MLN..."</span> &lt;&lt; endl;
<a name="l04790"></a>04790     zzappendFormulasToMLN(zzformulaInfos, mln, domain0);
<a name="l04791"></a>04791 
<a name="l04792"></a>04792     <span class="keywordflow">if</span> (addUnitClauses) zzappendUnitClausesToMLN(zzdomain, zzmln, zzdefaultWt);
<a name="l04793"></a>04793 
<a name="l04794"></a>04794     zzmln-&gt;<a class="code" href="classMLN.html#9d46d953f87b69a6951b143bfc814e26">setClauseInfoPriorMeansToClauseWts</a>();
<a name="l04795"></a>04795 
<a name="l04796"></a>04796       <span class="comment">// Change the constant ids so that constants of same type are ordered </span>
<a name="l04797"></a>04797       <span class="comment">// consecutively. Also ensure that the constants in the mln and map is </span>
<a name="l04798"></a>04798       <span class="comment">// consistent with the new constant ids</span>
<a name="l04799"></a>04799     zzdomain-&gt;<a class="code" href="classDomain.html#d6512f35bd6bb6accd1dd9d3ea8e6205">reorderConstants</a>(zzmln, zzpredIdToGndPredMap);
<a name="l04800"></a>04800 
<a name="l04801"></a>04801     zzmln-&gt;<a class="code" href="classMLN.html#b6209baa35bd3ac9c5962c00cdaa6cac">compress</a>();
<a name="l04802"></a>04802 
<a name="l04803"></a>04803     <a class="code" href="classArray.html">Array&lt;bool&gt;</a> isClosedWorldArr; 
<a name="l04804"></a>04804     zzfillClosedWorldArray(isClosedWorldArr,allPredsExceptQueriesAreClosedWorld,
<a name="l04805"></a>04805                            openWorldPredNames, queryPredNames);
<a name="l04806"></a>04806 
<a name="l04807"></a>04807     <a class="code" href="classDatabase.html">Database</a>* db = <span class="keyword">new</span> <a class="code" href="classDatabase.html">Database</a>(zzdomain, isClosedWorldArr, zzstoreGroundPreds);
<a name="l04808"></a>04808     <span class="keywordflow">if</span> (lazyInference) db-&gt;<a class="code" href="classDatabase.html#7dc452829292bf33dbfcbb8316fd9fc9">setLazyFlag</a>();
<a name="l04809"></a>04809     zzaddGndPredsToDb(db);
<a name="l04810"></a>04810     zzdomain-&gt;<a class="code" href="classDomain.html#266c134931ed832093200e4b5bc3e74e">setDB</a>(db);
<a name="l04811"></a>04811     zzdomain-&gt;<a class="code" href="classDomain.html#b70324e4b3124622d71d962ad3ba96d6">compress</a>();
<a name="l04812"></a>04812   }
<a name="l04813"></a>04813   
<a name="l04814"></a>04814   <span class="keywordflow">if</span> (zznumErrors &gt; 0) cout &lt;&lt; <span class="stringliteral">"Num of errors detected = "</span> &lt;&lt; zznumErrors&lt;&lt;endl;
<a name="l04815"></a>04815 
<a name="l04816"></a>04816   zzcleanUp();
<a name="l04817"></a>04817 
<a name="l04818"></a>04818   signal(SIGFPE,SIG_DFL);
<a name="l04819"></a>04819   signal(SIGABRT,SIG_DFL);
<a name="l04820"></a>04820   signal(SIGILL,SIG_DFL);
<a name="l04821"></a>04821   signal(SIGSEGV,SIG_DFL);
<a name="l04822"></a>04822 
<a name="l04823"></a>04823   <span class="keywordflow">return</span> zzok;
<a name="l04824"></a>04824 }
<a name="l04825"></a>04825 
<a name="l04826"></a>04826 
<a name="l04827"></a>04827 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 14 15:15:19 2007 for Alchemy by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
