<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Alchemy: VariableState Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>VariableState Class Reference</h1><!-- doxytag: class="VariableState" -->Represents the state of propositional variables and clauses.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="variablestate_8h-source.html">variablestate.h</a>&gt;</code>
<p>
<a href="classVariableState-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#abd28fc5eef663c5ec3d1e67cd313047">VariableState</a> (<a class="el" href="classHashArray.html">GroundPredicateHashArray</a> *const &amp;unknownQueries, <a class="el" href="classHashArray.html">GroundPredicateHashArray</a> *const &amp;knownQueries, <a class="el" href="classArray.html">Array</a>&lt; TruthValue &gt; *const &amp;knownQueryValues, const <a class="el" href="classArray.html">Array</a>&lt; int &gt; *const &amp;allPredGndingsAreQueries, const bool &amp;markHardGndClauses, const bool &amp;trackParentClauseWts, const <a class="el" href="classMLN.html">MLN</a> *const &amp;mln, const <a class="el" href="classDomain.html">Domain</a> *const &amp;domain, const bool &amp;lazy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for a <a class="el" href="classVariableState.html">VariableState</a>.  <a href="#abd28fc5eef663c5ec3d1e67cd313047"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#42046a00643e0464dcc6798b9c132f63">~VariableState</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#42046a00643e0464dcc6798b9c132f63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#2748a93f222dafedaf7443634e234ddd">addNewClauses</a> (bool initial)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">New clauses are added to the state.  <a href="#2748a93f222dafedaf7443634e234ddd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="78315762db15542e9cdab7753c697e66"></a><!-- doxytag: member="VariableState::init" ref="78315762db15542e9cdab7753c697e66" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#78315762db15542e9cdab7753c697e66">init</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information about the state is reset and initialized. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8f619357092cf7e5ac33d76c9e89afc"></a><!-- doxytag: member="VariableState::reinit" ref="a8f619357092cf7e5ac33d76c9e89afc" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#a8f619357092cf7e5ac33d76c9e89afc">reinit</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">State is re-initialized with all new clauses and atoms. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#38cda38f91fe157e68b0c9c4ce5a20a6">initRandom</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes a random truth assigment to all (active) atoms.  <a href="#38cda38f91fe157e68b0c9c4ce5a20a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="431d61bc9c02ee8e10833d34063ed98e"></a><!-- doxytag: member="VariableState::initBlocksRandom" ref="431d61bc9c02ee8e10833d34063ed98e" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#431d61bc9c02ee8e10833d34063ed98e">initBlocksRandom</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets one atom in each block to true and the rest to false. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c53e96f2f2f3ed8978fae90a7daad36"></a><!-- doxytag: member="VariableState::initMakeBreakCostWatch" ref="2c53e96f2f2f3ed8978fae90a7daad36" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#2c53e96f2f2f3ed8978fae90a7daad36">initMakeBreakCostWatch</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Re-initializes the makeCost, breakCost and watch arrays based on the current variable assignment. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#07b395d520788e7e8f58da07e6327c75">initMakeBreakCostWatch</a> (const int &amp;startClause)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize makeCost and breakCost and watch arrays based on the current variable assignment.  <a href="#07b395d520788e7e8f58da07e6327c75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bc520a99648ee29ef9447b86c26d9faf"></a><!-- doxytag: member="VariableState::getNumAtoms" ref="bc520a99648ee29ef9447b86c26d9faf" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#bc520a99648ee29ef9447b86c26d9faf">getNumAtoms</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="703e262481d6c0b076799511af07df67"></a><!-- doxytag: member="VariableState::getNumClauses" ref="703e262481d6c0b076799511af07df67" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#703e262481d6c0b076799511af07df67">getNumClauses</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fe382d0e9cd941649c330062cc71c8db"></a><!-- doxytag: member="VariableState::getNumDeadClauses" ref="fe382d0e9cd941649c330062cc71c8db" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#fe382d0e9cd941649c330062cc71c8db">getNumDeadClauses</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bfb994798a09590a85c7df10be856828"></a><!-- doxytag: member="VariableState::getIndexOfRandomAtom" ref="bfb994798a09590a85c7df10be856828" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#bfb994798a09590a85c7df10be856828">getIndexOfRandomAtom</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the absolute index of a random atom. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#f25a7b72dbd120a39bdf16a8f5177c0a">getIndexOfAtomInRandomFalseClause</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the absolute index of a random atom in a random unsatisfied pos.  <a href="#f25a7b72dbd120a39bdf16a8f5177c0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#8ebb42420177d489c46c56f2c6e7547a">getRandomFalseClauseIndex</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of a random unsatisfied pos.  <a href="#8ebb42420177d489c46c56f2c6e7547a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d7c8bcbf357de431370e2845019b08e"></a><!-- doxytag: member="VariableState::getCostOfFalseClauses" ref="5d7c8bcbf357de431370e2845019b08e" args="()" -->
long double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#5d7c8bcbf357de431370e2845019b08e">getCostOfFalseClauses</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the cost of the unsatisfied positive and satisfied negative clauses. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f3b4406c82b68fa76396996d9f6878a6"></a><!-- doxytag: member="VariableState::getNumFalseClauses" ref="f3b4406c82b68fa76396996d9f6878a6" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#f3b4406c82b68fa76396996d9f6878a6">getNumFalseClauses</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of the unsatisfied positive and satisfied negative clauses. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#1ad4eb75da5a498f834ce1aafd69f114">getValueOfAtom</a> (const int &amp;atomIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the truth value of an atom.  <a href="#1ad4eb75da5a498f834ce1aafd69f114"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#73ac1309ad13b2e21ff4904cb835610e">getValueOfLowAtom</a> (const int &amp;atomIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the truth value of an atom in the best state.  <a href="#73ac1309ad13b2e21ff4904cb835610e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#5ca24c889ca9ea4ec1ad6fa64b59e348">setValueOfAtom</a> (const int &amp;atomIdx, const bool &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the truth value of an atom.  <a href="#5ca24c889ca9ea4ec1ad6fa64b59e348"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="97f47d59c8ce2f05e2e32c52cadd87c4"></a><!-- doxytag: member="VariableState::getNegOccurenceArray" ref="97f47d59c8ce2f05e2e32c52cadd87c4" args="(const int &amp;atomIdx)" -->
<a class="el" href="classArray.html">Array</a>&lt; int &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#97f47d59c8ce2f05e2e32c52cadd87c4">getNegOccurenceArray</a> (const int &amp;atomIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the negative occurence array of an atom. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="472841bdbf016395d0c6a8fc43f220ff"></a><!-- doxytag: member="VariableState::getPosOccurenceArray" ref="472841bdbf016395d0c6a8fc43f220ff" args="(const int &amp;atomIdx)" -->
<a class="el" href="classArray.html">Array</a>&lt; int &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#472841bdbf016395d0c6a8fc43f220ff">getPosOccurenceArray</a> (const int &amp;atomIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the positive occurence array of an atom. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#a71f608d3613ba9ceae3b0f5e25a61c9">flipAtom</a> (const int &amp;toFlip)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flip the truth value of an atom and update info arrays.  <a href="#a71f608d3613ba9ceae3b0f5e25a61c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#86615cee925136b0b8d9fa9ee553ff10">flipAtomValue</a> (const int &amp;atomIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flips the truth value of an atom.  <a href="#86615cee925136b0b8d9fa9ee553ff10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">long double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#2ec57c8ad6127c24f96263abd8a301bb">getImprovementByFlipping</a> (const int &amp;atomIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the improvement achieved by flipping an atom.  <a href="#2ec57c8ad6127c24f96263abd8a301bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#9082644cc8bc821e0ad8abd85bf11f80">activateAtom</a> (const int &amp;atomIdx, const bool &amp;ignoreActivePreds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If in lazy mode, an atom is activated and all clauses activated by this atom are added to the state.  <a href="#9082644cc8bc821e0ad8abd85bf11f80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#d1809e4857db8f403c53948b0ba9e960">isActive</a> (const int &amp;atomIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if an atom is active.  <a href="#d1809e4857db8f403c53948b0ba9e960"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#d827fe2df8b496ba5ba583514caa89ea">isActive</a> (const <a class="el" href="classPredicate.html">Predicate</a> *pred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if an atom is active.  <a href="#d827fe2df8b496ba5ba583514caa89ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="32dc7e8ae1facd20d885cf6dac4c0028"></a><!-- doxytag: member="VariableState::getOccurenceArray" ref="32dc7e8ae1facd20d885cf6dac4c0028" args="(const int &amp;idx)" -->
<a class="el" href="classArray.html">Array</a>&lt; int &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#32dc7e8ae1facd20d885cf6dac4c0028">getOccurenceArray</a> (const int &amp;idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the occurence array of an atom. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="430605283b71f8a1c2ece97b62f6741f"></a><!-- doxytag: member="VariableState::incrementNumTrueLits" ref="430605283b71f8a1c2ece97b62f6741f" args="(const int &amp;clauseIdx)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#430605283b71f8a1c2ece97b62f6741f">incrementNumTrueLits</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increments the number of true literals in a clause. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="df2045508a3820ac75f02bd297c587f8"></a><!-- doxytag: member="VariableState::decrementNumTrueLits" ref="df2045508a3820ac75f02bd297c587f8" args="(const int &amp;clauseIdx)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#df2045508a3820ac75f02bd297c587f8">decrementNumTrueLits</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrements the number of true literals in a clause. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6a9a11612400d7eebd0c4c50731ee65"></a><!-- doxytag: member="VariableState::getNumTrueLits" ref="b6a9a11612400d7eebd0c4c50731ee65" args="(const int &amp;clauseIdx)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#b6a9a11612400d7eebd0c4c50731ee65">getNumTrueLits</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of true literals in a clause. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce8401a0ed90726319c8d8d15cb5da30"></a><!-- doxytag: member="VariableState::getClauseCost" ref="ce8401a0ed90726319c8d8d15cb5da30" args="(const int &amp;clauseIdx)" -->
long double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#ce8401a0ed90726319c8d8d15cb5da30">getClauseCost</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the cost associated with a clause. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="304eb59515687e3d439fcd2bdc7d071f"></a><!-- doxytag: member="VariableState::getAtomsInClause" ref="304eb59515687e3d439fcd2bdc7d071f" args="(const int &amp;clauseIdx)" -->
<a class="el" href="classArray.html">Array</a>&lt; int &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#304eb59515687e3d439fcd2bdc7d071f">getAtomsInClause</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the atoms in a clauses as an <a class="el" href="classArray.html">Array</a> of ints. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a57ed676fde7a24d57e527756d592bd5"></a><!-- doxytag: member="VariableState::addFalseClause" ref="a57ed676fde7a24d57e527756d592bd5" args="(const int &amp;clauseIdx)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#a57ed676fde7a24d57e527756d592bd5">addFalseClause</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks a clause as false in the state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="324631d59cff78ffd52163f584bd237c"></a><!-- doxytag: member="VariableState::removeFalseClause" ref="324631d59cff78ffd52163f584bd237c" args="(const int &amp;clauseIdx)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#324631d59cff78ffd52163f584bd237c">removeFalseClause</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmarks a clause as false in the state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e598f0dd45da0c61dacebea3871d9581"></a><!-- doxytag: member="VariableState::addBreakCost" ref="e598f0dd45da0c61dacebea3871d9581" args="(const int &amp;atomIdx, const long double &amp;cost)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#e598f0dd45da0c61dacebea3871d9581">addBreakCost</a> (const int &amp;atomIdx, const long double &amp;cost)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increases the breakcost of an atom. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="168251599d33f81bd971d4f6417d7888"></a><!-- doxytag: member="VariableState::subtractBreakCost" ref="168251599d33f81bd971d4f6417d7888" args="(const int &amp;atomIdx, const long double &amp;cost)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#168251599d33f81bd971d4f6417d7888">subtractBreakCost</a> (const int &amp;atomIdx, const long double &amp;cost)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decreases the breakcost of an atom. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#8bda003606fd8a852f44a988124adb19">addBreakCostToAtomsInClause</a> (const int &amp;clauseIdx, const long double &amp;cost)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increases breakCost of all atoms in a given clause.  <a href="#8bda003606fd8a852f44a988124adb19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#875cd0493e8d3ee050ef661ac01a7bcf">subtractBreakCostFromAtomsInClause</a> (const int &amp;clauseIdx, const long double &amp;cost)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decreases breakCost of all atoms in a given clause.  <a href="#875cd0493e8d3ee050ef661ac01a7bcf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#d1574f8f2d9106457d6bb1b2d3282d60">addMakeCost</a> (const int &amp;atomIdx, const long double &amp;cost)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increases makeCost of an atom.  <a href="#d1574f8f2d9106457d6bb1b2d3282d60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#4557a6ec0c103778dea9032a930b8f4e">subtractMakeCost</a> (const int &amp;atomIdx, const long double &amp;cost)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decreases makeCost of an atom.  <a href="#4557a6ec0c103778dea9032a930b8f4e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#189a058bc545cb3f284cf479d45dd6eb">addMakeCostToAtomsInClause</a> (const int &amp;clauseIdx, const long double &amp;cost)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increases makeCost of all atoms in a given clause.  <a href="#189a058bc545cb3f284cf479d45dd6eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#884bd8ade0d0e51f2c300e66eff68fc9">subtractMakeCostFromAtomsInClause</a> (const int &amp;clauseIdx, const long double &amp;cost)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decreases makeCost of all atoms in a given clause.  <a href="#884bd8ade0d0e51f2c300e66eff68fc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#9a385abc27c6cf5d891c52204a8b9faa">getTrueLiteralOtherThan</a> (const int &amp;clauseIdx, const int &amp;atomIdx1, const int &amp;atomIdx2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a true literal in a clause other than the two given.  <a href="#9a385abc27c6cf5d891c52204a8b9faa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6cd0ba26bb4d5c3f7b19d0cd76f3317"></a><!-- doxytag: member="VariableState::isTrueLiteral" ref="a6cd0ba26bb4d5c3f7b19d0cd76f3317" args="(const int &amp;literal)" -->
const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#a6cd0ba26bb4d5c3f7b19d0cd76f3317">isTrueLiteral</a> (const int &amp;literal)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a literal is true (Negated and false or non-negated an true). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b148c43ffe3b2cb5d58a1fcd66e58e23"></a><!-- doxytag: member="VariableState::getAtomInClause" ref="b148c43ffe3b2cb5d58a1fcd66e58e23" args="(const int &amp;atomIdxInClause, const int &amp;clauseIdx)" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#b148c43ffe3b2cb5d58a1fcd66e58e23">getAtomInClause</a> (const int &amp;atomIdxInClause, const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the absolute index of the nth atom in a clause. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7f6f911d7f857cc29b17bc07c36b380"></a><!-- doxytag: member="VariableState::getRandomAtomInClause" ref="a7f6f911d7f857cc29b17bc07c36b380" args="(const int &amp;clauseIdx)" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#a7f6f911d7f857cc29b17bc07c36b380">getRandomAtomInClause</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the absolute index of a random atom in a clause. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#2464e6883cae56360dfdccd4704e9a34">getRandomTrueLitInClause</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the index of a random true literal in a clause.  <a href="#2464e6883cae56360dfdccd4704e9a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7931e1d2b5d6b39bad5109d3574f82be"></a><!-- doxytag: member="VariableState::getMaxClauseWeight" ref="7931e1d2b5d6b39bad5109d3574f82be" args="()" -->
const double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#7931e1d2b5d6b39bad5109d3574f82be">getMaxClauseWeight</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5166274f9edd5ea901f9abf8315843b8"></a><!-- doxytag: member="VariableState::getMakeCost" ref="5166274f9edd5ea901f9abf8315843b8" args="(const int &amp;atomIdx)" -->
const long double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#5166274f9edd5ea901f9abf8315843b8">getMakeCost</a> (const int &amp;atomIdx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4c562c16692e5b895446b9d7f4d23f17"></a><!-- doxytag: member="VariableState::getBreakCost" ref="4c562c16692e5b895446b9d7f4d23f17" args="(const int &amp;atomIdx)" -->
const long double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#4c562c16692e5b895446b9d7f4d23f17">getBreakCost</a> (const int &amp;atomIdx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="12d6e101244182a1962c99cc016f4b78"></a><!-- doxytag: member="VariableState::getClauseSize" ref="12d6e101244182a1962c99cc016f4b78" args="(const int &amp;clauseIdx)" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1ff785b813b350e67466c7210856243e"></a><!-- doxytag: member="VariableState::getWatch1" ref="1ff785b813b350e67466c7210856243e" args="(const int &amp;clauseIdx)" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#1ff785b813b350e67466c7210856243e">getWatch1</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c0823bb22e2680eec885ca035ec17548"></a><!-- doxytag: member="VariableState::setWatch1" ref="c0823bb22e2680eec885ca035ec17548" args="(const int &amp;clauseIdx, const int &amp;atomIdx)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#c0823bb22e2680eec885ca035ec17548">setWatch1</a> (const int &amp;clauseIdx, const int &amp;atomIdx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="04e9c3e0a50b7bdfd04cdc0bafd6906d"></a><!-- doxytag: member="VariableState::getWatch2" ref="04e9c3e0a50b7bdfd04cdc0bafd6906d" args="(const int &amp;clauseIdx)" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#04e9c3e0a50b7bdfd04cdc0bafd6906d">getWatch2</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="575dad9109552494ca6c9a56582844c7"></a><!-- doxytag: member="VariableState::setWatch2" ref="575dad9109552494ca6c9a56582844c7" args="(const int &amp;clauseIdx, const int &amp;atomIdx)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#575dad9109552494ca6c9a56582844c7">setWatch2</a> (const int &amp;clauseIdx, const int &amp;atomIdx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a42f553cdd24e54b7f96f67a1ce138d3"></a><!-- doxytag: member="VariableState::isBlockEvidence" ref="a42f553cdd24e54b7f96f67a1ce138d3" args="(const int &amp;blockIdx)" -->
const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#a42f553cdd24e54b7f96f67a1ce138d3">isBlockEvidence</a> (const int &amp;blockIdx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="783eea1b0ecfd64095ddbb50cbaacb80"></a><!-- doxytag: member="VariableState::getBlockSize" ref="783eea1b0ecfd64095ddbb50cbaacb80" args="(const int &amp;blockIdx)" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#783eea1b0ecfd64095ddbb50cbaacb80">getBlockSize</a> (const int &amp;blockIdx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#48db641f2970801eefcb83a0147d9173">getBlockIndex</a> (const int &amp;atomIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index of the block which the atom with index atomIdx is in.  <a href="#48db641f2970801eefcb83a0147d9173"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="42099717c3620c1806f2a1d6588e27bc"></a><!-- doxytag: member="VariableState::getBlockArray" ref="42099717c3620c1806f2a1d6588e27bc" args="(const int &amp;blockIdx)" -->
<a class="el" href="classArray.html">Array</a>&lt; int &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#42099717c3620c1806f2a1d6588e27bc">getBlockArray</a> (const int &amp;blockIdx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b70bc9bf914ce154f8515715f4cace80"></a><!-- doxytag: member="VariableState::getBlockEvidence" ref="b70bc9bf914ce154f8515715f4cace80" args="(const int &amp;blockIdx)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#b70bc9bf914ce154f8515715f4cace80">getBlockEvidence</a> (const int &amp;blockIdx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5270f9c8fe20d2917f51bfc2a93d4ecb"></a><!-- doxytag: member="VariableState::getNumBlocks" ref="5270f9c8fe20d2917f51bfc2a93d4ecb" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#5270f9c8fe20d2917f51bfc2a93d4ecb">getNumBlocks</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="94db87fa8e1827f8ee9a0ed315d3f606"></a><!-- doxytag: member="VariableState::getLowCost" ref="94db87fa8e1827f8ee9a0ed315d3f606" args="()" -->
const long double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#94db87fa8e1827f8ee9a0ed315d3f606">getLowCost</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the cost of bad clauses in the optimum state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6aef60392382d145d024f6f06e148b2"></a><!-- doxytag: member="VariableState::getLowBad" ref="a6aef60392382d145d024f6f06e148b2" args="()" -->
const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#a6aef60392382d145d024f6f06e148b2">getLowBad</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of bad clauses in the optimum state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#770da3b8b33f4aeff3de22e0ddc451e7">makeUnitCosts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns all costs into units.  <a href="#770da3b8b33f4aeff3de22e0ddc451e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bfbe2f7663f7938cedf0888d5a189712"></a><!-- doxytag: member="VariableState::saveLowState" ref="bfbe2f7663f7938cedf0888d5a189712" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#bfbe2f7663f7938cedf0888d5a189712">saveLowState</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save current assignment as an optimum state. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bec37519e017eb2799b2ec09d0cdf0af"></a><!-- doxytag: member="VariableState::getTrueFixedAtomInBlock" ref="bec37519e017eb2799b2ec09d0cdf0af" args="(const int blockIdx)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#bec37519e017eb2799b2ec09d0cdf0af">getTrueFixedAtomInBlock</a> (const int blockIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns index in block if a true fixed atom is in block, otherwise -1. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fd93e92c1f1a6f906289bc37b0eb5d0f"></a><!-- doxytag: member="VariableState::getGndPredHashArrayPtr" ref="fd93e92c1f1a6f906289bc37b0eb5d0f" args="() const" -->
const <a class="el" href="classHashArray.html">GroundPredicateHashArray</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#fd93e92c1f1a6f906289bc37b0eb5d0f">getGndPredHashArrayPtr</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e86b1ea959f145302a6044f958e195cc"></a><!-- doxytag: member="VariableState::getUnePreds" ref="e86b1ea959f145302a6044f958e195cc" args="() const" -->
const <a class="el" href="classHashArray.html">GroundPredicateHashArray</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#e86b1ea959f145302a6044f958e195cc">getUnePreds</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="919610377b94639dddbb749e348c44cf"></a><!-- doxytag: member="VariableState::getKnePreds" ref="919610377b94639dddbb749e348c44cf" args="() const" -->
const <a class="el" href="classHashArray.html">GroundPredicateHashArray</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#919610377b94639dddbb749e348c44cf">getKnePreds</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b2f6b6972649b634eb1eacce1e3bcda4"></a><!-- doxytag: member="VariableState::getKnePredValues" ref="b2f6b6972649b634eb1eacce1e3bcda4" args="() const" -->
const <a class="el" href="classArray.html">Array</a>&lt; TruthValue &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#b2f6b6972649b634eb1eacce1e3bcda4">getKnePredValues</a> () const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4162873f734b00ff359fa71bd27e1441"></a><!-- doxytag: member="VariableState::setGndClausesWtsToSumOfParentWts" ref="4162873f734b00ff359fa71bd27e1441" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#4162873f734b00ff359fa71bd27e1441">setGndClausesWtsToSumOfParentWts</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the weight of a ground clause to the sum of its parents' weights. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#27096b8568bf1595981b75b2922560e3">getNumClauseGndings</a> (<a class="el" href="classArray.html">Array</a>&lt; double &gt; *const &amp;numGndings, bool tv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of (true or false) clause groundings in this state.  <a href="#27096b8568bf1595981b75b2922560e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#a082702ae807ec09afb99391faf58121">getNumClauseGndings</a> (double numGndings[], int clauseCnt, bool tv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of (true or false) clause groundings in this state.  <a href="#a082702ae807ec09afb99391faf58121"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#a5927ac9488727ae38468de0f1488b6e">getNumClauseGndingsWithUnknown</a> (double numGndings[], int clauseCnt, bool tv, const <a class="el" href="classArray.html">Array</a>&lt; bool &gt; *const &amp;unknownPred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of (true or false) clause groundings in this state.  <a href="#a5927ac9488727ae38468de0f1488b6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#51328d98874eae61096c94b6626f14df">setOthersInBlockToFalse</a> (const int &amp;atomIdx, const int &amp;blockIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the truth values of all atoms in a block except for the one given.  <a href="#51328d98874eae61096c94b6626f14df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#7929d260582cb7cc66fc7af5eb7c359b">fixAtom</a> (const int &amp;atomIdx, const bool &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fixes an atom to a truth value.  <a href="#7929d260582cb7cc66fc7af5eb7c359b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classArray.html">Array</a>&lt; int &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#b80a4267b5c2ea04a786b5dd4c23d879">simplifyClauseFromFixedAtoms</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simplifies a clause using atoms which have been fixed.  <a href="#b80a4267b5c2ea04a786b5dd4c23d879"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#127a243149f859dab21fcfd8279c29ad">isDeadClause</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a clause is dead.  <a href="#127a243149f859dab21fcfd8279c29ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b8fca3de746960f83057feea8cbaeb3"></a><!-- doxytag: member="VariableState::eliminateSoftClauses" ref="1b8fca3de746960f83057feea8cbaeb3" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#1b8fca3de746960f83057feea8cbaeb3">eliminateSoftClauses</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks soft clauses as dead. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#4e30712524da7ecb7b450b98155dd717">killClauses</a> (const int &amp;startClause)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks clauses as dead which were not good in the previous iteration of inference or are not picked according to a weighted coin flip.  <a href="#4e30712524da7ecb7b450b98155dd717"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#e337445a944f87ab57d255fcf7fee119">clauseGoodInPrevious</a> (const int &amp;clauseIdx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks if a clause was good in the previous iteration of inference, i.e.  <a href="#e337445a944f87ab57d255fcf7fee119"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="350c294f81bd00d994fe92b1ed8f0f6f"></a><!-- doxytag: member="VariableState::resetDeadClauses" ref="350c294f81bd00d994fe92b1ed8f0f6f" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#350c294f81bd00d994fe92b1ed8f0f6f">resetDeadClauses</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets all dead clauses to be alive again. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b2cb3ec1d58399e4f4ae544c504a6a20"></a><!-- doxytag: member="VariableState::resetFixedAtoms" ref="b2cb3ec1d58399e4f4ae544c504a6a20" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#b2cb3ec1d58399e4f4ae544c504a6a20">resetFixedAtoms</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets all fixed atoms to be not fixed again. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f23af662926e90cbf33b464dc00f18f0"></a><!-- doxytag: member="VariableState::setLazy" ref="f23af662926e90cbf33b464dc00f18f0" args="(const bool &amp;l)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#f23af662926e90cbf33b464dc00f18f0">setLazy</a> (const bool &amp;l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0aa423d45e9a45d43fc45f76dcc7d965"></a><!-- doxytag: member="VariableState::getLazy" ref="0aa423d45e9a45d43fc45f76dcc7d965" args="()" -->
const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#0aa423d45e9a45d43fc45f76dcc7d965">getLazy</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eb3f62075b6a1af215b73df383c55e3a"></a><!-- doxytag: member="VariableState::setUseThreshold" ref="eb3f62075b6a1af215b73df383c55e3a" args="(const bool &amp;t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#eb3f62075b6a1af215b73df383c55e3a">setUseThreshold</a> (const bool &amp;t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="53751af94ce5cd468ff4c53b75c38881"></a><!-- doxytag: member="VariableState::getUseThreshold" ref="53751af94ce5cd468ff4c53b75c38881" args="()" -->
const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#53751af94ce5cd468ff4c53b75c38881">getUseThreshold</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="43a78105492c54fca8826edca9d12e18"></a><!-- doxytag: member="VariableState::getHardWt" ref="43a78105492c54fca8826edca9d12e18" args="()" -->
long double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#43a78105492c54fca8826edca9d12e18">getHardWt</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0194e4cbd37bc1b5a7eb8807bfac7439"></a><!-- doxytag: member="VariableState::getDomain" ref="0194e4cbd37bc1b5a7eb8807bfac7439" args="()" -->
const <a class="el" href="classDomain.html">Domain</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#0194e4cbd37bc1b5a7eb8807bfac7439">getDomain</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1548f0738dfae172390bd766aae71fdd"></a><!-- doxytag: member="VariableState::getMLN" ref="1548f0738dfae172390bd766aae71fdd" args="()" -->
const <a class="el" href="classMLN.html">MLN</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#1548f0738dfae172390bd766aae71fdd">getMLN</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#0abdaf7a4b916cfc61907f09b68710c8">printLowState</a> (ostream &amp;out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the best state found to a stream.  <a href="#0abdaf7a4b916cfc61907f09b68710c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#2229f05fc17e02a969a178c9a2fe708c">printGndPred</a> (const int &amp;predIndex, ostream &amp;out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints a ground predicate to a stream.  <a href="#2229f05fc17e02a969a178c9a2fe708c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#e6903cc7c8abc7f43fa2f72e81dd0b94">getTruePreds</a> (vector&lt; string &gt; &amp;truePreds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puts the predicates set to true in the best state to a stream into a vector in string form.  <a href="#e6903cc7c8abc7f43fa2f72e81dd0b94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#b097423bddeaf431723ade2b990c10ce">setAsEvidence</a> (const <a class="el" href="classGroundPredicate.html">GroundPredicate</a> *const &amp;predicate, const bool &amp;trueEvidence)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a <a class="el" href="classGroundPredicate.html">GroundPredicate</a> to be evidence and sets its truth value.  <a href="#b097423bddeaf431723ade2b990c10ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#dfe0128b21fb28fcfd5a2796bc17eced">setAsQuery</a> (const <a class="el" href="classGroundPredicate.html">GroundPredicate</a> *const &amp;predicate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a <a class="el" href="classGroundPredicate.html">GroundPredicate</a> to be query.  <a href="#dfe0128b21fb28fcfd5a2796bc17eced"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGroundPredicate.html">GroundPredicate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#e25d7b335279bab8def1c7ed12d29ffa">getGndPred</a> (const int &amp;index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a pointer to a <a class="el" href="classGroundPredicate.html">GroundPredicate</a>.  <a href="#e25d7b335279bab8def1c7ed12d29ffa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGroundClause.html">GroundClause</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#cfd4c00140b2adacfe5113d35b79f71d">getGndClause</a> (const int &amp;index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a pointer to a <a class="el" href="classGroundClause.html">GroundClause</a>.  <a href="#cfd4c00140b2adacfe5113d35b79f71d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="66d8070da3adc21c6c7b906117712ff0"></a><!-- doxytag: member="VariableState::saveLowStateToGndPreds" ref="66d8070da3adc21c6c7b906117712ff0" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#66d8070da3adc21c6c7b906117712ff0">saveLowStateToGndPreds</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The atom assignment in the best state is saved to the ground predicates. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="90c5cf374c125ced03d93bd827e458b8"></a><!-- doxytag: member="VariableState::saveLowStateToDB" ref="90c5cf374c125ced03d93bd827e458b8" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#90c5cf374c125ced03d93bd827e458b8">saveLowStateToDB</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The atom assignment in the best state is saved to the database. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#df5999e531cf4de1350b46df789e0c81">getGndPredIndex</a> (<a class="el" href="classGroundPredicate.html">GroundPredicate</a> *const &amp;gndPred)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the index of a <a class="el" href="classGroundPredicate.html">GroundPredicate</a> in this state.  <a href="#df5999e531cf4de1350b46df789e0c81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#1944a7ef1d312dab635ad19801ba13f7">getActiveClauses</a> (<a class="el" href="classPredicate.html">Predicate</a> *inputPred, <a class="el" href="classArray.html">Array</a>&lt; <a class="el" href="classGroundClause.html">GroundClause</a> * &gt; &amp;activeClauses, bool const &amp;active, bool const &amp;ignoreActivePreds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets clauses and weights activated by the predicate inputPred, if active is true.  <a href="#1944a7ef1d312dab635ad19801ba13f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#879c6333edb862b00e2a3550fce77e1f">getActiveClauses</a> (<a class="el" href="classArray.html">Array</a>&lt; <a class="el" href="classGroundClause.html">GroundClause</a> * &gt; &amp;allClauses, bool const &amp;ignoreActivePreds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get all the active clauses in the database.  <a href="#879c6333edb862b00e2a3550fce77e1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c8f49252f55ea07378b7efb2cbfeeb32"></a><!-- doxytag: member="VariableState::getNumActiveAtoms" ref="c8f49252f55ea07378b7efb2cbfeeb32" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#c8f49252f55ea07378b7efb2cbfeeb32">getNumActiveAtoms</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="328560d1ccaecf634090c84a72fb094f"></a><!-- doxytag: member="VariableState::addOneAtomToEachBlock" ref="328560d1ccaecf634090c84a72fb094f" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#328560d1ccaecf634090c84a72fb094f">addOneAtomToEachBlock</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Selects one atom in each block in the domain and adds it to the block here and sets it to true. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7b3f22000c5ad265858bc34da586b280"></a><!-- doxytag: member="VariableState::initLazyBlocks" ref="7b3f22000c5ad265858bc34da586b280" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#7b3f22000c5ad265858bc34da586b280">initLazyBlocks</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the block structures for the lazy version. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d6804e71c36bc1d271ee2b3cbaf81750"></a><!-- doxytag: member="VariableState::fillLazyBlocks" ref="d6804e71c36bc1d271ee2b3cbaf81750" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVariableState.html#d6804e71c36bc1d271ee2b3cbaf81750">fillLazyBlocks</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the blocks with the predicates in the domain blocks. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Represents the state of propositional variables and clauses. 
<p>
Some of this code is based on the <a class="el" href="classMaxWalkSat.html">MaxWalkSat</a> package of Kautz et al.<p>
All inference algorithms should have a <a class="el" href="classVariableState.html">VariableState</a> to access the information needed in its predicates and clauses.<p>
Each atom has its own index starting at 1. The negation of an atom with index a is represented by -a (this is why the indices do not start at 0). Each clause has its own index starting at 0.<p>
A <a class="el" href="classVariableState.html">VariableState</a> is either eager or lazy. Eager states build an <a class="el" href="classMRF.html">MRF</a> upfront based on an <a class="el" href="classMLN.html">MLN</a> and a domain. Thus, all ground clauses and predicates are in memory after building the <a class="el" href="classMRF.html">MRF</a>. Lazy states activate atoms and clauses as they are needed from the <a class="el" href="classMLN.html">MLN</a> and domain. An atom is activated if it is in an unsatisfied clause with the assumption of all atoms being false or if it is looked at during inference (it is flipped or the cost of flipping it is computed). Active clauses are those which contain active atoms. 
<p>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00093">93</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="abd28fc5eef663c5ec3d1e67cd313047"></a><!-- doxytag: member="VariableState::VariableState" ref="abd28fc5eef663c5ec3d1e67cd313047" args="(GroundPredicateHashArray *const &amp;unknownQueries, GroundPredicateHashArray *const &amp;knownQueries, Array&lt; TruthValue &gt; *const &amp;knownQueryValues, const Array&lt; int &gt; *const &amp;allPredGndingsAreQueries, const bool &amp;markHardGndClauses, const bool &amp;trackParentClauseWts, const MLN *const &amp;mln, const Domain *const &amp;domain, const bool &amp;lazy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VariableState::VariableState           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHashArray.html">GroundPredicateHashArray</a> *const &amp;&nbsp;</td>
          <td class="paramname"> <em>unknownQueries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHashArray.html">GroundPredicateHashArray</a> *const &amp;&nbsp;</td>
          <td class="paramname"> <em>knownQueries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray.html">Array</a>&lt; TruthValue &gt; *const &amp;&nbsp;</td>
          <td class="paramname"> <em>knownQueryValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray.html">Array</a>&lt; int &gt; *const &amp;&nbsp;</td>
          <td class="paramname"> <em>allPredGndingsAreQueries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>markHardGndClauses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>trackParentClauseWts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMLN.html">MLN</a> *const &amp;&nbsp;</td>
          <td class="paramname"> <em>mln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDomain.html">Domain</a> *const &amp;&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>lazy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for a <a class="el" href="classVariableState.html">VariableState</a>. 
<p>
The hard clause weight is set. In lazy mode, the initial active atoms and clauses are retrieved and in eager mode, the <a class="el" href="classMRF.html">MRF</a> is built and the atoms and clauses are retrieved from it. In addition, all information arrays are filled with information.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unknownQueries</em>&nbsp;</td><td>Query predicates with unknown values used to build <a class="el" href="classMRF.html">MRF</a> in eager mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>knownQueries</em>&nbsp;</td><td>Query predicates with known values used to build <a class="el" href="classMRF.html">MRF</a> in eager mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>knownQueryValues</em>&nbsp;</td><td>Truth values of the known query predicates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>allPredGndingsAreQueries</em>&nbsp;</td><td><a class="el" href="classArray.html">Array</a> used to build <a class="el" href="classMRF.html">MRF</a> in eager mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mln</em>&nbsp;</td><td>mln and domain are used to build <a class="el" href="classMRF.html">MRF</a> in eager state and to retrieve active atoms in lazy state. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>domain</em>&nbsp;</td><td>mln and domain are used to build <a class="el" href="classMRF.html">MRF</a> in eager state and to retrieve active atoms in lazy state. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lazy</em>&nbsp;</td><td>Flag stating whether lazy mode is used or not. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00115">115</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l00292">addNewClauses()</a>, <a class="el" href="variablestate_8h-source.html#l02228">addOneAtomToEachBlock()</a>, <a class="el" href="hasharray_8h-source.html#l00119">HashArray&lt; Type, HashFn, EqualFn &gt;::append()</a>, <a class="el" href="array_8h-source.html#l00215">Array&lt; Type &gt;::clear()</a>, <a class="el" href="mrf_8h-source.html#l00463">MRF::deleteGndPredsGndClauseSets()</a>, <a class="el" href="variablestate_8h-source.html#l02287">fillLazyBlocks()</a>, <a class="el" href="variablestate_8h-source.html#l02101">getActiveClauses()</a>, <a class="el" href="mrf_8h-source.html#l00518">MRF::getBlockEvidence()</a>, <a class="el" href="mrf_8h-source.html#l00513">MRF::getBlocks()</a>, <a class="el" href="domain_8h-source.html#l00311">Domain::getDB()</a>, <a class="el" href="mrf_8h-source.html#l00478">MRF::getGndClauses()</a>, <a class="el" href="mrf_8h-source.html#l00476">MRF::getGndPreds()</a>, <a class="el" href="variablestate_8h-source.html#l00632">getNumClauses()</a>, <a class="el" href="variablestate_8h-source.html#l02276">initLazyBlocks()</a>, <a class="el" href="database_8h-source.html#l00688">Database::setActiveStatus()</a>, <a class="el" href="database_8h-source.html#l00479">Database::setPerformingInference()</a>, <a class="el" href="hasharray_8h-source.html#l00229">HashArray&lt; Type, HashFn, EqualFn &gt;::size()</a>, and <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.<div class="fragment"><pre class="fragment"><a name="l00123"></a>00123   {
<a name="l00124"></a>00124     this-&gt;mln_ = (<a class="code" href="classMLN.html">MLN</a>*)mln;
<a name="l00125"></a>00125     this-&gt;domain_ = (<a class="code" href="classDomain.html">Domain</a>*)domain;
<a name="l00126"></a>00126     this-&gt;lazy_ = lazy;
<a name="l00127"></a>00127 
<a name="l00128"></a>00128       <span class="comment">// Instantiate information</span>
<a name="l00129"></a>00129     baseNumAtoms_ = 0;
<a name="l00130"></a>00130     activeAtoms_ = 0;
<a name="l00131"></a>00131     numFalseClauses_ = 0;
<a name="l00132"></a>00132     costOfFalseClauses_ = 0.0;
<a name="l00133"></a>00133     lowCost_ = LDBL_MAX;
<a name="l00134"></a>00134     lowBad_ = INT_MAX;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136       <span class="comment">// Clauses and preds are stored in gndClauses_ and gndPreds_</span>
<a name="l00137"></a>00137     gndClauses_ = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;GroundClause*&gt;</a>;
<a name="l00138"></a>00138     gndPreds_ = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;GroundPredicate*&gt;</a>;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140       <span class="comment">// Set the hard clause weight</span>
<a name="l00141"></a>00141     setHardClauseWeight();
<a name="l00142"></a>00142 
<a name="l00143"></a>00143       <span class="comment">// Lazy version: Produce state with initial active atoms and clauses</span>
<a name="l00144"></a>00144     <span class="keywordflow">if</span> (lazy_)
<a name="l00145"></a>00145     {
<a name="l00146"></a>00146         <span class="comment">// Unknown preds are treated as false</span>
<a name="l00147"></a>00147       domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>()-&gt;<a class="code" href="classDatabase.html#f9e84d7c6945e840453c46b2c72b5d16">setPerformingInference</a>(<span class="keyword">true</span>);
<a name="l00148"></a>00148 
<a name="l00149"></a>00149         <span class="comment">// Blocks are copied from the domain</span>
<a name="l00150"></a>00150       <a class="code" href="classVariableState.html#7b3f22000c5ad265858bc34da586b280">initLazyBlocks</a>();
<a name="l00151"></a>00151 
<a name="l00152"></a>00152       clauseLimit_ = INT_MAX;
<a name="l00153"></a>00153       noApprox_ = <span class="keyword">false</span>;
<a name="l00154"></a>00154       haveDeactivated_ = <span class="keyword">false</span>;
<a name="l00155"></a>00155 
<a name="l00157"></a>00157         <span class="comment">// Get initial set of active atoms (atoms in unsat. clauses)</span>
<a name="l00158"></a>00158         <span class="comment">// Assumption is: all atoms are initially false except those in blocks</span>
<a name="l00159"></a>00159 
<a name="l00160"></a>00160         <span class="comment">// One atom in each block is set to true and activated</span>
<a name="l00161"></a>00161       <a class="code" href="classVariableState.html#328560d1ccaecf634090c84a72fb094f">addOneAtomToEachBlock</a>();
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">//cout &lt;&lt; "After addOneAtomToEachBlock" &lt;&lt; endl;</span>
<a name="l00164"></a>00164 <span class="comment">//for (int i = 1; i &lt; atom_.size(); i++)</span>
<a name="l00165"></a>00165 <span class="comment">//  cout &lt;&lt; atom_[i] &lt;&lt; endl;</span>
<a name="l00166"></a>00166 
<a name="l00167"></a>00167       <span class="keywordtype">bool</span> ignoreActivePreds = <span class="keyword">false</span>;
<a name="l00168"></a>00168       <a class="code" href="classVariableState.html#1944a7ef1d312dab635ad19801ba13f7">getActiveClauses</a>(newClauses_, ignoreActivePreds);
<a name="l00169"></a>00169       <span class="keywordtype">int</span> defaultCnt = newClauses_.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>();
<a name="l00170"></a>00170       <span class="keywordtype">long</span> <span class="keywordtype">double</span> defaultCost = 0;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; defaultCnt; i++)
<a name="l00173"></a>00173       {
<a name="l00174"></a>00174         <span class="keywordflow">if</span> (newClauses_[i]-&gt;isHardClause())
<a name="l00175"></a>00175           defaultCost += hardWt_;
<a name="l00176"></a>00176         <span class="keywordflow">else</span>
<a name="l00177"></a>00177           defaultCost += abs(newClauses_[i]-&gt;getWt());
<a name="l00178"></a>00178       }
<a name="l00179"></a>00179 
<a name="l00180"></a>00180         <span class="comment">// Clear ground clauses in the ground preds</span>
<a name="l00181"></a>00181       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndPredHashArray_.<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00182"></a>00182         gndPredHashArray_[i]-&gt;removeGndClauses();
<a name="l00183"></a>00183 
<a name="l00184"></a>00184         <span class="comment">// Delete new clauses</span>
<a name="l00185"></a>00185       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; newClauses_.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00186"></a>00186         <span class="keyword">delete</span> newClauses_[i];
<a name="l00187"></a>00187       newClauses_.<a class="code" href="classArray.html#732046291e31f830757e0847280fb593">clear</a>();
<a name="l00188"></a>00188 
<a name="l00189"></a>00189       baseNumAtoms_ = gndPredHashArray_.<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();
<a name="l00190"></a>00190       cout &lt;&lt; <span class="stringliteral">"Number of Baseatoms = "</span> &lt;&lt; baseNumAtoms_ &lt;&lt; endl;
<a name="l00191"></a>00191       cout &lt;&lt; <span class="stringliteral">"Default =&gt; Cost\t"</span> &lt;&lt; <span class="stringliteral">"******\t"</span> &lt;&lt; <span class="stringliteral">" Clause Cnt\t"</span> &lt;&lt; endl;
<a name="l00192"></a>00192       cout &lt;&lt; <span class="stringliteral">"           "</span> &lt;&lt; defaultCost &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; <span class="stringliteral">"******\t"</span> &lt;&lt; defaultCnt
<a name="l00193"></a>00193            &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; endl &lt;&lt; endl;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         <span class="comment">// Set base atoms as active in DB</span>
<a name="l00196"></a>00196       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; baseNumAtoms_; i++)
<a name="l00197"></a>00197       {
<a name="l00198"></a>00198         domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>()-&gt;<a class="code" href="classDatabase.html#60d5fbbfcda7a0e255e3727f4b7b148d">setActiveStatus</a>(gndPredHashArray_[i], <span class="keyword">true</span>);
<a name="l00199"></a>00199         activeAtoms_++;        
<a name="l00200"></a>00200       }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="comment">// Add the rest of the atoms in the blocks, but don't activate</span>
<a name="l00203"></a>00203       <a class="code" href="classVariableState.html#d6804e71c36bc1d271ee2b3cbaf81750">fillLazyBlocks</a>();
<a name="l00204"></a>00204 
<a name="l00205"></a>00205         <span class="comment">// Get the initial set of active clauses</span>
<a name="l00206"></a>00206       ignoreActivePreds = <span class="keyword">false</span>;
<a name="l00207"></a>00207       <a class="code" href="classVariableState.html#1944a7ef1d312dab635ad19801ba13f7">getActiveClauses</a>(newClauses_, ignoreActivePreds);      
<a name="l00208"></a>00208     } <span class="comment">// End lazy version</span>
<a name="l00209"></a>00209       <span class="comment">// Eager version: Use KBMC to produce the state</span>
<a name="l00210"></a>00210     <span class="keywordflow">else</span>
<a name="l00211"></a>00211     {
<a name="l00212"></a>00212       unePreds_ = unknownQueries;
<a name="l00213"></a>00213       knePreds_ = knownQueries;
<a name="l00214"></a>00214       knePredValues_ = knownQueryValues;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         <span class="comment">// MRF is built on known and unknown queries</span>
<a name="l00217"></a>00217       <span class="keywordtype">int</span> size = 0;
<a name="l00218"></a>00218       <span class="keywordflow">if</span> (unknownQueries) size += unknownQueries-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();
<a name="l00219"></a>00219       <span class="keywordflow">if</span> (knownQueries) size += knownQueries-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();
<a name="l00220"></a>00220       <a class="code" href="classHashArray.html">GroundPredicateHashArray</a>* queries = <span class="keyword">new</span> <a class="code" href="classHashArray.html">GroundPredicateHashArray</a>(size);
<a name="l00221"></a>00221       <span class="keywordflow">if</span> (unknownQueries) queries-&gt;<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>(unknownQueries);
<a name="l00222"></a>00222       <span class="keywordflow">if</span> (knownQueries) queries-&gt;<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>(knownQueries);
<a name="l00223"></a>00223       mrf_ = <span class="keyword">new</span> <a class="code" href="classMRF.html">MRF</a>(queries, allPredGndingsAreQueries, domain_,
<a name="l00224"></a>00224                      domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>(), mln_, markHardGndClauses,
<a name="l00225"></a>00225                      trackParentClauseWts, -1);
<a name="l00226"></a>00226         <span class="comment">//delete to save space. Can be deleted because no more gndClauses are</span>
<a name="l00227"></a>00227         <span class="comment">//appended to gndPreds beyond this point</span>
<a name="l00228"></a>00228       mrf_-&gt;<a class="code" href="classMRF.html#54120a9ab60129f2d30a00a905db1209">deleteGndPredsGndClauseSets</a>();
<a name="l00229"></a>00229         <span class="comment">//do not delete the intArrRep in gndPreds_;</span>
<a name="l00230"></a>00230       <span class="keyword">delete</span> queries;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232         <span class="comment">// Blocks built in MRF</span>
<a name="l00233"></a>00233       blocks_ = mrf_-&gt;<a class="code" href="classMRF.html#71a0712a7e1536494212b81e83966c04">getBlocks</a>();
<a name="l00234"></a>00234       blockEvidence_ = mrf_-&gt;<a class="code" href="classMRF.html#be7dfddd29cb3e226a3c438c1611d12f">getBlockEvidence</a>();
<a name="l00235"></a>00235         
<a name="l00236"></a>00236         <span class="comment">// Put ground clauses in newClauses_</span>
<a name="l00237"></a>00237       newClauses_ = *(<a class="code" href="classArray.html">Array&lt;GroundClause*&gt;</a>*)mrf_-&gt;<a class="code" href="classMRF.html#31490672018fd7951507f5ed404a0c18">getGndClauses</a>();
<a name="l00238"></a>00238         <span class="comment">// Put ground preds in the hash array</span>
<a name="l00239"></a>00239       <span class="comment">//const Array&lt;GroundPredicate*&gt;* gndPreds = mrf_-&gt;getGndPreds();</span>
<a name="l00240"></a>00240       <span class="keyword">const</span> <a class="code" href="classHashArray.html">GroundPredicateHashArray</a>* gndPreds = mrf_-&gt;<a class="code" href="classMRF.html#a9705576b7a99ee3158766ce841e6230">getGndPreds</a>();
<a name="l00241"></a>00241       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndPreds-&gt;<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00242"></a>00242         gndPredHashArray_.<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>((*gndPreds)[i]);
<a name="l00243"></a>00243     
<a name="l00244"></a>00244         <span class="comment">// baseNumAtoms_ are all atoms in eager version</span>
<a name="l00245"></a>00245       baseNumAtoms_ = gndPredHashArray_.<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();        
<a name="l00246"></a>00246     } <span class="comment">// End eager version</span>
<a name="l00247"></a>00247     
<a name="l00248"></a>00248       <span class="comment">// At this point, ground clauses are held in newClauses_</span>
<a name="l00249"></a>00249       <span class="comment">// and ground predicates are held in gndPredHashArray_</span>
<a name="l00250"></a>00250       <span class="comment">// for both versions</span>
<a name="l00251"></a>00251     
<a name="l00252"></a>00252       <span class="comment">// Add the clauses and preds and fill info arrays</span>
<a name="l00253"></a>00253     <span class="keywordtype">bool</span> initial = <span class="keyword">true</span>;
<a name="l00254"></a>00254     <a class="code" href="classVariableState.html#2748a93f222dafedaf7443634e234ddd">addNewClauses</a>(initial);
<a name="l00255"></a>00255     
<a name="l00256"></a>00256     cout &lt;&lt; <span class="stringliteral">"Initial num. of clauses: "</span> &lt;&lt; <a class="code" href="classVariableState.html#703e262481d6c0b076799511af07df67">getNumClauses</a>() &lt;&lt; endl;
<a name="l00257"></a>00257   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="42046a00643e0464dcc6798b9c132f63"></a><!-- doxytag: member="VariableState::~VariableState" ref="42046a00643e0464dcc6798b9c132f63" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VariableState::~VariableState           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Blocks are deleted in lazy version; <a class="el" href="classMRF.html">MRF</a> is deleted in eager version. 
<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00263">263</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.<div class="fragment"><pre class="fragment"><a name="l00264"></a>00264   {
<a name="l00265"></a>00265     <span class="keywordflow">if</span> (lazy_)
<a name="l00266"></a>00266     {
<a name="l00267"></a>00267         <span class="comment">// Block information from lazy version is deleted</span>
<a name="l00268"></a>00268       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; blocks_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00269"></a>00269         (*blocks_)[i].clearAndCompress();
<a name="l00270"></a>00270       <span class="keyword">delete</span> blocks_;
<a name="l00271"></a>00271     
<a name="l00272"></a>00272       <span class="keyword">delete</span> blockEvidence_;  
<a name="l00273"></a>00273     }
<a name="l00274"></a>00274     <span class="keywordflow">else</span>
<a name="l00275"></a>00275     {
<a name="l00276"></a>00276         <span class="comment">// MRF from eager version is deleted</span>
<a name="l00277"></a>00277       <span class="keywordflow">if</span> (mrf_) <span class="keyword">delete</span> mrf_;
<a name="l00278"></a>00278       <span class="comment">//if (unePreds_) delete unePreds_;</span>
<a name="l00279"></a>00279       <span class="comment">//if (knePreds_) delete knePreds_;</span>
<a name="l00280"></a>00280       <span class="comment">//if (knePredValues_) delete knePredValues_;</span>
<a name="l00281"></a>00281     }    
<a name="l00282"></a>00282   }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2748a93f222dafedaf7443634e234ddd"></a><!-- doxytag: member="VariableState::addNewClauses" ref="2748a93f222dafedaf7443634e234ddd" args="(bool initial)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::addNewClauses           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>initial</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
New clauses are added to the state. 
<p>
If not the initialization, then makecost and breakcost are updated for the new atoms.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>initial</em>&nbsp;</td><td>If true, this is the first time new clauses have been added. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00292">292</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="array_8h-source.html#l00153">Array&lt; Type &gt;::append()</a>, <a class="el" href="array_8h-source.html#l00215">Array&lt; Type &gt;::clear()</a>, <a class="el" href="domain_8h-source.html#l00311">Domain::getDB()</a>, <a class="el" href="variablestate_8h-source.html#l00630">getNumAtoms()</a>, <a class="el" href="variablestate_8h-source.html#l00632">getNumClauses()</a>, <a class="el" href="database_8h-source.html#l00494">Database::getValue()</a>, <a class="el" href="array_8h-source.html#l00180">Array&lt; Type &gt;::growToSize()</a>, <a class="el" href="variablestate_8h-source.html#l00530">initMakeBreakCostWatch()</a>, <a class="el" href="variablestate_8h-source.html#l01764">killClauses()</a>, <a class="el" href="hasharray_8h-source.html#l00229">HashArray&lt; Type, HashFn, EqualFn &gt;::size()</a>, and <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l00978">activateAtom()</a>, <a class="el" href="variablestate_8h-source.html#l02228">addOneAtomToEachBlock()</a>, <a class="el" href="variablestate_8h-source.html#l02287">fillLazyBlocks()</a>, <a class="el" href="variablestate_8h-source.html#l00418">reinit()</a>, and <a class="el" href="variablestate_8h-source.html#l00115">VariableState()</a>.<div class="fragment"><pre class="fragment"><a name="l00293"></a>00293   {
<a name="l00294"></a>00294     <span class="keywordflow">if</span> (vsdebug)
<a name="l00295"></a>00295       cout &lt;&lt; <span class="stringliteral">"Adding "</span> &lt;&lt; newClauses_.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() &lt;&lt; <span class="stringliteral">" new clauses.."</span> &lt;&lt; endl;
<a name="l00296"></a>00296 
<a name="l00297"></a>00297       <span class="comment">// Store the old number of clauses and atoms</span>
<a name="l00298"></a>00298     <span class="keywordtype">int</span> oldNumClauses = <a class="code" href="classVariableState.html#703e262481d6c0b076799511af07df67">getNumClauses</a>();
<a name="l00299"></a>00299     <span class="keywordtype">int</span> oldNumAtoms = <a class="code" href="classVariableState.html#bc520a99648ee29ef9447b86c26d9faf">getNumAtoms</a>();
<a name="l00300"></a>00300 
<a name="l00301"></a>00301     gndClauses_-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(newClauses_);
<a name="l00302"></a>00302     gndPreds_-&gt;<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(gndPredHashArray_.<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>());
<a name="l00303"></a>00303 
<a name="l00304"></a>00304     <span class="keywordtype">int</span> numAtoms = <a class="code" href="classVariableState.html#bc520a99648ee29ef9447b86c26d9faf">getNumAtoms</a>();
<a name="l00305"></a>00305     <span class="keywordtype">int</span> numClauses = <a class="code" href="classVariableState.html#703e262481d6c0b076799511af07df67">getNumClauses</a>();
<a name="l00306"></a>00306       <span class="comment">// If no new atoms or clauses have been added, then do nothing</span>
<a name="l00307"></a>00307     <span class="keywordflow">if</span> (numAtoms == oldNumAtoms &amp;&amp; numClauses == oldNumClauses) <span class="keywordflow">return</span>;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309     <span class="keywordflow">if</span> (vsdebug) cout &lt;&lt; <span class="stringliteral">"Clauses: "</span> &lt;&lt; numClauses &lt;&lt; endl;
<a name="l00310"></a>00310       <span class="comment">// atomIdx starts at 1</span>
<a name="l00311"></a>00311     atom_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numAtoms + 1, <span class="keyword">false</span>);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     makeCost_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numAtoms + 1, 0.0);
<a name="l00314"></a>00314     breakCost_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numAtoms + 1, 0.0);
<a name="l00315"></a>00315     lowAtom_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numAtoms + 1, <span class="keyword">false</span>);
<a name="l00316"></a>00316     fixedAtom_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numAtoms + 1, 0);
<a name="l00317"></a>00317 
<a name="l00318"></a>00318       <span class="comment">// Copy ground preds to gndPreds_ and set values in atom and lowAtom</span>
<a name="l00319"></a>00319     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = oldNumAtoms; i &lt; gndPredHashArray_.<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l00320"></a>00320     {
<a name="l00321"></a>00321       (*gndPreds_)[i] = gndPredHashArray_[i];
<a name="l00322"></a>00322 
<a name="l00323"></a>00323       <span class="keywordflow">if</span> (vsdebug)
<a name="l00324"></a>00324       {
<a name="l00325"></a>00325         cout &lt;&lt; <span class="stringliteral">"New pred: "</span>;
<a name="l00326"></a>00326         (*gndPreds_)[i]-&gt;print(cout, domain_);
<a name="l00327"></a>00327         cout &lt;&lt; endl;
<a name="l00328"></a>00328       }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330       lowAtom_[i + 1] = atom_[i + 1] = 
<a name="l00331"></a>00331         (domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>()-&gt;<a class="code" href="classDatabase.html#599fbc0b7e396c424f747a4c8bedd25e">getValue</a>((*gndPreds_)[i]) == TRUE) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00332"></a>00332     }
<a name="l00333"></a>00333     newClauses_.<a class="code" href="classArray.html#732046291e31f830757e0847280fb593">clear</a>();
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     clause_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numClauses);
<a name="l00336"></a>00336     clauseCost_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numClauses);
<a name="l00337"></a>00337     falseClause_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numClauses);
<a name="l00338"></a>00338     whereFalse_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numClauses);
<a name="l00339"></a>00339     numTrueLits_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numClauses);
<a name="l00340"></a>00340     watch1_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numClauses);
<a name="l00341"></a>00341     watch2_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numClauses);
<a name="l00342"></a>00342     isSatisfied_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numClauses, <span class="keyword">false</span>);
<a name="l00343"></a>00343     deadClause_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numClauses, <span class="keyword">false</span>);
<a name="l00344"></a>00344     threshold_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numClauses, <span class="keyword">false</span>);
<a name="l00345"></a>00345 
<a name="l00346"></a>00346     occurence_.<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(2*numAtoms + 1);
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = oldNumClauses; i &lt; numClauses; i++)
<a name="l00349"></a>00349     {
<a name="l00350"></a>00350       <a class="code" href="classGroundClause.html">GroundClause</a>* gndClause = (*gndClauses_)[i];
<a name="l00351"></a>00351 
<a name="l00352"></a>00352       <span class="keywordflow">if</span> (vsdebug)
<a name="l00353"></a>00353       {
<a name="l00354"></a>00354         cout &lt;&lt; <span class="stringliteral">"New clause: "</span>;
<a name="l00355"></a>00355         gndClause-&gt;print(cout, domain_, &amp;gndPredHashArray_);
<a name="l00356"></a>00356         cout &lt;&lt; endl;
<a name="l00357"></a>00357       }
<a name="l00358"></a>00358       
<a name="l00359"></a>00359         <span class="comment">// Set thresholds for clause selection</span>
<a name="l00360"></a>00360       <span class="keywordflow">if</span> (gndClause-&gt;isHardClause()) threshold_[i] = RAND_MAX;
<a name="l00361"></a>00361       <span class="keywordflow">else</span>
<a name="l00362"></a>00362       {
<a name="l00363"></a>00363         <span class="keywordtype">double</span> w = gndClause-&gt;getWt();
<a name="l00364"></a>00364         threshold_[i] = RAND_MAX*(1 - exp(-abs(w)));
<a name="l00365"></a>00365         <span class="keywordflow">if</span> (vsdebug)
<a name="l00366"></a>00366         {
<a name="l00367"></a>00367           cout &lt;&lt; <span class="stringliteral">"Weight: "</span> &lt;&lt; w &lt;&lt; endl;            
<a name="l00368"></a>00368         }
<a name="l00369"></a>00369       }
<a name="l00370"></a>00370       <span class="keywordflow">if</span> (vsdebug)
<a name="l00371"></a>00371         cout &lt;&lt; <span class="stringliteral">"Threshold: "</span> &lt;&lt; threshold_[i] &lt;&lt; endl;            
<a name="l00372"></a>00372       
<a name="l00373"></a>00373       <span class="keywordtype">int</span> numGndPreds = gndClause-&gt;getNumGroundPredicates();
<a name="l00374"></a>00374       clause_[i].<a class="code" href="classArray.html#a8417f3aab7a56eee773c45173c77626">growToSize</a>(numGndPreds);
<a name="l00375"></a>00375 
<a name="l00376"></a>00376       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; numGndPreds; j++) 
<a name="l00377"></a>00377       {
<a name="l00378"></a>00378         <span class="keywordtype">int</span> lit = gndClause-&gt;getGroundPredicateIndex(j);
<a name="l00379"></a>00379         clause_[i][j] = lit;
<a name="l00380"></a>00380         <span class="keywordtype">int</span> litIdx = 2*abs(lit) - (lit &gt; 0);
<a name="l00381"></a>00381         occurence_[litIdx].<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(i);
<a name="l00382"></a>00382       }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384         <span class="comment">// Hard clause weight has been previously determined</span>
<a name="l00385"></a>00385       <span class="keywordflow">if</span> (gndClause-&gt;isHardClause())
<a name="l00386"></a>00386         clauseCost_[i] = hardWt_;
<a name="l00387"></a>00387       <span class="keywordflow">else</span>
<a name="l00388"></a>00388         clauseCost_[i] = gndClause-&gt;getWt();
<a name="l00389"></a>00389     }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391     <span class="keywordflow">if</span> (!initial)
<a name="l00392"></a>00392     {
<a name="l00393"></a>00393       <span class="comment">//initNumSatLiterals(1, oldNumClauses);</span>
<a name="l00394"></a>00394       <span class="keywordflow">if</span> (useThreshold_)
<a name="l00395"></a>00395       {
<a name="l00396"></a>00396         <a class="code" href="classVariableState.html#4e30712524da7ecb7b450b98155dd717">killClauses</a>(oldNumClauses);
<a name="l00397"></a>00397       }
<a name="l00398"></a>00398       <span class="keywordflow">else</span>
<a name="l00399"></a>00399       {
<a name="l00400"></a>00400         <a class="code" href="classVariableState.html#2c53e96f2f2f3ed8978fae90a7daad36">initMakeBreakCostWatch</a>(oldNumClauses);
<a name="l00401"></a>00401       }
<a name="l00402"></a>00402     }
<a name="l00403"></a>00403     <span class="keywordflow">if</span> (vsdebug) cout &lt;&lt; <span class="stringliteral">"Done adding new clauses.."</span> &lt;&lt; endl;
<a name="l00404"></a>00404   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="38cda38f91fe157e68b0c9c4ce5a20a6"></a><!-- doxytag: member="VariableState::initRandom" ref="38cda38f91fe157e68b0c9c4ce5a20a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::initRandom           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes a random truth assigment to all (active) atoms. 
<p>
Blocks are taken into account: exactly one atom in the block is set to true and the others are set to false. 
<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00450">450</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01334">getBlockIndex()</a>, <a class="el" href="variablestate_8h-source.html#l00409">init()</a>, <a class="el" href="variablestate_8h-source.html#l00479">initBlocksRandom()</a>, and <a class="el" href="variablestate_8h-source.html#l00726">setValueOfAtom()</a>.
<p>
Referenced by <a class="el" href="maxwalksat_8h-source.html#l00151">MaxWalkSat::init()</a>.<div class="fragment"><pre class="fragment"><a name="l00451"></a>00451   {
<a name="l00452"></a>00452       <span class="comment">// Set one in each block to true randomly</span>
<a name="l00453"></a>00453     <a class="code" href="classVariableState.html#431d61bc9c02ee8e10833d34063ed98e">initBlocksRandom</a>();
<a name="l00454"></a>00454 
<a name="l00455"></a>00455       <span class="comment">// Random truth value for all not in blocks</span>
<a name="l00456"></a>00456     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= baseNumAtoms_; i++)
<a name="l00457"></a>00457     {
<a name="l00458"></a>00458         <span class="comment">// fixedAtom_[i] = -1: false, fixedAtom_[i] = 1: true</span>
<a name="l00459"></a>00459       <span class="keywordflow">if</span> (fixedAtom_[i] != 0) <a class="code" href="classVariableState.html#5ca24c889ca9ea4ec1ad6fa64b59e348">setValueOfAtom</a>(i, (fixedAtom_[i] == 1));
<a name="l00460"></a>00460         <span class="comment">// Blocks are initialized above</span>
<a name="l00461"></a>00461       <span class="keywordflow">if</span> (<a class="code" href="classVariableState.html#48db641f2970801eefcb83a0147d9173">getBlockIndex</a>(i - 1) &gt;= 0)
<a name="l00462"></a>00462       {
<a name="l00463"></a>00463         <span class="keywordflow">if</span> (vsdebug) cout &lt;&lt; <span class="stringliteral">"Atom "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" in block"</span> &lt;&lt; endl;
<a name="l00464"></a>00464         <span class="keywordflow">continue</span>;
<a name="l00465"></a>00465       }
<a name="l00466"></a>00466         <span class="comment">// Not fixed and not in block</span>
<a name="l00467"></a>00467       <span class="keywordflow">else</span>
<a name="l00468"></a>00468       {
<a name="l00469"></a>00469         <span class="keywordflow">if</span> (vsdebug) cout &lt;&lt; <span class="stringliteral">"Atom "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" not in block"</span> &lt;&lt; endl;
<a name="l00470"></a>00470         <a class="code" href="classVariableState.html#5ca24c889ca9ea4ec1ad6fa64b59e348">setValueOfAtom</a>(i, random() % 2);
<a name="l00471"></a>00471       }
<a name="l00472"></a>00472     }
<a name="l00473"></a>00473     <a class="code" href="classVariableState.html#78315762db15542e9cdab7753c697e66">init</a>();
<a name="l00474"></a>00474   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="07b395d520788e7e8f58da07e6327c75"></a><!-- doxytag: member="VariableState::initMakeBreakCostWatch" ref="07b395d520788e7e8f58da07e6327c75" args="(const int &amp;startClause)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::initMakeBreakCostWatch           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>startClause</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize makeCost and breakCost and watch arrays based on the current variable assignment. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startClause</em>&nbsp;</td><td>All clauses with index of this or greater are initialized. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00555">555</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01291">getClauseSize()</a>, <a class="el" href="variablestate_8h-source.html#l00632">getNumClauses()</a>, and <a class="el" href="variablestate_8h-source.html#l01224">isTrueLiteral()</a>.<div class="fragment"><pre class="fragment"><a name="l00556"></a>00556   {
<a name="l00557"></a>00557     <span class="keywordtype">int</span> theTrueLit = -1;
<a name="l00558"></a>00558       <span class="comment">// Initialize breakCost and makeCost in the following:</span>
<a name="l00559"></a>00559     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = startClause; i &lt; <a class="code" href="classVariableState.html#703e262481d6c0b076799511af07df67">getNumClauses</a>(); i++)
<a name="l00560"></a>00560     {
<a name="l00561"></a>00561         <span class="comment">// Don't look at dead clauses</span>
<a name="l00562"></a>00562       <span class="keywordflow">if</span> (deadClause_[i]) <span class="keywordflow">continue</span>;
<a name="l00563"></a>00563       <span class="keywordtype">int</span> trueLit1 = 0;
<a name="l00564"></a>00564       <span class="keywordtype">int</span> trueLit2 = 0;
<a name="l00565"></a>00565       <span class="keywordtype">long</span> <span class="keywordtype">double</span> cost = clauseCost_[i];
<a name="l00566"></a>00566       numTrueLits_[i] = 0;
<a name="l00567"></a>00567       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a>(i); j++)
<a name="l00568"></a>00568       {
<a name="l00569"></a>00569         <span class="keywordflow">if</span> (<a class="code" href="classVariableState.html#a6cd0ba26bb4d5c3f7b19d0cd76f3317">isTrueLiteral</a>(clause_[i][j]))
<a name="l00570"></a>00570         { <span class="comment">// ij is true lit</span>
<a name="l00571"></a>00571           numTrueLits_[i]++;
<a name="l00572"></a>00572           theTrueLit = abs(clause_[i][j]);
<a name="l00573"></a>00573           <span class="keywordflow">if</span> (!trueLit1) trueLit1 = theTrueLit;
<a name="l00574"></a>00574           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (trueLit1 &amp;&amp; !trueLit2) trueLit2 = theTrueLit;
<a name="l00575"></a>00575         }
<a name="l00576"></a>00576       }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578         <span class="comment">// Unsatisfied positive-weighted clauses or</span>
<a name="l00579"></a>00579         <span class="comment">// Satisfied negative-weighted clauses</span>
<a name="l00580"></a>00580       <span class="keywordflow">if</span> ((numTrueLits_[i] == 0 &amp;&amp; cost &gt; 0) ||
<a name="l00581"></a>00581           (numTrueLits_[i] &gt; 0 &amp;&amp; cost &lt; 0))
<a name="l00582"></a>00582       {
<a name="l00583"></a>00583         whereFalse_[i] = numFalseClauses_;
<a name="l00584"></a>00584         falseClause_[numFalseClauses_] = i;
<a name="l00585"></a>00585         numFalseClauses_++;
<a name="l00586"></a>00586         costOfFalseClauses_ += abs(cost);
<a name="l00587"></a>00587         <span class="keywordflow">if</span> (highestCost_ == abs(cost)) {eqHighest_ = <span class="keyword">true</span>; numHighest_++;}
<a name="l00588"></a>00588 
<a name="l00589"></a>00589           <span class="comment">// Unsat. pos. clause: increase makeCost_ of all atoms</span>
<a name="l00590"></a>00590         <span class="keywordflow">if</span> (numTrueLits_[i] == 0)
<a name="l00591"></a>00591           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a>(i); j++)
<a name="l00592"></a>00592           {
<a name="l00593"></a>00593             makeCost_[abs(clause_[i][j])] += cost;
<a name="l00594"></a>00594           }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596           <span class="comment">// Sat. neg. clause: increase makeCost_ if one true literal</span>
<a name="l00597"></a>00597         <span class="keywordflow">if</span> (numTrueLits_[i] == 1)
<a name="l00598"></a>00598         {
<a name="l00599"></a>00599             <span class="comment">// Subtract neg. cost</span>
<a name="l00600"></a>00600           makeCost_[theTrueLit] -= cost;
<a name="l00601"></a>00601           watch1_[i] = theTrueLit;
<a name="l00602"></a>00602         }
<a name="l00603"></a>00603         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (numTrueLits_[i] &gt; 1)
<a name="l00604"></a>00604         {
<a name="l00605"></a>00605           watch1_[i] = trueLit1;
<a name="l00606"></a>00606           watch2_[i] = trueLit2;
<a name="l00607"></a>00607         }
<a name="l00608"></a>00608       }
<a name="l00609"></a>00609         <span class="comment">// Pos. clauses satisfied by one true literal</span>
<a name="l00610"></a>00610       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (numTrueLits_[i] == 1 &amp;&amp; cost &gt; 0)
<a name="l00611"></a>00611       {
<a name="l00612"></a>00612         breakCost_[theTrueLit] += cost;
<a name="l00613"></a>00613         watch1_[i] = theTrueLit;
<a name="l00614"></a>00614       }
<a name="l00615"></a>00615         <span class="comment">// Pos. clauses satisfied by 2 or more true literals</span>
<a name="l00616"></a>00616       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cost &gt; 0)
<a name="l00617"></a>00617       { <span class="comment">/*if (numtruelit[i] == 2)*/</span>
<a name="l00618"></a>00618         watch1_[i] = trueLit1;
<a name="l00619"></a>00619         watch2_[i] = trueLit2;
<a name="l00620"></a>00620       }
<a name="l00621"></a>00621         <span class="comment">// Unsat. neg. clauses: increase breakCost of all atoms</span>
<a name="l00622"></a>00622       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (numTrueLits_[i] == 0 &amp;&amp; cost &lt; 0)
<a name="l00623"></a>00623       {
<a name="l00624"></a>00624         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a>(i); j++)
<a name="l00625"></a>00625           breakCost_[abs(clause_[i][j])] -= cost;
<a name="l00626"></a>00626       }
<a name="l00627"></a>00627     } <span class="comment">// for all clauses</span>
<a name="l00628"></a>00628   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="f25a7b72dbd120a39bdf16a8f5177c0a"></a><!-- doxytag: member="VariableState::getIndexOfAtomInRandomFalseClause" ref="f25a7b72dbd120a39bdf16a8f5177c0a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VariableState::getIndexOfAtomInRandomFalseClause           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the absolute index of a random atom in a random unsatisfied pos. 
<p>
clause or the absolute index of a random true literal in a random satisfied clause. 
<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00657">657</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01291">getClauseSize()</a>, and <a class="el" href="variablestate_8h-source.html#l01251">getRandomTrueLitInClause()</a>.
<p>
Referenced by <a class="el" href="maxwalksat_8h-source.html#l00345">MaxWalkSat::pickRandom()</a>.<div class="fragment"><pre class="fragment"><a name="l00658"></a>00658   {
<a name="l00659"></a>00659     <span class="keywordflow">if</span> (numFalseClauses_ == 0) <span class="keywordflow">return</span> NOVALUE;
<a name="l00660"></a>00660     <span class="keywordtype">int</span> clauseIdx = falseClause_[random()%numFalseClauses_];
<a name="l00661"></a>00661       <span class="comment">// Pos. clause: return index of random atom</span>
<a name="l00662"></a>00662     <span class="keywordflow">if</span> (clauseCost_[clauseIdx] &gt; 0)
<a name="l00663"></a>00663       <span class="keywordflow">return</span> abs(clause_[clauseIdx][random()%<a class="code" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a>(clauseIdx)]);
<a name="l00664"></a>00664       <span class="comment">// Neg. clause: find random true lit</span>
<a name="l00665"></a>00665     <span class="keywordflow">else</span>
<a name="l00666"></a>00666       <span class="keywordflow">return</span> <a class="code" href="classVariableState.html#2464e6883cae56360dfdccd4704e9a34">getRandomTrueLitInClause</a>(clauseIdx);
<a name="l00667"></a>00667   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8ebb42420177d489c46c56f2c6e7547a"></a><!-- doxytag: member="VariableState::getRandomFalseClauseIndex" ref="8ebb42420177d489c46c56f2c6e7547a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int VariableState::getRandomFalseClauseIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of a random unsatisfied pos. 
<p>
clause or a random satisfied neg. clause. 
<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00673">673</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
Referenced by <a class="el" href="maxwalksat_8h-source.html#l00406">MaxWalkSat::pickBest()</a>, and <a class="el" href="maxwalksat_8h-source.html#l00499">MaxWalkSat::pickTabu()</a>.<div class="fragment"><pre class="fragment"><a name="l00674"></a>00674   {
<a name="l00675"></a>00675     <span class="keywordflow">if</span> (numFalseClauses_ == 0) <span class="keywordflow">return</span> NOVALUE;
<a name="l00676"></a>00676     <span class="keywordflow">return</span> falseClause_[random()%numFalseClauses_];
<a name="l00677"></a>00677   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1ad4eb75da5a498f834ce1aafd69f114"></a><!-- doxytag: member="VariableState::getValueOfAtom" ref="1ad4eb75da5a498f834ce1aafd69f114" args="(const int &amp;atomIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VariableState::getValueOfAtom           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the truth value of an atom. 
<p>
Index of atom whose truth value is returned. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Truth value of atom. </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00703">703</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
Referenced by <a class="el" href="maxwalksat_8h-source.html#l00683">MaxWalkSat::calculateImprovement()</a>, <a class="el" href="variablestate_8h-source.html#l00774">flipAtom()</a>, and <a class="el" href="maxwalksat_8h-source.html#l00345">MaxWalkSat::pickRandom()</a>.<div class="fragment"><pre class="fragment"><a name="l00704"></a>00704   {
<a name="l00705"></a>00705     <span class="keywordflow">return</span> atom_[atomIdx];
<a name="l00706"></a>00706   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="73ac1309ad13b2e21ff4904cb835610e"></a><!-- doxytag: member="VariableState::getValueOfLowAtom" ref="73ac1309ad13b2e21ff4904cb835610e" args="(const int &amp;atomIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VariableState::getValueOfLowAtom           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the truth value of an atom in the best state. 
<p>
Index of atom whose truth value is returned. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Truth value of atom. </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00714">714</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
Referenced by <a class="el" href="unitpropagation_8h-source.html#l00166">UnitPropagation::getPredsWithNonZeroProb()</a>, <a class="el" href="sat_8h-source.html#l00125">SAT::getPredsWithNonZeroProb()</a>, <a class="el" href="unitpropagation_8h-source.html#l00186">UnitPropagation::getProbability()</a>, <a class="el" href="sat_8h-source.html#l00145">SAT::getProbability()</a>, <a class="el" href="variablestate_8h-source.html#l01872">getTruePreds()</a>, <a class="el" href="unitpropagation_8h-source.html#l00148">UnitPropagation::printProbabilities()</a>, <a class="el" href="sat_8h-source.html#l00107">SAT::printProbabilities()</a>, <a class="el" href="unitpropagation_8h-source.html#l00197">UnitPropagation::printTruePreds()</a>, <a class="el" href="sat_8h-source.html#l00156">SAT::printTruePreds()</a>, and <a class="el" href="mcmc_8h-source.html#l00740">MCMC::saveLowStateToChain()</a>.<div class="fragment"><pre class="fragment"><a name="l00715"></a>00715   {
<a name="l00716"></a>00716     <span class="keywordflow">return</span> lowAtom_[atomIdx];
<a name="l00717"></a>00717   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="5ca24c889ca9ea4ec1ad6fa64b59e348"></a><!-- doxytag: member="VariableState::setValueOfAtom" ref="5ca24c889ca9ea4ec1ad6fa64b59e348" args="(const int &amp;atomIdx, const bool &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::setValueOfAtom           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the truth value of an atom. 
<p>
The truth value is propagated to the database.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atomIdx</em>&nbsp;</td><td>Index of atom whose value is to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Truth value being set. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00726">726</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l00978">activateAtom()</a>, <a class="el" href="domain_8h-source.html#l00311">Domain::getDB()</a>, <a class="el" href="variablestate_8h-source.html#l01003">isActive()</a>, and <a class="el" href="database_8h-source.html#l00646">Database::setValue()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l02228">addOneAtomToEachBlock()</a>, <a class="el" href="variablestate_8h-source.html#l01634">fixAtom()</a>, <a class="el" href="variablestate_8h-source.html#l00943">flipAtomValue()</a>, <a class="el" href="variablestate_8h-source.html#l00479">initBlocksRandom()</a>, <a class="el" href="variablestate_8h-source.html#l00450">initRandom()</a>, and <a class="el" href="variablestate_8h-source.html#l01613">setOthersInBlockToFalse()</a>.<div class="fragment"><pre class="fragment"><a name="l00727"></a>00727   {
<a name="l00728"></a>00728     <span class="keywordflow">if</span> (vsdebug) cout &lt;&lt; <span class="stringliteral">"Setting value of atom "</span> &lt;&lt; atomIdx 
<a name="l00729"></a>00729                       &lt;&lt; <span class="stringliteral">" to "</span> &lt;&lt; value &lt;&lt; endl;
<a name="l00730"></a>00730       <span class="comment">// If atom already has this value, then do nothing</span>
<a name="l00731"></a>00731     <span class="keywordflow">if</span> (atom_[atomIdx] == value) <span class="keywordflow">return</span>;
<a name="l00732"></a>00732       <span class="comment">// Propagate assigment to DB</span>
<a name="l00733"></a>00733     <a class="code" href="classGroundPredicate.html">GroundPredicate</a>* p = gndPredHashArray_[atomIdx - 1];
<a name="l00734"></a>00734     <span class="keywordflow">if</span> (value)
<a name="l00735"></a>00735     {
<a name="l00736"></a>00736       domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>()-&gt;<a class="code" href="classDatabase.html#55bde3da38b3b555e9897d860dfff500">setValue</a>(p, TRUE);
<a name="l00737"></a>00737     }
<a name="l00738"></a>00738     <span class="keywordflow">else</span>
<a name="l00739"></a>00739     {
<a name="l00740"></a>00740       domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>()-&gt;<a class="code" href="classDatabase.html#55bde3da38b3b555e9897d860dfff500">setValue</a>(p, FALSE);
<a name="l00741"></a>00741     }
<a name="l00742"></a>00742       <span class="comment">// If not active, then activate it</span>
<a name="l00743"></a>00743     <span class="keywordflow">if</span> (lazy_ &amp;&amp; !<a class="code" href="classVariableState.html#d1809e4857db8f403c53948b0ba9e960">isActive</a>(atomIdx))
<a name="l00744"></a>00744     {
<a name="l00745"></a>00745       <span class="keywordtype">bool</span> ignoreActivePreds = <span class="keyword">false</span>;
<a name="l00746"></a>00746       <a class="code" href="classVariableState.html#9082644cc8bc821e0ad8abd85bf11f80">activateAtom</a>(atomIdx, ignoreActivePreds);
<a name="l00747"></a>00747     }
<a name="l00748"></a>00748     atom_[atomIdx] = value;
<a name="l00749"></a>00749   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a71f608d3613ba9ceae3b0f5e25a61c9"></a><!-- doxytag: member="VariableState::flipAtom" ref="a71f608d3613ba9ceae3b0f5e25a61c9" args="(const int &amp;toFlip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::flipAtom           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>toFlip</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flip the truth value of an atom and update info arrays. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>toFlip</em>&nbsp;</td><td>Index of atom to be flipped. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00774">774</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01092">addBreakCost()</a>, <a class="el" href="variablestate_8h-source.html#l01111">addBreakCostToAtomsInClause()</a>, <a class="el" href="variablestate_8h-source.html#l01070">addFalseClause()</a>, <a class="el" href="variablestate_8h-source.html#l01145">addMakeCost()</a>, <a class="el" href="variablestate_8h-source.html#l01167">addMakeCostToAtomsInClause()</a>, <a class="el" href="variablestate_8h-source.html#l01038">decrementNumTrueLits()</a>, <a class="el" href="variablestate_8h-source.html#l00943">flipAtomValue()</a>, <a class="el" href="variablestate_8h-source.html#l01054">getClauseCost()</a>, <a class="el" href="variablestate_8h-source.html#l01022">getOccurenceArray()</a>, <a class="el" href="variablestate_8h-source.html#l01204">getTrueLiteralOtherThan()</a>, <a class="el" href="variablestate_8h-source.html#l00703">getValueOfAtom()</a>, <a class="el" href="variablestate_8h-source.html#l01296">getWatch1()</a>, <a class="el" href="variablestate_8h-source.html#l01306">getWatch2()</a>, <a class="el" href="variablestate_8h-source.html#l01030">incrementNumTrueLits()</a>, <a class="el" href="variablestate_8h-source.html#l01081">removeFalseClause()</a>, <a class="el" href="variablestate_8h-source.html#l01301">setWatch1()</a>, <a class="el" href="variablestate_8h-source.html#l01311">setWatch2()</a>, and <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.
<p>
Referenced by <a class="el" href="maxwalksat_8h-source.html#l00296">MaxWalkSat::flipAtom()</a>, and <a class="el" href="variablestate_8h-source.html#l00960">getImprovementByFlipping()</a>.<div class="fragment"><pre class="fragment"><a name="l00775"></a>00775   {
<a name="l00776"></a>00776     <span class="keywordtype">bool</span> toFlipValue = <a class="code" href="classVariableState.html#1ad4eb75da5a498f834ce1aafd69f114">getValueOfAtom</a>(toFlip);
<a name="l00777"></a>00777     <span class="keyword">register</span> <span class="keywordtype">int</span> clauseIdx;
<a name="l00778"></a>00778     <span class="keywordtype">int</span> sign;
<a name="l00779"></a>00779     <span class="keywordtype">int</span> oppSign;
<a name="l00780"></a>00780     <span class="keywordtype">int</span> litIdx;
<a name="l00781"></a>00781     <span class="keywordflow">if</span> (toFlipValue)
<a name="l00782"></a>00782       sign = 1;
<a name="l00783"></a>00783     <span class="keywordflow">else</span>
<a name="l00784"></a>00784       sign = 0;
<a name="l00785"></a>00785     oppSign = sign ^ 1;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787     <a class="code" href="classVariableState.html#86615cee925136b0b8d9fa9ee553ff10">flipAtomValue</a>(toFlip);
<a name="l00788"></a>00788     
<a name="l00789"></a>00789       <span class="comment">// Update all clauses in which the atom occurs as a true literal</span>
<a name="l00790"></a>00790     litIdx = 2*toFlip - sign;
<a name="l00791"></a>00791     <a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; posOccArray = <a class="code" href="classVariableState.html#32dc7e8ae1facd20d885cf6dac4c0028">getOccurenceArray</a>(litIdx);
<a name="l00792"></a>00792     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; posOccArray.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00793"></a>00793     {
<a name="l00794"></a>00794       clauseIdx = posOccArray[i];
<a name="l00795"></a>00795         <span class="comment">// Don't look at dead clauses</span>
<a name="l00796"></a>00796       <span class="keywordflow">if</span> (deadClause_[clauseIdx]) <span class="keywordflow">continue</span>;
<a name="l00797"></a>00797         <span class="comment">// The true lit became a false lit</span>
<a name="l00798"></a>00798       <span class="keywordtype">int</span> numTrueLits = <a class="code" href="classVariableState.html#df2045508a3820ac75f02bd297c587f8">decrementNumTrueLits</a>(clauseIdx);
<a name="l00799"></a>00799       <span class="keywordtype">long</span> <span class="keywordtype">double</span> cost = <a class="code" href="classVariableState.html#ce8401a0ed90726319c8d8d15cb5da30">getClauseCost</a>(clauseIdx);
<a name="l00800"></a>00800       <span class="keywordtype">int</span> watch1 = <a class="code" href="classVariableState.html#1ff785b813b350e67466c7210856243e">getWatch1</a>(clauseIdx);
<a name="l00801"></a>00801       <span class="keywordtype">int</span> watch2 = <a class="code" href="classVariableState.html#04e9c3e0a50b7bdfd04cdc0bafd6906d">getWatch2</a>(clauseIdx);
<a name="l00802"></a>00802 
<a name="l00803"></a>00803         <span class="comment">// 1. If last true lit was flipped, then we have to update</span>
<a name="l00804"></a>00804         <span class="comment">// the makecost / breakcost info accordingly        </span>
<a name="l00805"></a>00805       <span class="keywordflow">if</span> (numTrueLits == 0)
<a name="l00806"></a>00806       {
<a name="l00807"></a>00807           <span class="comment">// Pos. clause</span>
<a name="l00808"></a>00808         <span class="keywordflow">if</span> (cost &gt; 0)
<a name="l00809"></a>00809         {
<a name="l00810"></a>00810             <span class="comment">// Add this clause as false in the state</span>
<a name="l00811"></a>00811           <a class="code" href="classVariableState.html#a57ed676fde7a24d57e527756d592bd5">addFalseClause</a>(clauseIdx);
<a name="l00812"></a>00812             <span class="comment">// Decrease toFlip's breakcost (add neg. cost)</span>
<a name="l00813"></a>00813           <a class="code" href="classVariableState.html#e598f0dd45da0c61dacebea3871d9581">addBreakCost</a>(toFlip, -cost);
<a name="l00814"></a>00814             <span class="comment">// Increase makecost of all vars in clause (add pos. cost)</span>
<a name="l00815"></a>00815           <a class="code" href="classVariableState.html#189a058bc545cb3f284cf479d45dd6eb">addMakeCostToAtomsInClause</a>(clauseIdx, cost);
<a name="l00816"></a>00816         }
<a name="l00817"></a>00817           <span class="comment">// Neg. clause</span>
<a name="l00818"></a>00818         <span class="keywordflow">else</span>
<a name="l00819"></a>00819         {
<a name="l00820"></a>00820           assert(cost &lt; 0);
<a name="l00821"></a>00821             <span class="comment">// Remove this clause as false in the state</span>
<a name="l00822"></a>00822           <a class="code" href="classVariableState.html#324631d59cff78ffd52163f584bd237c">removeFalseClause</a>(clauseIdx);
<a name="l00823"></a>00823             <span class="comment">// Increase breakcost of all vars in clause (add pos. cost)</span>
<a name="l00824"></a>00824           <a class="code" href="classVariableState.html#8bda003606fd8a852f44a988124adb19">addBreakCostToAtomsInClause</a>(clauseIdx, -cost);        
<a name="l00825"></a>00825             <span class="comment">// Decrease toFlip's makecost (add neg. cost)</span>
<a name="l00826"></a>00826           <a class="code" href="classVariableState.html#d1574f8f2d9106457d6bb1b2d3282d60">addMakeCost</a>(toFlip, cost);
<a name="l00827"></a>00827         }
<a name="l00828"></a>00828       }
<a name="l00829"></a>00829         <span class="comment">// 2. If there is now one true lit left, then move watch2</span>
<a name="l00830"></a>00830         <span class="comment">// up to watch1 and increase the breakcost / makecost of watch1</span>
<a name="l00831"></a>00831       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (numTrueLits == 1)
<a name="l00832"></a>00832       {
<a name="l00833"></a>00833         <span class="keywordflow">if</span> (watch1 == toFlip)
<a name="l00834"></a>00834         {
<a name="l00835"></a>00835           assert(watch1 != watch2);
<a name="l00836"></a>00836           <a class="code" href="classVariableState.html#c0823bb22e2680eec885ca035ec17548">setWatch1</a>(clauseIdx, watch2);
<a name="l00837"></a>00837           watch1 = <a class="code" href="classVariableState.html#1ff785b813b350e67466c7210856243e">getWatch1</a>(clauseIdx);
<a name="l00838"></a>00838         }
<a name="l00839"></a>00839 
<a name="l00840"></a>00840           <span class="comment">// Pos. clause: Increase toFlip's breakcost (add pos. cost)</span>
<a name="l00841"></a>00841         <span class="keywordflow">if</span> (cost &gt; 0)
<a name="l00842"></a>00842         {
<a name="l00843"></a>00843           <a class="code" href="classVariableState.html#e598f0dd45da0c61dacebea3871d9581">addBreakCost</a>(watch1, cost);
<a name="l00844"></a>00844         }
<a name="l00845"></a>00845           <span class="comment">// Neg. clause: Increase toFlip's makecost (add pos. cost)</span>
<a name="l00846"></a>00846         <span class="keywordflow">else</span>
<a name="l00847"></a>00847         {
<a name="l00848"></a>00848           assert(cost &lt; 0);
<a name="l00849"></a>00849           <a class="code" href="classVariableState.html#d1574f8f2d9106457d6bb1b2d3282d60">addMakeCost</a>(watch1, -cost);
<a name="l00850"></a>00850         }
<a name="l00851"></a>00851       }
<a name="l00852"></a>00852         <span class="comment">// 3. If there are 2 or more true lits left, then we have to</span>
<a name="l00853"></a>00853         <span class="comment">// find a new true lit to watch if one was flipped</span>
<a name="l00854"></a>00854       <span class="keywordflow">else</span>
<a name="l00855"></a>00855       { <span class="comment">/* numtruelit[clauseIdx] &gt;= 2 */</span>
<a name="l00856"></a>00856           <span class="comment">// If watch1[clauseIdx] has been flipped</span>
<a name="l00857"></a>00857         <span class="keywordflow">if</span> (watch1 == toFlip)
<a name="l00858"></a>00858         {
<a name="l00859"></a>00859             <span class="comment">// find a different true literal to watch</span>
<a name="l00860"></a>00860           <span class="keywordtype">int</span> diffTrueLit = <a class="code" href="classVariableState.html#9a385abc27c6cf5d891c52204a8b9faa">getTrueLiteralOtherThan</a>(clauseIdx, watch1, watch2);
<a name="l00861"></a>00861           <a class="code" href="classVariableState.html#c0823bb22e2680eec885ca035ec17548">setWatch1</a>(clauseIdx, diffTrueLit);
<a name="l00862"></a>00862         }
<a name="l00863"></a>00863           <span class="comment">// If watch2[clauseIdx] has been flipped</span>
<a name="l00864"></a>00864         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (watch2 == toFlip)
<a name="l00865"></a>00865         {
<a name="l00866"></a>00866             <span class="comment">// find a different true literal to watch</span>
<a name="l00867"></a>00867           <span class="keywordtype">int</span> diffTrueLit = <a class="code" href="classVariableState.html#9a385abc27c6cf5d891c52204a8b9faa">getTrueLiteralOtherThan</a>(clauseIdx, watch1, watch2);
<a name="l00868"></a>00868           <a class="code" href="classVariableState.html#575dad9109552494ca6c9a56582844c7">setWatch2</a>(clauseIdx, diffTrueLit);
<a name="l00869"></a>00869         }
<a name="l00870"></a>00870       }
<a name="l00871"></a>00871     }
<a name="l00872"></a>00872         
<a name="l00873"></a>00873       <span class="comment">// Update all clauses in which the atom occurs as a false literal</span>
<a name="l00874"></a>00874     litIdx = 2*toFlip - oppSign;
<a name="l00875"></a>00875     <a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; negOccArray = <a class="code" href="classVariableState.html#32dc7e8ae1facd20d885cf6dac4c0028">getOccurenceArray</a>(litIdx);
<a name="l00876"></a>00876     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; negOccArray.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l00877"></a>00877     {
<a name="l00878"></a>00878       clauseIdx = negOccArray[i];
<a name="l00879"></a>00879         <span class="comment">// Don't look at dead clauses</span>
<a name="l00880"></a>00880       <span class="keywordflow">if</span> (deadClause_[clauseIdx]) <span class="keywordflow">continue</span>;
<a name="l00881"></a>00881         <span class="comment">// The false lit became a true lit</span>
<a name="l00882"></a>00882       <span class="keywordtype">int</span> numTrueLits = <a class="code" href="classVariableState.html#430605283b71f8a1c2ece97b62f6741f">incrementNumTrueLits</a>(clauseIdx);
<a name="l00883"></a>00883       <span class="keywordtype">long</span> <span class="keywordtype">double</span> cost = <a class="code" href="classVariableState.html#ce8401a0ed90726319c8d8d15cb5da30">getClauseCost</a>(clauseIdx);
<a name="l00884"></a>00884       <span class="keywordtype">int</span> watch1 = <a class="code" href="classVariableState.html#1ff785b813b350e67466c7210856243e">getWatch1</a>(clauseIdx);
<a name="l00885"></a>00885 
<a name="l00886"></a>00886         <span class="comment">// 1. If this is the only true lit, then we have to update</span>
<a name="l00887"></a>00887         <span class="comment">// the makecost / breakcost info accordingly        </span>
<a name="l00888"></a>00888       <span class="keywordflow">if</span> (numTrueLits == 1)
<a name="l00889"></a>00889       {
<a name="l00890"></a>00890           <span class="comment">// Pos. clause</span>
<a name="l00891"></a>00891         <span class="keywordflow">if</span> (cost &gt; 0)
<a name="l00892"></a>00892         {
<a name="l00893"></a>00893             <span class="comment">// Remove this clause as false in the state</span>
<a name="l00894"></a>00894           <a class="code" href="classVariableState.html#324631d59cff78ffd52163f584bd237c">removeFalseClause</a>(clauseIdx);
<a name="l00895"></a>00895             <span class="comment">// Increase toFlip's breakcost (add pos. cost)</span>
<a name="l00896"></a>00896           <a class="code" href="classVariableState.html#e598f0dd45da0c61dacebea3871d9581">addBreakCost</a>(toFlip, cost);        
<a name="l00897"></a>00897             <span class="comment">// Decrease makecost of all vars in clause (add neg. cost)</span>
<a name="l00898"></a>00898           <a class="code" href="classVariableState.html#189a058bc545cb3f284cf479d45dd6eb">addMakeCostToAtomsInClause</a>(clauseIdx, -cost);
<a name="l00899"></a>00899         }
<a name="l00900"></a>00900           <span class="comment">// Neg. clause</span>
<a name="l00901"></a>00901         <span class="keywordflow">else</span>
<a name="l00902"></a>00902         {
<a name="l00903"></a>00903           assert(cost &lt; 0);
<a name="l00904"></a>00904             <span class="comment">// Add this clause as false in the state</span>
<a name="l00905"></a>00905           <a class="code" href="classVariableState.html#a57ed676fde7a24d57e527756d592bd5">addFalseClause</a>(clauseIdx);
<a name="l00906"></a>00906             <span class="comment">// Decrease breakcost of all vars in clause (add neg. cost)</span>
<a name="l00907"></a>00907           <a class="code" href="classVariableState.html#8bda003606fd8a852f44a988124adb19">addBreakCostToAtomsInClause</a>(clauseIdx, cost);
<a name="l00908"></a>00908             <span class="comment">// Increase toFlip's makecost (add pos. cost)</span>
<a name="l00909"></a>00909           <a class="code" href="classVariableState.html#d1574f8f2d9106457d6bb1b2d3282d60">addMakeCost</a>(toFlip, -cost);
<a name="l00910"></a>00910         }
<a name="l00911"></a>00911           <span class="comment">// Watch this atom</span>
<a name="l00912"></a>00912         <a class="code" href="classVariableState.html#c0823bb22e2680eec885ca035ec17548">setWatch1</a>(clauseIdx, toFlip);
<a name="l00913"></a>00913       }
<a name="l00914"></a>00914         <span class="comment">// 2. If there are now exactly 2 true lits, then watch second atom</span>
<a name="l00915"></a>00915         <span class="comment">// and update breakcost</span>
<a name="l00916"></a>00916       <span class="keywordflow">else</span>
<a name="l00917"></a>00917       <span class="keywordflow">if</span> (numTrueLits == 2)
<a name="l00918"></a>00918       {
<a name="l00919"></a>00919         <span class="keywordflow">if</span> (cost &gt; 0)
<a name="l00920"></a>00920         {
<a name="l00921"></a>00921             <span class="comment">// Pos. clause</span>
<a name="l00922"></a>00922             <span class="comment">// Decrease breakcost of first atom being watched (add neg. cost)</span>
<a name="l00923"></a>00923           <a class="code" href="classVariableState.html#e598f0dd45da0c61dacebea3871d9581">addBreakCost</a>(watch1, -cost);
<a name="l00924"></a>00924         }
<a name="l00925"></a>00925         <span class="keywordflow">else</span>
<a name="l00926"></a>00926         {
<a name="l00927"></a>00927             <span class="comment">// Neg. clause</span>
<a name="l00928"></a>00928           assert(cost &lt; 0);
<a name="l00929"></a>00929             <span class="comment">// Decrease makecost of first atom being watched (add neg. cost)</span>
<a name="l00930"></a>00930           <a class="code" href="classVariableState.html#d1574f8f2d9106457d6bb1b2d3282d60">addMakeCost</a>(watch1, cost);
<a name="l00931"></a>00931         }
<a name="l00932"></a>00932         
<a name="l00933"></a>00933           <span class="comment">// Watch second atom</span>
<a name="l00934"></a>00934         <a class="code" href="classVariableState.html#575dad9109552494ca6c9a56582844c7">setWatch2</a>(clauseIdx, toFlip);
<a name="l00935"></a>00935       }
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="86615cee925136b0b8d9fa9ee553ff10"></a><!-- doxytag: member="VariableState::flipAtomValue" ref="86615cee925136b0b8d9fa9ee553ff10" args="(const int &amp;atomIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::flipAtomValue           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flips the truth value of an atom. 
<p>
If in lazy mode, the truth value is propagated to the database. 
<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00943">943</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l00726">setValueOfAtom()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l00774">flipAtom()</a>, and <a class="el" href="maxwalksat_8h-source.html#l00770">MaxWalkSat::reconstructLowState()</a>.<div class="fragment"><pre class="fragment"><a name="l00944"></a>00944   {
<a name="l00945"></a>00945     <span class="keywordtype">bool</span> opposite = !atom_[atomIdx];
<a name="l00946"></a>00946     <a class="code" href="classVariableState.html#5ca24c889ca9ea4ec1ad6fa64b59e348">setValueOfAtom</a>(atomIdx, opposite);
<a name="l00947"></a>00947   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2ec57c8ad6127c24f96263abd8a301bb"></a><!-- doxytag: member="VariableState::getImprovementByFlipping" ref="2ec57c8ad6127c24f96263abd8a301bb" args="(const int &amp;atomIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double VariableState::getImprovementByFlipping           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the improvement achieved by flipping an atom. 
<p>
This is the cost of clauses which flipping the atom makes good minus the cost of clauses which flipping the atom makes bad. In lazy mode, if the atom is not active, then the atom is activated and the makecost and breakcost are updated.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atomIdx</em>&nbsp;</td><td>Index of atom to flip.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Improvement achieved by flipping the atom. </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00960">960</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l00774">flipAtom()</a>, and <a class="el" href="variablestate_8h-source.html#l01003">isActive()</a>.
<p>
Referenced by <a class="el" href="maxwalksat_8h-source.html#l00683">MaxWalkSat::calculateImprovement()</a>.<div class="fragment"><pre class="fragment"><a name="l00961"></a>00961   {
<a name="l00962"></a>00962     <span class="keywordflow">if</span> (lazy_ &amp;&amp; !<a class="code" href="classVariableState.html#d1809e4857db8f403c53948b0ba9e960">isActive</a>(atomIdx))
<a name="l00963"></a>00963     {
<a name="l00964"></a>00964         <span class="comment">// First flip the atom to activate it, then flip it back</span>
<a name="l00965"></a>00965       <a class="code" href="classVariableState.html#a71f608d3613ba9ceae3b0f5e25a61c9">flipAtom</a>(atomIdx);
<a name="l00966"></a>00966       <a class="code" href="classVariableState.html#a71f608d3613ba9ceae3b0f5e25a61c9">flipAtom</a>(atomIdx);
<a name="l00967"></a>00967     }
<a name="l00968"></a>00968     <span class="keywordtype">long</span> <span class="keywordtype">double</span> improvement = makeCost_[atomIdx] - breakCost_[atomIdx];
<a name="l00969"></a>00969     <span class="keywordflow">return</span> improvement;
<a name="l00970"></a>00970   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9082644cc8bc821e0ad8abd85bf11f80"></a><!-- doxytag: member="VariableState::activateAtom" ref="9082644cc8bc821e0ad8abd85bf11f80" args="(const int &amp;atomIdx, const bool &amp;ignoreActivePreds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::activateAtom           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>ignoreActivePreds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If in lazy mode, an atom is activated and all clauses activated by this atom are added to the state. 
<p>
If in eager mode, nothing happens.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atomIdx</em>&nbsp;</td><td>Index of atom to be activated. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l00978">978</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l00292">addNewClauses()</a>, <a class="el" href="variablestate_8h-source.html#l02101">getActiveClauses()</a>, <a class="el" href="domain_8h-source.html#l00311">Domain::getDB()</a>, <a class="el" href="variablestate_8h-source.html#l01003">isActive()</a>, and <a class="el" href="database_8h-source.html#l00688">Database::setActiveStatus()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l00726">setValueOfAtom()</a>.<div class="fragment"><pre class="fragment"><a name="l00979"></a>00979   {
<a name="l00980"></a>00980       <span class="comment">// Lazy version: if atom is not active, we need to activate clauses</span>
<a name="l00981"></a>00981       <span class="comment">// and take their cost into account</span>
<a name="l00982"></a>00982     <span class="keywordflow">if</span> (lazy_ &amp;&amp; !<a class="code" href="classVariableState.html#d1809e4857db8f403c53948b0ba9e960">isActive</a>(atomIdx))
<a name="l00983"></a>00983     {
<a name="l00984"></a>00984       <a class="code" href="classPredicate.html">Predicate</a>* p =
<a name="l00985"></a>00985         gndPredHashArray_[atomIdx - 1]-&gt;createEquivalentPredicate(domain_);
<a name="l00986"></a>00986       <a class="code" href="classVariableState.html#1944a7ef1d312dab635ad19801ba13f7">getActiveClauses</a>(p, newClauses_, <span class="keyword">true</span>, ignoreActivePreds);
<a name="l00987"></a>00987         <span class="comment">// Add the clauses and preds and fill info arrays</span>
<a name="l00988"></a>00988       <span class="keywordtype">bool</span> initial = <span class="keyword">false</span>;
<a name="l00989"></a>00989       <a class="code" href="classVariableState.html#2748a93f222dafedaf7443634e234ddd">addNewClauses</a>(initial);
<a name="l00990"></a>00990         <span class="comment">// Set active status in db</span>
<a name="l00991"></a>00991       domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>()-&gt;<a class="code" href="classDatabase.html#60d5fbbfcda7a0e255e3727f4b7b148d">setActiveStatus</a>(p, <span class="keyword">true</span>);
<a name="l00992"></a>00992       activeAtoms_++;
<a name="l00993"></a>00993       <span class="keyword">delete</span> p;
<a name="l00994"></a>00994     }        
<a name="l00995"></a>00995   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d1809e4857db8f403c53948b0ba9e960"></a><!-- doxytag: member="VariableState::isActive" ref="d1809e4857db8f403c53948b0ba9e960" args="(const int &amp;atomIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VariableState::isActive           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if an atom is active. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atomIdx</em>&nbsp;</td><td>Index of atom to be checked. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true, if atom is active, otherwise false. </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01003">1003</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="database_8h-source.html#l00546">Database::getActiveStatus()</a>, and <a class="el" href="domain_8h-source.html#l00311">Domain::getDB()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l00978">activateAtom()</a>, <a class="el" href="variablestate_8h-source.html#l00960">getImprovementByFlipping()</a>, and <a class="el" href="variablestate_8h-source.html#l00726">setValueOfAtom()</a>.<div class="fragment"><pre class="fragment"><a name="l01004"></a>01004   {
<a name="l01005"></a>01005     <span class="keywordflow">return</span> domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>()-&gt;<a class="code" href="classDatabase.html#a57622c524765825fb8ca985d84733b0">getActiveStatus</a>(gndPredHashArray_[atomIdx-1]);
<a name="l01006"></a>01006   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d827fe2df8b496ba5ba583514caa89ea"></a><!-- doxytag: member="VariableState::isActive" ref="d827fe2df8b496ba5ba583514caa89ea" args="(const Predicate *pred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VariableState::isActive           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPredicate.html">Predicate</a> *&nbsp;</td>
          <td class="paramname"> <em>pred</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if an atom is active. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td><a class="el" href="classPredicate.html">Predicate</a> to be checked. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true, if atom is active, otherwise false. </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01014">1014</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="database_8h-source.html#l00546">Database::getActiveStatus()</a>, and <a class="el" href="domain_8h-source.html#l00311">Domain::getDB()</a>.<div class="fragment"><pre class="fragment"><a name="l01015"></a>01015   {
<a name="l01016"></a>01016     <span class="keywordflow">return</span> domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>()-&gt;<a class="code" href="classDatabase.html#a57622c524765825fb8ca985d84733b0">getActiveStatus</a>(pred);
<a name="l01017"></a>01017   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8bda003606fd8a852f44a988124adb19"></a><!-- doxytag: member="VariableState::addBreakCostToAtomsInClause" ref="8bda003606fd8a852f44a988124adb19" args="(const int &amp;clauseIdx, const long double &amp;cost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::addBreakCostToAtomsInClause           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>clauseIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double &amp;&nbsp;</td>
          <td class="paramname"> <em>cost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Increases breakCost of all atoms in a given clause. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clauseIdx</em>&nbsp;</td><td>Index of clause whose atoms' breakCost is altered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cost</em>&nbsp;</td><td>Cost to be added to atoms' breakCost. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01111">1111</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01291">getClauseSize()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l00774">flipAtom()</a>.<div class="fragment"><pre class="fragment"><a name="l01113"></a>01113   {
<a name="l01114"></a>01114     <span class="keyword">register</span> <span class="keywordtype">int</span> size = <a class="code" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a>(clauseIdx);
<a name="l01115"></a>01115     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++)
<a name="l01116"></a>01116     {
<a name="l01117"></a>01117       <span class="keyword">register</span> <span class="keywordtype">int</span> lit = clause_[clauseIdx][i];
<a name="l01118"></a>01118       breakCost_[abs(lit)] += cost;
<a name="l01119"></a>01119     }
<a name="l01120"></a>01120   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="875cd0493e8d3ee050ef661ac01a7bcf"></a><!-- doxytag: member="VariableState::subtractBreakCostFromAtomsInClause" ref="875cd0493e8d3ee050ef661ac01a7bcf" args="(const int &amp;clauseIdx, const long double &amp;cost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::subtractBreakCostFromAtomsInClause           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>clauseIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double &amp;&nbsp;</td>
          <td class="paramname"> <em>cost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decreases breakCost of all atoms in a given clause. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clauseIdx</em>&nbsp;</td><td>Index of clause whose atoms' breakCost is altered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cost</em>&nbsp;</td><td>Cost to be subtracted from atoms' breakCost. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01128">1128</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01291">getClauseSize()</a>.<div class="fragment"><pre class="fragment"><a name="l01130"></a>01130   {
<a name="l01131"></a>01131     <span class="keyword">register</span> <span class="keywordtype">int</span> size = <a class="code" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a>(clauseIdx);
<a name="l01132"></a>01132     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++)
<a name="l01133"></a>01133     {
<a name="l01134"></a>01134       <span class="keyword">register</span> <span class="keywordtype">int</span> lit = clause_[clauseIdx][i];
<a name="l01135"></a>01135       breakCost_[abs(lit)] -= cost;
<a name="l01136"></a>01136     }
<a name="l01137"></a>01137   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d1574f8f2d9106457d6bb1b2d3282d60"></a><!-- doxytag: member="VariableState::addMakeCost" ref="d1574f8f2d9106457d6bb1b2d3282d60" args="(const int &amp;atomIdx, const long double &amp;cost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::addMakeCost           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double &amp;&nbsp;</td>
          <td class="paramname"> <em>cost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Increases makeCost of an atom. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atomIdx</em>&nbsp;</td><td>Index of atom whose makeCost is altered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cost</em>&nbsp;</td><td>Cost to be added to atom's makeCost. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01145">1145</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l00774">flipAtom()</a>.<div class="fragment"><pre class="fragment"><a name="l01146"></a>01146   {
<a name="l01147"></a>01147     makeCost_[atomIdx] += cost;
<a name="l01148"></a>01148   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4557a6ec0c103778dea9032a930b8f4e"></a><!-- doxytag: member="VariableState::subtractMakeCost" ref="4557a6ec0c103778dea9032a930b8f4e" args="(const int &amp;atomIdx, const long double &amp;cost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::subtractMakeCost           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double &amp;&nbsp;</td>
          <td class="paramname"> <em>cost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decreases makeCost of an atom. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atomIdx</em>&nbsp;</td><td>Index of atom whose makeCost is altered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cost</em>&nbsp;</td><td>Cost to be subtracted from atom's makeCost. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01156">1156</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.<div class="fragment"><pre class="fragment"><a name="l01157"></a>01157   {
<a name="l01158"></a>01158     makeCost_[atomIdx] -= cost;
<a name="l01159"></a>01159   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="189a058bc545cb3f284cf479d45dd6eb"></a><!-- doxytag: member="VariableState::addMakeCostToAtomsInClause" ref="189a058bc545cb3f284cf479d45dd6eb" args="(const int &amp;clauseIdx, const long double &amp;cost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::addMakeCostToAtomsInClause           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>clauseIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double &amp;&nbsp;</td>
          <td class="paramname"> <em>cost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Increases makeCost of all atoms in a given clause. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clauseIdx</em>&nbsp;</td><td>Index of clause whose atoms' makeCost is altered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cost</em>&nbsp;</td><td>Cost to be added to atoms' makeCost. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01167">1167</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01291">getClauseSize()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l00774">flipAtom()</a>.<div class="fragment"><pre class="fragment"><a name="l01169"></a>01169   {
<a name="l01170"></a>01170     <span class="keyword">register</span> <span class="keywordtype">int</span> size = <a class="code" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a>(clauseIdx);
<a name="l01171"></a>01171     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++)
<a name="l01172"></a>01172     {
<a name="l01173"></a>01173       <span class="keyword">register</span> <span class="keywordtype">int</span> lit = clause_[clauseIdx][i];
<a name="l01174"></a>01174       makeCost_[abs(lit)] += cost;
<a name="l01175"></a>01175     }
<a name="l01176"></a>01176   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="884bd8ade0d0e51f2c300e66eff68fc9"></a><!-- doxytag: member="VariableState::subtractMakeCostFromAtomsInClause" ref="884bd8ade0d0e51f2c300e66eff68fc9" args="(const int &amp;clauseIdx, const long double &amp;cost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::subtractMakeCostFromAtomsInClause           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>clauseIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long double &amp;&nbsp;</td>
          <td class="paramname"> <em>cost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decreases makeCost of all atoms in a given clause. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clauseIdx</em>&nbsp;</td><td>Index of clause whose atoms' makeCost is altered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cost</em>&nbsp;</td><td>Cost to be subtracted from atoms' makeCost. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01184">1184</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01291">getClauseSize()</a>.<div class="fragment"><pre class="fragment"><a name="l01186"></a>01186   {
<a name="l01187"></a>01187     <span class="keyword">register</span> <span class="keywordtype">int</span> size = <a class="code" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a>(clauseIdx);
<a name="l01188"></a>01188     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++)
<a name="l01189"></a>01189     {
<a name="l01190"></a>01190       <span class="keyword">register</span> <span class="keywordtype">int</span> lit = clause_[clauseIdx][i];
<a name="l01191"></a>01191       makeCost_[abs(lit)] -= cost;
<a name="l01192"></a>01192     }
<a name="l01193"></a>01193   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="9a385abc27c6cf5d891c52204a8b9faa"></a><!-- doxytag: member="VariableState::getTrueLiteralOtherThan" ref="9a385abc27c6cf5d891c52204a8b9faa" args="(const int &amp;clauseIdx, const int &amp;atomIdx1, const int &amp;atomIdx2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int VariableState::getTrueLiteralOtherThan           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>clauseIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a true literal in a clause other than the two given. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clauseIdx</em>&nbsp;</td><td>Index of clause from which literal is retrieved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>atomIdx1</em>&nbsp;</td><td>Index of first atom excluded from search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>atomIdx2</em>&nbsp;</td><td>Index of second atom excluded from search.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Index of atom found. </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01204">1204</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01291">getClauseSize()</a>, and <a class="el" href="variablestate_8h-source.html#l01224">isTrueLiteral()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l00774">flipAtom()</a>.<div class="fragment"><pre class="fragment"><a name="l01207"></a>01207   {
<a name="l01208"></a>01208     <span class="keyword">register</span> <span class="keywordtype">int</span> size = <a class="code" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a>(clauseIdx);
<a name="l01209"></a>01209     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++)
<a name="l01210"></a>01210     {
<a name="l01211"></a>01211       <span class="keyword">register</span> <span class="keywordtype">int</span> lit = clause_[clauseIdx][i];
<a name="l01212"></a>01212       <span class="keyword">register</span> <span class="keywordtype">int</span> v = abs(lit);
<a name="l01213"></a>01213       <span class="keywordflow">if</span> (<a class="code" href="classVariableState.html#a6cd0ba26bb4d5c3f7b19d0cd76f3317">isTrueLiteral</a>(lit) &amp;&amp; v != atomIdx1 &amp;&amp; v != atomIdx2)
<a name="l01214"></a>01214         <span class="keywordflow">return</span> v;
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216       <span class="comment">// If we're here, then no other true lit exists</span>
<a name="l01217"></a>01217     assert(<span class="keyword">false</span>);
<a name="l01218"></a>01218     <span class="keywordflow">return</span> -1;
<a name="l01219"></a>01219   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2464e6883cae56360dfdccd4704e9a34"></a><!-- doxytag: member="VariableState::getRandomTrueLitInClause" ref="2464e6883cae56360dfdccd4704e9a34" args="(const int &amp;clauseIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int VariableState::getRandomTrueLitInClause           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>clauseIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the index of a random true literal in a clause. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clauseIdx</em>&nbsp;</td><td>Index of clause from which the literal is retrieved. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Index of the atom retrieved. </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01251">1251</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01291">getClauseSize()</a>, and <a class="el" href="variablestate_8h-source.html#l01224">isTrueLiteral()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l00657">getIndexOfAtomInRandomFalseClause()</a>, and <a class="el" href="maxwalksat_8h-source.html#l00406">MaxWalkSat::pickBest()</a>.<div class="fragment"><pre class="fragment"><a name="l01252"></a>01252   {
<a name="l01253"></a>01253     assert(numTrueLits_[clauseIdx] &gt; 0);
<a name="l01254"></a>01254     <span class="keywordtype">int</span> trueLit = random()%numTrueLits_[clauseIdx];
<a name="l01255"></a>01255     <span class="keywordtype">int</span> whichTrueLit = 0;
<a name="l01256"></a>01256     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a>(clauseIdx); i++)
<a name="l01257"></a>01257     {
<a name="l01258"></a>01258       <span class="keywordtype">int</span> lit = clause_[clauseIdx][i];
<a name="l01259"></a>01259       <span class="keywordtype">int</span> atm = abs(lit);
<a name="l01260"></a>01260         <span class="comment">// True literal</span>
<a name="l01261"></a>01261       <span class="keywordflow">if</span> (<a class="code" href="classVariableState.html#a6cd0ba26bb4d5c3f7b19d0cd76f3317">isTrueLiteral</a>(lit))
<a name="l01262"></a>01262         <span class="keywordflow">if</span> (trueLit == whichTrueLit++)
<a name="l01263"></a>01263           <span class="keywordflow">return</span> atm;
<a name="l01264"></a>01264     }
<a name="l01265"></a>01265       <span class="comment">// If we're here, then no other true lit exists</span>
<a name="l01266"></a>01266     assert(<span class="keyword">false</span>);
<a name="l01267"></a>01267     <span class="keywordflow">return</span> -1;
<a name="l01268"></a>01268   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="48db641f2970801eefcb83a0147d9173"></a><!-- doxytag: member="VariableState::getBlockIndex" ref="48db641f2970801eefcb83a0147d9173" args="(const int &amp;atomIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int VariableState::getBlockIndex           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the index of the block which the atom with index atomIdx is in. 
<p>
If not in any, returns -1. 
<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01334">1334</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.
<p>
Referenced by <a class="el" href="maxwalksat_8h-source.html#l00683">MaxWalkSat::calculateImprovement()</a>, <a class="el" href="simulatedtempering_8h-source.html#l00199">SimulatedTempering::infer()</a>, <a class="el" href="variablestate_8h-source.html#l00450">initRandom()</a>, <a class="el" href="mcmc_8h-source.html#l00364">MCMC::performGibbsStep()</a>, <a class="el" href="maxwalksat_8h-source.html#l00345">MaxWalkSat::pickRandom()</a>, and <a class="el" href="mcmc_8h-source.html#l00257">MCMC::randomInitGndPredsTruthValues()</a>.<div class="fragment"><pre class="fragment"><a name="l01335"></a>01335   {
<a name="l01336"></a>01336     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; blocks_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01337"></a>01337     {
<a name="l01338"></a>01338       <span class="keywordtype">int</span> blockIdx = (*blocks_)[i].find(atomIdx);
<a name="l01339"></a>01339       <span class="keywordflow">if</span> (blockIdx &gt;= 0)
<a name="l01340"></a>01340         <span class="keywordflow">return</span> i;
<a name="l01341"></a>01341     }
<a name="l01342"></a>01342     <span class="keywordflow">return</span> -1;
<a name="l01343"></a>01343   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="770da3b8b33f4aeff3de22e0ddc451e7"></a><!-- doxytag: member="VariableState::makeUnitCosts" ref="770da3b8b33f4aeff3de22e0ddc451e7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::makeUnitCosts           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Turns all costs into units. 
<p>
Positive costs are converted to 1, negative costs are converted to -1 
<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01380">1380</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l00530">initMakeBreakCostWatch()</a>, and <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.
<p>
Referenced by <a class="el" href="mcsat_8h-source.html#l00111">MCSAT::init()</a>.<div class="fragment"><pre class="fragment"><a name="l01381"></a>01381   {
<a name="l01382"></a>01382     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauseCost_.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01383"></a>01383     {
<a name="l01384"></a>01384       <span class="keywordflow">if</span> (clauseCost_[i] &gt; 0) clauseCost_[i] = 1.0;
<a name="l01385"></a>01385       <span class="keywordflow">else</span>
<a name="l01386"></a>01386       {
<a name="l01387"></a>01387         assert(clauseCost_[i] &lt; 0);
<a name="l01388"></a>01388         clauseCost_[i] = -1.0;
<a name="l01389"></a>01389       }
<a name="l01390"></a>01390     }
<a name="l01391"></a>01391     <span class="keywordflow">if</span> (vsdebug) cout &lt;&lt; <span class="stringliteral">"Made unit costs"</span> &lt;&lt; endl;
<a name="l01392"></a>01392     <a class="code" href="classVariableState.html#2c53e96f2f2f3ed8978fae90a7daad36">initMakeBreakCostWatch</a>();
<a name="l01393"></a>01393   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="27096b8568bf1595981b75b2922560e3"></a><!-- doxytag: member="VariableState::getNumClauseGndings" ref="27096b8568bf1595981b75b2922560e3" args="(Array&lt; double &gt; *const &amp;numGndings, bool tv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::getNumClauseGndings           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray.html">Array</a>&lt; double &gt; *const &amp;&nbsp;</td>
          <td class="paramname"> <em>numGndings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>tv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of (true or false) clause groundings in this state. 
<p>
If eager, the first order clause frequencies in the mrf are used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numGndings</em>&nbsp;</td><td><a class="el" href="classArray.html">Array</a> being filled with values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clauseCnt</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01478">1478</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="mln_8h-source.html#l00100">MLN::getNumClauses()</a>, <a class="el" href="variablestate_8h-source.html#l01224">isTrueLiteral()</a>, and <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.
<p>
Referenced by <a class="el" href="simulatedtempering_8h-source.html#l00199">SimulatedTempering::infer()</a>, <a class="el" href="maxwalksat_8h-source.html#l00173">MaxWalkSat::infer()</a>, and <a class="el" href="mcmc_8h-source.html#l00364">MCMC::performGibbsStep()</a>.<div class="fragment"><pre class="fragment"><a name="l01479"></a>01479   {
<a name="l01480"></a>01480     <span class="comment">// TODO: lazy version</span>
<a name="l01481"></a>01481     IntPairItr itr;
<a name="l01482"></a>01482     IntPair *clauseFrequencies;
<a name="l01483"></a>01483     
<a name="l01484"></a>01484       <span class="comment">// numGndings should have been initialized with non-negative values</span>
<a name="l01485"></a>01485     <span class="keywordtype">int</span> clauseCnt = numGndings-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>();
<a name="l01486"></a>01486     assert(clauseCnt == mln_-&gt;<a class="code" href="classMLN.html#9af698a87c5b518e9ce18755bc414231">getNumClauses</a>());
<a name="l01487"></a>01487     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> clauseno = 0; clauseno &lt; clauseCnt; clauseno++)
<a name="l01488"></a>01488       assert ((*numGndings)[clauseno] &gt;= 0);
<a name="l01489"></a>01489     
<a name="l01490"></a>01490     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndClauses_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01491"></a>01491     {
<a name="l01492"></a>01492       <a class="code" href="classGroundClause.html">GroundClause</a> *gndClause = (*gndClauses_)[i];
<a name="l01493"></a>01493       <span class="keywordtype">int</span> satLitcnt = 0;
<a name="l01494"></a>01494       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; gndClause-&gt;getNumGroundPredicates(); j++)
<a name="l01495"></a>01495       {
<a name="l01496"></a>01496         <span class="keywordtype">int</span> lit = gndClause-&gt;getGroundPredicateIndex(j);
<a name="l01497"></a>01497         <span class="keywordflow">if</span> (<a class="code" href="classVariableState.html#a6cd0ba26bb4d5c3f7b19d0cd76f3317">isTrueLiteral</a>(lit)) satLitcnt++;
<a name="l01498"></a>01498       }
<a name="l01499"></a>01499       <span class="comment">//int satLitcnt = getNumTrueLits(i);</span>
<a name="l01500"></a>01500       <span class="keywordflow">if</span> (tv &amp;&amp; satLitcnt == 0)
<a name="l01501"></a>01501         <span class="keywordflow">continue</span>;
<a name="l01502"></a>01502       <span class="keywordflow">if</span> (!tv &amp;&amp; satLitcnt &gt; 0)
<a name="l01503"></a>01503         <span class="keywordflow">continue</span>;
<a name="l01504"></a>01504 
<a name="l01505"></a>01505       clauseFrequencies = gndClause-&gt;getClauseFrequencies();
<a name="l01506"></a>01506       <span class="keywordflow">for</span> (itr = clauseFrequencies-&gt;begin();
<a name="l01507"></a>01507            itr != clauseFrequencies-&gt;end(); itr++)
<a name="l01508"></a>01508       {
<a name="l01509"></a>01509         <span class="keywordtype">int</span> clauseno = itr-&gt;first;
<a name="l01510"></a>01510         <span class="keywordtype">int</span> frequency = itr-&gt;second;
<a name="l01511"></a>01511         (*numGndings)[clauseno] += frequency;
<a name="l01512"></a>01512       }
<a name="l01513"></a>01513     }
<a name="l01514"></a>01514   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a082702ae807ec09afb99391faf58121"></a><!-- doxytag: member="VariableState::getNumClauseGndings" ref="a082702ae807ec09afb99391faf58121" args="(double numGndings[], int clauseCnt, bool tv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::getNumClauseGndings           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>numGndings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clauseCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>tv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of (true or false) clause groundings in this state. 
<p>
If eager, the first order clause frequencies in the mrf are used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numGndings</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clauseCnt</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01524">1524</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01046">getNumTrueLits()</a>, and <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.<div class="fragment"><pre class="fragment"><a name="l01525"></a>01525   {
<a name="l01526"></a>01526     <span class="comment">// TODO: lazy version</span>
<a name="l01527"></a>01527     IntPairItr itr;
<a name="l01528"></a>01528     IntPair *clauseFrequencies;
<a name="l01529"></a>01529     
<a name="l01530"></a>01530     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> clauseno = 0; clauseno &lt; clauseCnt; clauseno++)
<a name="l01531"></a>01531       numGndings[clauseno] = 0;
<a name="l01532"></a>01532     
<a name="l01533"></a>01533     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndClauses_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01534"></a>01534     {
<a name="l01535"></a>01535       <a class="code" href="classGroundClause.html">GroundClause</a> *gndClause = (*gndClauses_)[i];
<a name="l01536"></a>01536       <span class="keywordtype">int</span> satLitcnt = <a class="code" href="classVariableState.html#b6a9a11612400d7eebd0c4c50731ee65">getNumTrueLits</a>(i);
<a name="l01537"></a>01537       <span class="keywordflow">if</span> (tv &amp;&amp; satLitcnt == 0)
<a name="l01538"></a>01538         <span class="keywordflow">continue</span>;
<a name="l01539"></a>01539       <span class="keywordflow">if</span> (!tv &amp;&amp; satLitcnt &gt; 0)
<a name="l01540"></a>01540         <span class="keywordflow">continue</span>;
<a name="l01541"></a>01541 
<a name="l01542"></a>01542       clauseFrequencies = gndClause-&gt;getClauseFrequencies();
<a name="l01543"></a>01543       <span class="keywordflow">for</span> (itr = clauseFrequencies-&gt;begin();
<a name="l01544"></a>01544            itr != clauseFrequencies-&gt;end(); itr++)
<a name="l01545"></a>01545       {
<a name="l01546"></a>01546         <span class="keywordtype">int</span> clauseno = itr-&gt;first;
<a name="l01547"></a>01547         <span class="keywordtype">int</span> frequency = itr-&gt;second;
<a name="l01548"></a>01548         numGndings[clauseno] += frequency;
<a name="l01549"></a>01549       }
<a name="l01550"></a>01550     }
<a name="l01551"></a>01551   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a5927ac9488727ae38468de0f1488b6e"></a><!-- doxytag: member="VariableState::getNumClauseGndingsWithUnknown" ref="a5927ac9488727ae38468de0f1488b6e" args="(double numGndings[], int clauseCnt, bool tv, const Array&lt; bool &gt; *const &amp;unknownPred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::getNumClauseGndingsWithUnknown           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>numGndings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clauseCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArray.html">Array</a>&lt; bool &gt; *const &amp;&nbsp;</td>
          <td class="paramname"> <em>unknownPred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the number of (true or false) clause groundings in this state. 
<p>
If eager, the first order clause frequencies in the mrf are used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numGndings</em>&nbsp;</td><td>Will hold the number of groundings for each first-order clause. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clauseCnt</em>&nbsp;</td><td>Number of first-order clauses whose groundings are being counted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td>If true, true groundings are counted, otherwise false groundings. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>unknownPred</em>&nbsp;</td><td>If pred is marked as unknown, it is ignored in the count </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01564">1564</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l00630">getNumAtoms()</a>, <a class="el" href="variablestate_8h-source.html#l01224">isTrueLiteral()</a>, and <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.<div class="fragment"><pre class="fragment"><a name="l01567"></a>01567   {
<a name="l01568"></a>01568     assert(unknownPred-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>() == <a class="code" href="classVariableState.html#bc520a99648ee29ef9447b86c26d9faf">getNumAtoms</a>());
<a name="l01569"></a>01569     IntPairItr itr;
<a name="l01570"></a>01570     IntPair *clauseFrequencies;
<a name="l01571"></a>01571     
<a name="l01572"></a>01572     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> clauseno = 0; clauseno &lt; clauseCnt; clauseno++)
<a name="l01573"></a>01573       numGndings[clauseno] = 0;
<a name="l01574"></a>01574     
<a name="l01575"></a>01575     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndClauses_-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01576"></a>01576     {
<a name="l01577"></a>01577       <a class="code" href="classGroundClause.html">GroundClause</a> *gndClause = (*gndClauses_)[i];
<a name="l01578"></a>01578       <span class="keywordtype">int</span> satLitcnt = 0;
<a name="l01579"></a>01579       <span class="keywordtype">bool</span> unknown = <span class="keyword">false</span>;
<a name="l01580"></a>01580       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; gndClause-&gt;getNumGroundPredicates(); j++)
<a name="l01581"></a>01581       {
<a name="l01582"></a>01582         <span class="keywordtype">int</span> lit = gndClause-&gt;getGroundPredicateIndex(j);
<a name="l01583"></a>01583         <span class="keywordflow">if</span> ((*unknownPred)[abs(lit) - 1])
<a name="l01584"></a>01584         {
<a name="l01585"></a>01585           unknown = <span class="keyword">true</span>;
<a name="l01586"></a>01586           <span class="keywordflow">continue</span>;
<a name="l01587"></a>01587         }
<a name="l01588"></a>01588         <span class="keywordflow">if</span> (<a class="code" href="classVariableState.html#a6cd0ba26bb4d5c3f7b19d0cd76f3317">isTrueLiteral</a>(lit)) satLitcnt++;
<a name="l01589"></a>01589       }
<a name="l01590"></a>01590       
<a name="l01591"></a>01591       <span class="keywordflow">if</span> (tv &amp;&amp; satLitcnt == 0)
<a name="l01592"></a>01592         <span class="keywordflow">continue</span>;
<a name="l01593"></a>01593       <span class="keywordflow">if</span> (!tv &amp;&amp; (satLitcnt &gt; 0 || unknown))
<a name="l01594"></a>01594         <span class="keywordflow">continue</span>;
<a name="l01595"></a>01595 
<a name="l01596"></a>01596       clauseFrequencies = gndClause-&gt;getClauseFrequencies();
<a name="l01597"></a>01597       <span class="keywordflow">for</span> (itr = clauseFrequencies-&gt;begin();
<a name="l01598"></a>01598            itr != clauseFrequencies-&gt;end(); itr++)
<a name="l01599"></a>01599       {
<a name="l01600"></a>01600         <span class="keywordtype">int</span> clauseno = itr-&gt;first;
<a name="l01601"></a>01601         <span class="keywordtype">int</span> frequency = itr-&gt;second;
<a name="l01602"></a>01602         numGndings[clauseno] += frequency;
<a name="l01603"></a>01603       }
<a name="l01604"></a>01604     }
<a name="l01605"></a>01605   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="51328d98874eae61096c94b6626f14df"></a><!-- doxytag: member="VariableState::setOthersInBlockToFalse" ref="51328d98874eae61096c94b6626f14df" args="(const int &amp;atomIdx, const int &amp;blockIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::setOthersInBlockToFalse           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>blockIdx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the truth values of all atoms in a block except for the one given. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atomIdx</em>&nbsp;</td><td>Index of atom in block exempt from being set to false. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockIdx</em>&nbsp;</td><td>Index of block whose atoms are set to false. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01613">1613</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l00726">setValueOfAtom()</a>, and <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l02228">addOneAtomToEachBlock()</a>, and <a class="el" href="variablestate_8h-source.html#l00479">initBlocksRandom()</a>.<div class="fragment"><pre class="fragment"><a name="l01615"></a>01615   {
<a name="l01616"></a>01616     <a class="code" href="classArray.html">Array&lt;int&gt;</a>&amp; block = (*blocks_)[blockIdx];
<a name="l01617"></a>01617     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; block.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01618"></a>01618     {
<a name="l01619"></a>01619         <span class="comment">// Atom not the one specified and not fixed</span>
<a name="l01620"></a>01620       <span class="keywordflow">if</span> (i != atomIdx &amp;&amp; fixedAtom_[block[i] + 1] == 0)
<a name="l01621"></a>01621         <a class="code" href="classVariableState.html#5ca24c889ca9ea4ec1ad6fa64b59e348">setValueOfAtom</a>(block[i] + 1, <span class="keyword">false</span>);
<a name="l01622"></a>01622     }
<a name="l01623"></a>01623   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="7929d260582cb7cc66fc7af5eb7c359b"></a><!-- doxytag: member="VariableState::fixAtom" ref="7929d260582cb7cc66fc7af5eb7c359b" args="(const int &amp;atomIdx, const bool &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::fixAtom           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>atomIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fixes an atom to a truth value. 
<p>
This means the atom can not change its truth values again. If the atom has already been fixed to the opposite value, then we have a contradiction and the program terminates.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>atomIdx</em>&nbsp;</td><td>Index of atom to be fixed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Truth value to which the atom is fixed. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01634">1634</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l00726">setValueOfAtom()</a>.
<p>
Referenced by <a class="el" href="unitpropagation_8h-source.html#l00094">UnitPropagation::infer()</a>.<div class="fragment"><pre class="fragment"><a name="l01635"></a>01635   {
<a name="l01636"></a>01636     assert(atomIdx &gt; 0);
<a name="l01637"></a>01637       <span class="comment">// If already fixed to opp. sense, then contradiction</span>
<a name="l01638"></a>01638     <span class="keywordflow">if</span> ((fixedAtom_[atomIdx] == 1 &amp;&amp; value == <span class="keyword">false</span>) ||
<a name="l01639"></a>01639         (fixedAtom_[atomIdx] == -1 &amp;&amp; value == <span class="keyword">true</span>))
<a name="l01640"></a>01640     {
<a name="l01641"></a>01641       cout &lt;&lt; <span class="stringliteral">"Contradiction: Tried to fix atom "</span> &lt;&lt; atomIdx &lt;&lt;
<a name="l01642"></a>01642       <span class="stringliteral">" to true and false ... exiting."</span> &lt;&lt; endl;
<a name="l01643"></a>01643       exit(0);
<a name="l01644"></a>01644     }
<a name="l01645"></a>01645 
<a name="l01646"></a>01646     <span class="keywordflow">if</span> (vsdebug)
<a name="l01647"></a>01647     {
<a name="l01648"></a>01648       cout &lt;&lt; <span class="stringliteral">"Fixing "</span>;
<a name="l01649"></a>01649       (*gndPreds_)[atomIdx - 1]-&gt;print(cout, domain_);
<a name="l01650"></a>01650       cout &lt;&lt; <span class="stringliteral">" to "</span> &lt;&lt; value &lt;&lt; endl;
<a name="l01651"></a>01651     }
<a name="l01652"></a>01652     
<a name="l01653"></a>01653     <a class="code" href="classVariableState.html#5ca24c889ca9ea4ec1ad6fa64b59e348">setValueOfAtom</a>(atomIdx, value);
<a name="l01654"></a>01654     fixedAtom_[atomIdx] = (value) ? 1 : -1;
<a name="l01655"></a>01655   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b80a4267b5c2ea04a786b5dd4c23d879"></a><!-- doxytag: member="VariableState::simplifyClauseFromFixedAtoms" ref="b80a4267b5c2ea04a786b5dd4c23d879" args="(const int &amp;clauseIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray.html">Array</a>&lt;int&gt;* VariableState::simplifyClauseFromFixedAtoms           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>clauseIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simplifies a clause using atoms which have been fixed. 
<p>
If clause is satisfied from the fixed atoms, this is marked in isSatisfied_ and an empty array is returned. If clause is empty and not satisfied, then a contradiction has occured. Otherwise, the simplified clause is returned.<p>
Returned array should be deleted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clauseIdx</em>&nbsp;</td><td>Index of the clause to be simplified </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Simplified clause </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01668">1668</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="array_8h-source.html#l00153">Array&lt; Type &gt;::append()</a>, <a class="el" href="array_8h-source.html#l00215">Array&lt; Type &gt;::clear()</a>, and <a class="el" href="variablestate_8h-source.html#l01291">getClauseSize()</a>.
<p>
Referenced by <a class="el" href="unitpropagation_8h-source.html#l00094">UnitPropagation::infer()</a>.<div class="fragment"><pre class="fragment"><a name="l01669"></a>01669   {
<a name="l01670"></a>01670     <a class="code" href="classArray.html">Array&lt;int&gt;</a>* returnArray = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;int&gt;</a>;
<a name="l01671"></a>01671       <span class="comment">// If already satisfied from fixed atoms, then return empty array</span>
<a name="l01672"></a>01672     <span class="keywordflow">if</span> (isSatisfied_[clauseIdx]) <span class="keywordflow">return</span> returnArray;
<a name="l01673"></a>01673 
<a name="l01674"></a>01674       <span class="comment">// Keeps track of pos. clause being satisfied or </span>
<a name="l01675"></a>01675       <span class="comment">// neg. clause being unsatisfied due to fixed atoms</span>
<a name="l01676"></a>01676     <span class="keywordtype">bool</span> isGood = (clauseCost_[clauseIdx] &gt; 0) ? <span class="keyword">false</span> : <span class="keyword">true</span>;
<a name="l01677"></a>01677       <span class="comment">// Keeps track of all atoms being fixed to false in a pos. clause</span>
<a name="l01678"></a>01678     <span class="keywordtype">bool</span> allFalseAtoms = (clauseCost_[clauseIdx] &gt; 0) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l01679"></a>01679       <span class="comment">// Check each literal in clause</span>
<a name="l01680"></a>01680     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classVariableState.html#12d6e101244182a1962c99cc016f4b78">getClauseSize</a>(clauseIdx); i++)
<a name="l01681"></a>01681     {
<a name="l01682"></a>01682       <span class="keywordtype">int</span> lit = clause_[clauseIdx][i];
<a name="l01683"></a>01683       <span class="keywordtype">int</span> fixedValue = fixedAtom_[abs(lit)];
<a name="l01684"></a>01684 
<a name="l01685"></a>01685       <span class="keywordflow">if</span> (clauseCost_[clauseIdx] &gt; 0)
<a name="l01686"></a>01686       { <span class="comment">// Pos. clause: check if clause is satisfied</span>
<a name="l01687"></a>01687         <span class="keywordflow">if</span> ((fixedValue == 1 &amp;&amp; lit &gt; 0) ||
<a name="l01688"></a>01688             (fixedValue == -1 &amp;&amp; lit &lt; 0))
<a name="l01689"></a>01689         { <span class="comment">// True fixed lit</span>
<a name="l01690"></a>01690           isGood = <span class="keyword">true</span>;
<a name="l01691"></a>01691           allFalseAtoms = <span class="keyword">false</span>;
<a name="l01692"></a>01692           returnArray-&gt;<a class="code" href="classArray.html#732046291e31f830757e0847280fb593">clear</a>();
<a name="l01693"></a>01693           <span class="keywordflow">break</span>;
<a name="l01694"></a>01694         }
<a name="l01695"></a>01695         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fixedValue == 0)
<a name="l01696"></a>01696         { <span class="comment">// Lit not fixed</span>
<a name="l01697"></a>01697           allFalseAtoms = <span class="keyword">false</span>;
<a name="l01698"></a>01698           returnArray-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(lit);
<a name="l01699"></a>01699         }
<a name="l01700"></a>01700       }
<a name="l01701"></a>01701       <span class="keywordflow">else</span>
<a name="l01702"></a>01702       { <span class="comment">// Neg. clause:</span>
<a name="l01703"></a>01703         assert(clauseCost_[clauseIdx] &lt; 0);
<a name="l01704"></a>01704         <span class="keywordflow">if</span> ((fixedValue == 1 &amp;&amp; lit &gt; 0) ||
<a name="l01705"></a>01705             (fixedValue == -1 &amp;&amp; lit &lt; 0))
<a name="l01706"></a>01706         { <span class="comment">// True fixed lit</span>
<a name="l01707"></a>01707           cout &lt;&lt; <span class="stringliteral">"Contradiction: Tried to fix atom "</span> &lt;&lt; abs(lit) &lt;&lt;
<a name="l01708"></a>01708           <span class="stringliteral">" to true in a negative clause ... exiting."</span> &lt;&lt; endl;
<a name="l01709"></a>01709           exit(0);
<a name="l01710"></a>01710         }
<a name="l01711"></a>01711         <span class="keywordflow">else</span>
<a name="l01712"></a>01712         { <span class="comment">// False fixed lit or non-fixed lit</span>
<a name="l01713"></a>01713           returnArray-&gt;<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(lit);
<a name="l01714"></a>01714             <span class="comment">// Non-fixed lit</span>
<a name="l01715"></a>01715           <span class="keywordflow">if</span> (fixedValue == 0) isGood = <span class="keyword">false</span>;          
<a name="l01716"></a>01716         }
<a name="l01717"></a>01717       }
<a name="l01718"></a>01718     }
<a name="l01719"></a>01719     <span class="keywordflow">if</span> (allFalseAtoms)
<a name="l01720"></a>01720     {
<a name="l01721"></a>01721       cout &lt;&lt; <span class="stringliteral">"Contradiction: All atoms in clause "</span> &lt;&lt; clauseIdx &lt;&lt;
<a name="l01722"></a>01722       <span class="stringliteral">" fixed to false ... exiting."</span> &lt;&lt; endl;
<a name="l01723"></a>01723       exit(0);
<a name="l01724"></a>01724     }
<a name="l01725"></a>01725     <span class="keywordflow">if</span> (isGood) isSatisfied_[clauseIdx] = <span class="keyword">true</span>;
<a name="l01726"></a>01726     <span class="keywordflow">return</span> returnArray;
<a name="l01727"></a>01727   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="127a243149f859dab21fcfd8279c29ad"></a><!-- doxytag: member="VariableState::isDeadClause" ref="127a243149f859dab21fcfd8279c29ad" args="(const int &amp;clauseIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool VariableState::isDeadClause           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>clauseIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if a clause is dead. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clauseIdx</em>&nbsp;</td><td>Index of clause being checked. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True, if clause is dead, otherwise false. </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01735">1735</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
Referenced by <a class="el" href="unitpropagation_8h-source.html#l00094">UnitPropagation::infer()</a>.<div class="fragment"><pre class="fragment"><a name="l01736"></a>01736   {
<a name="l01737"></a>01737     <span class="keywordflow">return</span> deadClause_[clauseIdx];
<a name="l01738"></a>01738   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4e30712524da7ecb7b450b98155dd717"></a><!-- doxytag: member="VariableState::killClauses" ref="4e30712524da7ecb7b450b98155dd717" args="(const int &amp;startClause)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::killClauses           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>startClause</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marks clauses as dead which were not good in the previous iteration of inference or are not picked according to a weighted coin flip. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startClause</em>&nbsp;</td><td>All clauses with index of this or greater are looked at to be killed. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01764">1764</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l01796">clauseGoodInPrevious()</a>, <a class="el" href="variablestate_8h-source.html#l00632">getNumClauses()</a>, and <a class="el" href="variablestate_8h-source.html#l00530">initMakeBreakCostWatch()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l00292">addNewClauses()</a>.<div class="fragment"><pre class="fragment"><a name="l01765"></a>01765   {
<a name="l01766"></a>01766     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = startClause; i &lt; <a class="code" href="classVariableState.html#703e262481d6c0b076799511af07df67">getNumClauses</a>(); i++)
<a name="l01767"></a>01767     {
<a name="l01768"></a>01768       <a class="code" href="classGroundClause.html">GroundClause</a>* clause = (*gndClauses_)[i];
<a name="l01769"></a>01769       <span class="keywordflow">if</span> ((<a class="code" href="classVariableState.html#e337445a944f87ab57d255fcf7fee119">clauseGoodInPrevious</a>(i)) &amp;&amp;
<a name="l01770"></a>01770           (clause-&gt;isHardClause() || random() &lt;= threshold_[i]))
<a name="l01771"></a>01771       {
<a name="l01772"></a>01772         <span class="keywordflow">if</span> (vsdebug)
<a name="l01773"></a>01773         {
<a name="l01774"></a>01774           cout &lt;&lt; <span class="stringliteral">"Keeping clause "</span>&lt;&lt; i &lt;&lt; <span class="stringliteral">" "</span>;
<a name="l01775"></a>01775           clause-&gt;print(cout, domain_, &amp;gndPredHashArray_);
<a name="l01776"></a>01776           cout &lt;&lt; endl;
<a name="l01777"></a>01777         }
<a name="l01778"></a>01778         deadClause_[i] = <span class="keyword">false</span>;
<a name="l01779"></a>01779       }
<a name="l01780"></a>01780       <span class="keywordflow">else</span>
<a name="l01781"></a>01781       {
<a name="l01782"></a>01782         deadClause_[i] = <span class="keyword">true</span>;
<a name="l01783"></a>01783       }
<a name="l01784"></a>01784     }
<a name="l01785"></a>01785     <a class="code" href="classVariableState.html#2c53e96f2f2f3ed8978fae90a7daad36">initMakeBreakCostWatch</a>();
<a name="l01786"></a>01786   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e337445a944f87ab57d255fcf7fee119"></a><!-- doxytag: member="VariableState::clauseGoodInPrevious" ref="e337445a944f87ab57d255fcf7fee119" args="(const int &amp;clauseIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool VariableState::clauseGoodInPrevious           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>clauseIdx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if a clause was good in the previous iteration of inference, i.e. 
<p>
if it is positive and satisfied or negative and unsatisfied.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clauseIdx</em>&nbsp;</td><td>Index of clause being checked. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true, if clause was good, otherwise false. </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01796">1796</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l01764">killClauses()</a>.<div class="fragment"><pre class="fragment"><a name="l01797"></a>01797   {
<a name="l01798"></a>01798     <span class="comment">//GroundClause* clause = (*gndClauses_)[clauseIdx];</span>
<a name="l01799"></a>01799     <span class="keywordtype">int</span> numSatLits = numTrueLits_[clauseIdx];
<a name="l01800"></a>01800       <span class="comment">// Num. of satisfied lits in previous iteration is stored in clause</span>
<a name="l01801"></a>01801     <span class="keywordflow">if</span> ((numSatLits &gt; 0 &amp;&amp; clauseCost_[clauseIdx] &gt; 0.0) ||
<a name="l01802"></a>01802         (numSatLits == 0 &amp;&amp; clauseCost_[clauseIdx] &lt; 0.0))
<a name="l01803"></a>01803       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01804"></a>01804     <span class="keywordflow">else</span>
<a name="l01805"></a>01805       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01806"></a>01806   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="0abdaf7a4b916cfc61907f09b68710c8"></a><!-- doxytag: member="VariableState::printLowState" ref="0abdaf7a4b916cfc61907f09b68710c8" args="(ostream &amp;out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::printLowState           </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints the best state found to a stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>Stream to which the state is printed. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01846">1846</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l00630">getNumAtoms()</a>.
<p>
Referenced by <a class="el" href="mcsat_8h-source.html#l00111">MCSAT::init()</a>.<div class="fragment"><pre class="fragment"><a name="l01847"></a>01847   {
<a name="l01848"></a>01848     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classVariableState.html#bc520a99648ee29ef9447b86c26d9faf">getNumAtoms</a>(); i++)
<a name="l01849"></a>01849     {
<a name="l01850"></a>01850       (*gndPreds_)[i]-&gt;print(out, domain_);
<a name="l01851"></a>01851       out &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; lowAtom_[i + 1] &lt;&lt; endl;
<a name="l01852"></a>01852     }
<a name="l01853"></a>01853   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2229f05fc17e02a969a178c9a2fe708c"></a><!-- doxytag: member="VariableState::printGndPred" ref="2229f05fc17e02a969a178c9a2fe708c" args="(const int &amp;predIndex, ostream &amp;out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::printGndPred           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>predIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints a ground predicate to a stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>predIndex</em>&nbsp;</td><td>Index of predicate to be printed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>Stream to which predicate is printed. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01861">1861</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
Referenced by <a class="el" href="unitpropagation_8h-source.html#l00166">UnitPropagation::getPredsWithNonZeroProb()</a>, <a class="el" href="sat_8h-source.html#l00125">SAT::getPredsWithNonZeroProb()</a>, <a class="el" href="mcmc_8h-source.html#l00131">MCMC::getPredsWithNonZeroProb()</a>, <a class="el" href="variablestate_8h-source.html#l01872">getTruePreds()</a>, <a class="el" href="unitpropagation_8h-source.html#l00148">UnitPropagation::printProbabilities()</a>, <a class="el" href="sat_8h-source.html#l00107">SAT::printProbabilities()</a>, <a class="el" href="mcmc_8h-source.html#l00110">MCMC::printProbabilities()</a>, <a class="el" href="unitpropagation_8h-source.html#l00197">UnitPropagation::printTruePreds()</a>, <a class="el" href="sat_8h-source.html#l00156">SAT::printTruePreds()</a>, and <a class="el" href="mcmc_8h-source.html#l00169">MCMC::printTruePreds()</a>.<div class="fragment"><pre class="fragment"><a name="l01862"></a>01862   {
<a name="l01863"></a>01863     (*gndPreds_)[predIndex]-&gt;print(out, domain_);
<a name="l01864"></a>01864   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e6903cc7c8abc7f43fa2f72e81dd0b94"></a><!-- doxytag: member="VariableState::getTruePreds" ref="e6903cc7c8abc7f43fa2f72e81dd0b94" args="(vector&lt; string &gt; &amp;truePreds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::getTruePreds           </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>truePreds</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Puts the predicates set to true in the best state to a stream into a vector in string form. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>truePreds</em>&nbsp;</td><td>vector being filled with true predicates </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01872">1872</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l00630">getNumAtoms()</a>, <a class="el" href="variablestate_8h-source.html#l00714">getValueOfLowAtom()</a>, and <a class="el" href="variablestate_8h-source.html#l01861">printGndPred()</a>.<div class="fragment"><pre class="fragment"><a name="l01873"></a>01873   {
<a name="l01874"></a>01874     truePreds.clear();
<a name="l01875"></a>01875     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classVariableState.html#bc520a99648ee29ef9447b86c26d9faf">getNumAtoms</a>(); i++)
<a name="l01876"></a>01876     {
<a name="l01877"></a>01877       <span class="keywordflow">if</span> (<a class="code" href="classVariableState.html#73ac1309ad13b2e21ff4904cb835610e">getValueOfLowAtom</a>(i + 1))
<a name="l01878"></a>01878       {
<a name="l01879"></a>01879         ostringstream oss(ostringstream::out);
<a name="l01880"></a>01880         <a class="code" href="classVariableState.html#2229f05fc17e02a969a178c9a2fe708c">printGndPred</a>(i, oss);
<a name="l01881"></a>01881         truePreds.push_back(oss.str());
<a name="l01882"></a>01882       }
<a name="l01883"></a>01883     }
<a name="l01884"></a>01884   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b097423bddeaf431723ade2b990c10ce"></a><!-- doxytag: member="VariableState::setAsEvidence" ref="b097423bddeaf431723ade2b990c10ce" args="(const GroundPredicate *const &amp;predicate, const bool &amp;trueEvidence)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::setAsEvidence           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGroundPredicate.html">GroundPredicate</a> *const &amp;&nbsp;</td>
          <td class="paramname"> <em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>trueEvidence</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a <a class="el" href="classGroundPredicate.html">GroundPredicate</a> to be evidence and sets its truth value. 
<p>
If it is already present as evidence with the given truth value, then nothing happens. If the predicate was a query, then additional clauses may be eliminated. <a class="el" href="classVariableState.html#a8f619357092cf7e5ac33d76c9e89afc">reinit()</a> should be called after this in order to ensure that the clause and atom information is correct.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>predicate</em>&nbsp;</td><td><a class="el" href="classGroundPredicate.html">GroundPredicate</a> to be set as evidence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trueEvidence</em>&nbsp;</td><td>The truth value of the predicate is set to this. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01896">1896</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="array_8h-source.html#l00354">Array&lt; Type &gt;::compress()</a>, <a class="el" href="hasharray_8h-source.html#l00339">HashArray&lt; Type, HashFn, EqualFn &gt;::compress()</a>, <a class="el" href="hasharray_8h-source.html#l00260">HashArray&lt; Type, HashFn, EqualFn &gt;::find()</a>, <a class="el" href="domain_8h-source.html#l00311">Domain::getDB()</a>, <a class="el" href="variablestate_8h-source.html#l00754">getNegOccurenceArray()</a>, <a class="el" href="variablestate_8h-source.html#l00763">getPosOccurenceArray()</a>, <a class="el" href="database_8h-source.html#l00494">Database::getValue()</a>, <a class="el" href="groundpredicate_8h-source.html#l00202">GroundPredicate::print()</a>, <a class="el" href="array_8h-source.html#l00309">Array&lt; Type &gt;::removeAllNull()</a>, <a class="el" href="array_8h-source.html#l00344">Array&lt; Type &gt;::removeItemFastDisorder()</a>, <a class="el" href="hasharray_8h-source.html#l00312">HashArray&lt; Type, HashFn, EqualFn &gt;::removeItemFastDisorder()</a>, <a class="el" href="database_8h-source.html#l00646">Database::setValue()</a>, <a class="el" href="hasharray_8h-source.html#l00229">HashArray&lt; Type, HashFn, EqualFn &gt;::size()</a>, and <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.<div class="fragment"><pre class="fragment"><a name="l01898"></a>01898   {
<a name="l01899"></a>01899     <span class="keywordflow">if</span> (vsdebug)
<a name="l01900"></a>01900     {
<a name="l01901"></a>01901       cout &lt;&lt; <span class="stringliteral">"Setting to evidence "</span> ;
<a name="l01902"></a>01902       predicate-&gt;<a class="code" href="classGroundPredicate.html#d8291702c56dbceed35016b052f38f38">print</a>(cout, domain_);
<a name="l01903"></a>01903       cout &lt;&lt; endl;
<a name="l01904"></a>01904     }
<a name="l01905"></a>01905     <a class="code" href="classDatabase.html">Database</a>* db = domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>();
<a name="l01906"></a>01906     <span class="keywordtype">int</span> atomIdx = gndPredHashArray_.<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>((<a class="code" href="classGroundPredicate.html">GroundPredicate</a>*)predicate);
<a name="l01907"></a>01907       <span class="comment">// If already evidence, then check its truth value</span>
<a name="l01908"></a>01908     <span class="keywordflow">if</span> (atomIdx &lt;= 0)
<a name="l01909"></a>01909     {
<a name="l01910"></a>01910         <span class="comment">// If predicate already evidence with same truth value, then do nothing</span>
<a name="l01911"></a>01911       <span class="keywordflow">if</span> (db-&gt;<a class="code" href="classDatabase.html#599fbc0b7e396c424f747a4c8bedd25e">getValue</a>(predicate) == trueEvidence)
<a name="l01912"></a>01912         <span class="keywordflow">return</span>;
<a name="l01913"></a>01913         
<a name="l01914"></a>01914         <span class="comment">// Changing truth value of evidence</span>
<a name="l01915"></a>01915       <span class="keywordflow">if</span> (trueEvidence)
<a name="l01916"></a>01916         db-&gt;<a class="code" href="classDatabase.html#55bde3da38b3b555e9897d860dfff500">setValue</a>(predicate, TRUE);
<a name="l01917"></a>01917       <span class="keywordflow">else</span>
<a name="l01918"></a>01918         db-&gt;<a class="code" href="classDatabase.html#55bde3da38b3b555e9897d860dfff500">setValue</a>(predicate, FALSE);
<a name="l01919"></a>01919     }
<a name="l01920"></a>01920     <span class="keywordflow">else</span>
<a name="l01921"></a>01921     {
<a name="l01922"></a>01922       <a class="code" href="classArray.html">Array&lt;int&gt;</a> gndClauseIndexes;      
<a name="l01923"></a>01923       gndClauseIndexes = <a class="code" href="classVariableState.html#97f47d59c8ce2f05e2e32c52cadd87c4">getNegOccurenceArray</a>(atomIdx + 1);
<a name="l01924"></a>01924       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndClauseIndexes.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01925"></a>01925       {
<a name="l01926"></a>01926           <span class="comment">// Atom appears neg. in these clauses, so remove the atom from</span>
<a name="l01927"></a>01927           <span class="comment">// these clauses if true evidence, or remove clause if false evidence</span>
<a name="l01928"></a>01928           <span class="comment">// or a unit clause</span>
<a name="l01929"></a>01929         <span class="keywordflow">if</span> (!trueEvidence ||
<a name="l01930"></a>01930             (*gndClauses_)[gndClauseIndexes[i]]-&gt;getNumGroundPredicates() == 1)
<a name="l01931"></a>01931         {          
<a name="l01932"></a>01932           <span class="keywordflow">if</span> (vsdebug)
<a name="l01933"></a>01933             cout &lt;&lt; <span class="stringliteral">"Deleting ground clause "</span> &lt;&lt; gndClauseIndexes[i] &lt;&lt; endl;
<a name="l01934"></a>01934           <span class="keyword">delete</span> (*gndClauses_)[gndClauseIndexes[i]];
<a name="l01935"></a>01935           (*gndClauses_)[gndClauseIndexes[i]] = NULL;
<a name="l01936"></a>01936         }
<a name="l01937"></a>01937         <span class="keywordflow">else</span>
<a name="l01938"></a>01938         {
<a name="l01939"></a>01939           <span class="keywordflow">if</span> (vsdebug)
<a name="l01940"></a>01940           {
<a name="l01941"></a>01941             cout &lt;&lt; <span class="stringliteral">"Removing gnd pred "</span> &lt;&lt; -(atomIdx + 1)
<a name="l01942"></a>01942                  &lt;&lt; <span class="stringliteral">" from ground clause "</span> &lt;&lt; gndClauseIndexes[i] &lt;&lt; endl;
<a name="l01943"></a>01943           }
<a name="l01944"></a>01944           (*gndClauses_)[gndClauseIndexes[i]]-&gt;removeGndPred(-(atomIdx + 1));
<a name="l01945"></a>01945         }
<a name="l01946"></a>01946       }
<a name="l01947"></a>01947 
<a name="l01948"></a>01948       gndClauseIndexes = <a class="code" href="classVariableState.html#472841bdbf016395d0c6a8fc43f220ff">getPosOccurenceArray</a>(atomIdx + 1);
<a name="l01949"></a>01949       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; gndClauseIndexes.<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l01950"></a>01950       {
<a name="l01951"></a>01951           <span class="comment">// Atom appears pos. in these clauses, so remove the atom from</span>
<a name="l01952"></a>01952           <span class="comment">// these clauses if false evidence, or remove clause if true evidence</span>
<a name="l01953"></a>01953           <span class="comment">// or a unit clause</span>
<a name="l01954"></a>01954         <span class="keywordflow">if</span> (trueEvidence ||
<a name="l01955"></a>01955             (*gndClauses_)[gndClauseIndexes[i]]-&gt;getNumGroundPredicates() == 1)
<a name="l01956"></a>01956         {
<a name="l01957"></a>01957           <span class="keywordflow">if</span> (vsdebug)
<a name="l01958"></a>01958             cout &lt;&lt; <span class="stringliteral">"Deleting ground clause "</span> &lt;&lt; gndClauseIndexes[i] &lt;&lt; endl;
<a name="l01959"></a>01959           <span class="keyword">delete</span> (*gndClauses_)[gndClauseIndexes[i]];
<a name="l01960"></a>01960           (*gndClauses_)[gndClauseIndexes[i]] = NULL;
<a name="l01961"></a>01961         }
<a name="l01962"></a>01962         <span class="keywordflow">else</span>
<a name="l01963"></a>01963         {
<a name="l01964"></a>01964           <span class="keywordflow">if</span> (vsdebug)
<a name="l01965"></a>01965           {
<a name="l01966"></a>01966             cout &lt;&lt; <span class="stringliteral">"Removing gnd pred "</span> &lt;&lt; -(atomIdx + 1)
<a name="l01967"></a>01967                  &lt;&lt; <span class="stringliteral">" from ground clause "</span> &lt;&lt; gndClauseIndexes[i] &lt;&lt; endl;
<a name="l01968"></a>01968           }
<a name="l01969"></a>01969           (*gndClauses_)[gndClauseIndexes[i]]-&gt;removeGndPred(atomIdx + 1);
<a name="l01970"></a>01970         }
<a name="l01971"></a>01971       }
<a name="l01972"></a>01972       
<a name="l01973"></a>01973       gndPredHashArray_.<a class="code" href="classHashArray.html#e5e111447c99c8bec8dcb007e9b7816b">removeItemFastDisorder</a>(atomIdx);
<a name="l01974"></a>01974       gndPredHashArray_.<a class="code" href="classHashArray.html#e113aa6f71b16def86aa32bbc2fee334">compress</a>();
<a name="l01975"></a>01975       gndPreds_-&gt;<a class="code" href="classArray.html#f3a485906b00ac44e39f0d402bd09512">removeItemFastDisorder</a>(atomIdx);
<a name="l01976"></a>01976       gndPreds_-&gt;<a class="code" href="classArray.html#d076eab62161d62c67aadebcc71e5cb2">compress</a>();
<a name="l01977"></a>01977         <span class="comment">// By removing a pred, the pred at the end of the array gets the</span>
<a name="l01978"></a>01978         <span class="comment">// index of the pred deleted, so we have to update to the new index</span>
<a name="l01979"></a>01979         <span class="comment">// in all clauses</span>
<a name="l01980"></a>01980       <span class="keywordtype">int</span> oldIdx = gndPredHashArray_.<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>();
<a name="l01981"></a>01981       replaceAtomIndexInAllClauses(oldIdx, atomIdx);      
<a name="l01982"></a>01982       gndClauses_-&gt;<a class="code" href="classArray.html#9b58ce1b5d1283b76e2f11de7bf96657">removeAllNull</a>();
<a name="l01983"></a>01983     }
<a name="l01984"></a>01984   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="dfe0128b21fb28fcfd5a2796bc17eced"></a><!-- doxytag: member="VariableState::setAsQuery" ref="dfe0128b21fb28fcfd5a2796bc17eced" args="(const GroundPredicate *const &amp;predicate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::setAsQuery           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGroundPredicate.html">GroundPredicate</a> *const &amp;&nbsp;</td>
          <td class="paramname"> <em>predicate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a <a class="el" href="classGroundPredicate.html">GroundPredicate</a> to be query. 
<p>
If it is already present as query, then nothing happens. If the predicate was evidence, then additional clauses may be added. <a class="el" href="classVariableState.html#a8f619357092cf7e5ac33d76c9e89afc">reinit()</a> should be called after this in order to ensure that the clause and atom information is correct.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>predicate</em>&nbsp;</td><td><a class="el" href="classGroundPredicate.html">GroundPredicate</a> to be set as a query. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l01994">1994</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="hasharray_8h-source.html#l00119">HashArray&lt; Type, HashFn, EqualFn &gt;::append()</a>, <a class="el" href="hasharray_8h-source.html#l00269">HashArray&lt; Type, HashFn, EqualFn &gt;::contains()</a>, <a class="el" href="variablestate_8h-source.html#l02101">getActiveClauses()</a>, <a class="el" href="domain_8h-source.html#l00311">Domain::getDB()</a>, <a class="el" href="groundpredicate_8h-source.html#l00202">GroundPredicate::print()</a>, and <a class="el" href="database_8h-source.html#l00789">Database::setEvidenceStatus()</a>.<div class="fragment"><pre class="fragment"><a name="l01995"></a>01995   {
<a name="l01996"></a>01996     <span class="keywordflow">if</span> (vsdebug)
<a name="l01997"></a>01997     {
<a name="l01998"></a>01998       cout &lt;&lt; <span class="stringliteral">"Setting to query "</span> ;
<a name="l01999"></a>01999       predicate-&gt;<a class="code" href="classGroundPredicate.html#d8291702c56dbceed35016b052f38f38">print</a>(cout, domain_);
<a name="l02000"></a>02000       cout &lt;&lt; endl;
<a name="l02001"></a>02001     }
<a name="l02002"></a>02002     <a class="code" href="classDatabase.html">Database</a>* db = domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>();
<a name="l02003"></a>02003       <span class="comment">// If already non-evidence, then do nothing</span>
<a name="l02004"></a>02004     <span class="keywordflow">if</span> (gndPredHashArray_.<a class="code" href="classHashArray.html#7ef36132544b3d97362a9216a0e04c87">contains</a>((<a class="code" href="classGroundPredicate.html">GroundPredicate</a>*)predicate))
<a name="l02005"></a>02005       <span class="keywordflow">return</span>;
<a name="l02006"></a>02006     <span class="keywordflow">else</span>
<a name="l02007"></a>02007     {
<a name="l02008"></a>02008         <span class="comment">// Evidence -&gt; query</span>
<a name="l02009"></a>02009         <span class="comment">// Add predicate to query set and get clauses</span>
<a name="l02010"></a>02010       gndPredHashArray_.<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>((<a class="code" href="classGroundPredicate.html">GroundPredicate</a>*)predicate);
<a name="l02011"></a>02011       <a class="code" href="classPredicate.html">Predicate</a>* p = predicate-&gt;createEquivalentPredicate(domain_);
<a name="l02012"></a>02012       db-&gt;<a class="code" href="classDatabase.html#03711a23747b17d9465cd5d443900f21">setEvidenceStatus</a>(p, <span class="keyword">false</span>);
<a name="l02013"></a>02013       <span class="keywordtype">bool</span> ignoreActivePreds = <span class="keyword">true</span>;
<a name="l02014"></a>02014       <a class="code" href="classVariableState.html#1944a7ef1d312dab635ad19801ba13f7">getActiveClauses</a>(p, newClauses_, <span class="keyword">true</span>, ignoreActivePreds);
<a name="l02015"></a>02015     }
<a name="l02016"></a>02016   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e25d7b335279bab8def1c7ed12d29ffa"></a><!-- doxytag: member="VariableState::getGndPred" ref="e25d7b335279bab8def1c7ed12d29ffa" args="(const int &amp;index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGroundPredicate.html">GroundPredicate</a>* VariableState::getGndPred           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a pointer to a <a class="el" href="classGroundPredicate.html">GroundPredicate</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index of the <a class="el" href="classGroundPredicate.html">GroundPredicate</a> to be retrieved. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the <a class="el" href="classGroundPredicate.html">GroundPredicate</a> </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l02026">2026</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
Referenced by <a class="el" href="mcmc_8h-source.html#l00314">MCMC::getProbabilityOfPred()</a>, <a class="el" href="mcmc_8h-source.html#l00661">MCMC::gndPredFlippedUpdates()</a>, <a class="el" href="simulatedtempering_8h-source.html#l00199">SimulatedTempering::infer()</a>, <a class="el" href="mcsat_8h-source.html#l00143">MCSAT::infer()</a>, <a class="el" href="gibbssampler_8h-source.html#l00159">GibbsSampler::infer()</a>, and <a class="el" href="mcmc_8h-source.html#l00364">MCMC::performGibbsStep()</a>.<div class="fragment"><pre class="fragment"><a name="l02027"></a>02027   {
<a name="l02028"></a>02028     <span class="keywordflow">return</span> (*gndPreds_)[index];
<a name="l02029"></a>02029   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="cfd4c00140b2adacfe5113d35b79f71d"></a><!-- doxytag: member="VariableState::getGndClause" ref="cfd4c00140b2adacfe5113d35b79f71d" args="(const int &amp;index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGroundClause.html">GroundClause</a>* VariableState::getGndClause           </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a pointer to a <a class="el" href="classGroundClause.html">GroundClause</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>Index of the <a class="el" href="classGroundClause.html">GroundClause</a> to be retrieved. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to the <a class="el" href="classGroundClause.html">GroundClause</a> </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l02037">2037</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
Referenced by <a class="el" href="mcmc_8h-source.html#l00661">MCMC::gndPredFlippedUpdates()</a>, <a class="el" href="mcmc_8h-source.html#l00230">MCMC::initNumTrueLits()</a>, and <a class="el" href="mcmc_8h-source.html#l00488">MCMC::updateWtsForGndPreds()</a>.<div class="fragment"><pre class="fragment"><a name="l02038"></a>02038   {
<a name="l02039"></a>02039     <span class="keywordflow">return</span> (*gndClauses_)[index];
<a name="l02040"></a>02040   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="df5999e531cf4de1350b46df789e0c81"></a><!-- doxytag: member="VariableState::getGndPredIndex" ref="df5999e531cf4de1350b46df789e0c81" args="(GroundPredicate *const &amp;gndPred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int VariableState::getGndPredIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGroundPredicate.html">GroundPredicate</a> *const &amp;&nbsp;</td>
          <td class="paramname"> <em>gndPred</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the index of a <a class="el" href="classGroundPredicate.html">GroundPredicate</a> in this state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gndPred</em>&nbsp;</td><td><a class="el" href="classGroundPredicate.html">GroundPredicate</a> whose index is being found. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Index of the <a class="el" href="classGroundPredicate.html">GroundPredicate</a>, if found; otherwise -1. </dd></dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l02077">2077</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="array_8h-source.html#l00273">Array&lt; Type &gt;::find()</a>.
<p>
Referenced by <a class="el" href="unitpropagation_8h-source.html#l00186">UnitPropagation::getProbability()</a>, <a class="el" href="sat_8h-source.html#l00145">SAT::getProbability()</a>, and <a class="el" href="mcmc_8h-source.html#l00157">MCMC::getProbability()</a>.<div class="fragment"><pre class="fragment"><a name="l02078"></a>02078   {
<a name="l02079"></a>02079     <span class="keywordflow">return</span> gndPreds_-&gt;<a class="code" href="classArray.html#e5a7703acd6b54d55cd7c95b68262b09">find</a>(gndPred);
<a name="l02080"></a>02080   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1944a7ef1d312dab635ad19801ba13f7"></a><!-- doxytag: member="VariableState::getActiveClauses" ref="1944a7ef1d312dab635ad19801ba13f7" args="(Predicate *inputPred, Array&lt; GroundClause * &gt; &amp;activeClauses, bool const &amp;active, bool const &amp;ignoreActivePreds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::getActiveClauses           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPredicate.html">Predicate</a> *&nbsp;</td>
          <td class="paramname"> <em>inputPred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArray.html">Array</a>&lt; <a class="el" href="classGroundClause.html">GroundClause</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>activeClauses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const &amp;&nbsp;</td>
          <td class="paramname"> <em>active</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const &amp;&nbsp;</td>
          <td class="paramname"> <em>ignoreActivePreds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets clauses and weights activated by the predicate inputPred, if active is true. 
<p>
If false, inactive clauses (and their weights) containing inputPred are retrieved. If inputPred is NULL, then all active (or inactive) clauses and their weights are retrieved.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inputPred</em>&nbsp;</td><td>Only clauses containing this <a class="el" href="classPredicate.html">Predicate</a> are looked at. If NULL, then all active clauses are retrieved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>activeClauses</em>&nbsp;</td><td>New active clauses are put here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>active</em>&nbsp;</td><td>If true, active clauses are retrieved, otherwise inactive. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ignoreActivePreds</em>&nbsp;</td><td>If true, active preds are not taken into account. This results in the retrieval of all unsatisfied clauses. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l02101">2101</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="array_8h-source.html#l00153">Array&lt; Type &gt;::append()</a>, <a class="el" href="hasharray_8h-source.html#l00119">HashArray&lt; Type, HashFn, EqualFn &gt;::append()</a>, <a class="el" href="groundclause_8h-source.html#l00173">GroundClause::appendParentWtPtr()</a>, <a class="el" href="groundclause_8cpp-source.html#l00124">GroundClause::appendToGndPreds()</a>, <a class="el" href="array_8h-source.html#l00215">Array&lt; Type &gt;::clear()</a>, <a class="el" href="hasharray_8h-source.html#l00260">HashArray&lt; Type, HashFn, EqualFn &gt;::find()</a>, <a class="el" href="mln_8h-source.html#l00336">MLN::findClauseIdx()</a>, <a class="el" href="clause_8h-source.html#l02590">Clause::getActiveClauses()</a>, <a class="el" href="mln_8h-source.html#l00350">MLN::getClause()</a>, <a class="el" href="mln_8h-source.html#l00576">MLN::getClausesContainingPred()</a>, <a class="el" href="domain_8h-source.html#l00311">Domain::getDB()</a>, <a class="el" href="database_8h-source.html#l00574">Database::getDeactivatedStatus()</a>, <a class="el" href="predicate_8h-source.html#l00274">Predicate::getId()</a>, <a class="el" href="mln_8h-source.html#l00100">MLN::getNumClauses()</a>, <a class="el" href="groundclause_8h-source.html#l00138">GroundClause::getWt()</a>, <a class="el" href="clause_8h-source.html#l00258">Clause::getWt()</a>, <a class="el" href="clause_8h-source.html#l00260">Clause::getWtPtr()</a>, <a class="el" href="groundclause_8h-source.html#l00203">GroundClause::incrementClauseFrequency()</a>, <a class="el" href="clause_8h-source.html#l00312">Clause::isHardClause()</a>, <a class="el" href="groundclause_8cpp-source.html#l00147">GroundClause::print()</a>, <a class="el" href="clause_8h-source.html#l00662">Clause::print()</a>, <a class="el" href="groundclause_8h-source.html#l00135">GroundClause::setWt()</a>, <a class="el" href="hasharray_8h-source.html#l00229">HashArray&lt; Type, HashFn, EqualFn &gt;::size()</a>, and <a class="el" href="array_8h-source.html#l00240">Array&lt; Type &gt;::size()</a>.
<p>
Referenced by <a class="el" href="variablestate_8h-source.html#l00978">activateAtom()</a>, <a class="el" href="variablestate_8h-source.html#l02213">getActiveClauses()</a>, <a class="el" href="variablestate_8h-source.html#l01994">setAsQuery()</a>, and <a class="el" href="variablestate_8h-source.html#l00115">VariableState()</a>.<div class="fragment"><pre class="fragment"><a name="l02105"></a>02105   {
<a name="l02106"></a>02106     <a class="code" href="classClause.html">Clause</a> *fclause;
<a name="l02107"></a>02107     <a class="code" href="classGroundClause.html">GroundClause</a>* newClause;
<a name="l02108"></a>02108     <span class="keywordtype">int</span> clauseCnt;
<a name="l02109"></a>02109     <a class="code" href="classHashArray.html">GroundClauseHashArray</a> clauseHashArray;
<a name="l02110"></a>02110 
<a name="l02111"></a>02111     <a class="code" href="classArray.html">Array&lt;GroundClause*&gt;</a>* newClauses = <span class="keyword">new</span> <a class="code" href="classArray.html">Array&lt;GroundClause*&gt;</a>; 
<a name="l02112"></a>02112   
<a name="l02113"></a>02113     <span class="keyword">const</span> <a class="code" href="classArray.html">Array&lt;IndexClause*&gt;</a>* indexClauses = NULL;
<a name="l02114"></a>02114       
<a name="l02115"></a>02115       <span class="comment">// inputPred is null: all active clauses should be retrieved</span>
<a name="l02116"></a>02116     <span class="keywordflow">if</span> (inputPred == NULL)
<a name="l02117"></a>02117     {
<a name="l02118"></a>02118       clauseCnt = mln_-&gt;<a class="code" href="classMLN.html#9af698a87c5b518e9ce18755bc414231">getNumClauses</a>();
<a name="l02119"></a>02119     }
<a name="l02120"></a>02120       <span class="comment">// Otherwise, look at all first order clauses containing the pred</span>
<a name="l02121"></a>02121     <span class="keywordflow">else</span>
<a name="l02122"></a>02122     {
<a name="l02123"></a>02123       <span class="keywordflow">if</span> (domain_-&gt;<a class="code" href="classDomain.html#732940c3a6c4064099aaf353513b553f">getDB</a>()-&gt;<a class="code" href="classDatabase.html#1c459bc03d0e73b3d51eafae6b9d5151">getDeactivatedStatus</a>(inputPred)) <span class="keywordflow">return</span>;
<a name="l02124"></a>02124       <span class="keywordtype">int</span> predId = inputPred-&gt;<a class="code" href="classPredicate.html#bf7ace41fac6ed9b6c68bb29a1c95445">getId</a>();
<a name="l02125"></a>02125       indexClauses = mln_-&gt;<a class="code" href="classMLN.html#fe5ab9aa70237fbbfa70541d90619eeb">getClausesContainingPred</a>(predId);
<a name="l02126"></a>02126       clauseCnt = indexClauses-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>();
<a name="l02127"></a>02127     }
<a name="l02128"></a>02128 
<a name="l02129"></a>02129       <span class="comment">// Look at each first-order clause and get active groundings</span>
<a name="l02130"></a>02130     <span class="keywordtype">int</span> clauseno = 0;
<a name="l02131"></a>02131     <span class="keywordflow">while</span> (clauseno &lt; clauseCnt)
<a name="l02132"></a>02132     {
<a name="l02133"></a>02133       <span class="keywordflow">if</span> (inputPred)
<a name="l02134"></a>02134         fclause = (<a class="code" href="classClause.html">Clause</a> *) (*indexClauses)[clauseno]-&gt;clause;           
<a name="l02135"></a>02135       <span class="keywordflow">else</span>
<a name="l02136"></a>02136         fclause = (<a class="code" href="classClause.html">Clause</a> *) mln_-&gt;<a class="code" href="classMLN.html#497ce3f0fc49d215ab278a4a285e161e">getClause</a>(clauseno);
<a name="l02137"></a>02137 
<a name="l02138"></a>02138       <span class="keywordflow">if</span> (vsdebug)
<a name="l02139"></a>02139       {
<a name="l02140"></a>02140         cout &lt;&lt; <span class="stringliteral">"Getting active clauses for FO clause: "</span>;
<a name="l02141"></a>02141         fclause-&gt;<a class="code" href="classClause.html#c7ca63adf8f409bb95159f428a2439b7">print</a>(cout, domain_);
<a name="l02142"></a>02142         cout &lt;&lt; endl;
<a name="l02143"></a>02143       }
<a name="l02144"></a>02144       
<a name="l02145"></a>02145       <span class="keywordtype">long</span> <span class="keywordtype">double</span> wt = fclause-&gt;<a class="code" href="classClause.html#e234aafdd6eb6df9db924e254d13f12e">getWt</a>();
<a name="l02146"></a>02146       <span class="keyword">const</span> <span class="keywordtype">double</span>* parentWtPtr = NULL;
<a name="l02147"></a>02147       <span class="keywordflow">if</span> (!fclause-&gt;<a class="code" href="classClause.html#7eb908b452f9e428fc05cc22501c5cb8">isHardClause</a>()) parentWtPtr = fclause-&gt;<a class="code" href="classClause.html#be9f5a3ccd9ec0b6c92ecb26d3e7323e">getWtPtr</a>();
<a name="l02148"></a>02148       <span class="keyword">const</span> <span class="keywordtype">int</span> clauseId = mln_-&gt;<a class="code" href="classMLN.html#e7dd082d7dce234cab11adfc3a83be1a">findClauseIdx</a>(fclause);
<a name="l02149"></a>02149       newClauses-&gt;<a class="code" href="classArray.html#732046291e31f830757e0847280fb593">clear</a>();
<a name="l02150"></a>02150 
<a name="l02151"></a>02151       fclause-&gt;<a class="code" href="classClause.html#e7d9bdbce92ec00ea4fcd71c4106b1d5">getActiveClauses</a>(inputPred, domain_, newClauses,
<a name="l02152"></a>02152                                 &amp;gndPredHashArray_, ignoreActivePreds);
<a name="l02153"></a>02153 
<a name="l02154"></a>02154       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; newClauses-&gt;<a class="code" href="classArray.html#d7a2ae7ae5e0d02cd7d4d9e2f696379e">size</a>(); i++)
<a name="l02155"></a>02155       {
<a name="l02156"></a>02156         newClause = (*newClauses)[i];
<a name="l02157"></a>02157         <span class="keywordtype">int</span> pos = clauseHashArray.<a class="code" href="classHashArray.html#3a29d73618fa8d216ca8342b6b1bac89">find</a>(newClause);
<a name="l02158"></a>02158           <span class="comment">// If clause already present, then just add weight</span>
<a name="l02159"></a>02159         <span class="keywordflow">if</span> (pos &gt;= 0)
<a name="l02160"></a>02160         {
<a name="l02161"></a>02161           <span class="keywordflow">if</span> (vsdebug)
<a name="l02162"></a>02162           {
<a name="l02163"></a>02163             cout &lt;&lt; <span class="stringliteral">"Adding weight "</span> &lt;&lt; wt &lt;&lt; <span class="stringliteral">" to clause "</span>;
<a name="l02164"></a>02164             clauseHashArray[pos]-&gt;print(cout, domain_, &amp;gndPredHashArray_);
<a name="l02165"></a>02165             cout &lt;&lt; endl;
<a name="l02166"></a>02166           }
<a name="l02167"></a>02167           clauseHashArray[pos]-&gt;addWt(wt);
<a name="l02168"></a>02168           <span class="keywordflow">if</span> (parentWtPtr)
<a name="l02169"></a>02169           {
<a name="l02170"></a>02170             clauseHashArray[pos]-&gt;appendParentWtPtr(parentWtPtr);
<a name="l02171"></a>02171             clauseHashArray[pos]-&gt;incrementClauseFrequency(clauseId, 1);
<a name="l02172"></a>02172           }
<a name="l02173"></a>02173           <span class="keyword">delete</span> newClause;
<a name="l02174"></a>02174           <span class="keywordflow">continue</span>;
<a name="l02175"></a>02175         }
<a name="l02176"></a>02176 
<a name="l02177"></a>02177           <span class="comment">// If here, then clause is not yet present        </span>
<a name="l02178"></a>02178         newClause-&gt;<a class="code" href="classGroundClause.html#87aa563d0f712f7481ece8b8d7551a47">setWt</a>(wt);
<a name="l02179"></a>02179         newClause-&gt;<a class="code" href="classGroundClause.html#b2bc8fac453a33ecc45d199cf080b7c9">appendToGndPreds</a>(&amp;gndPredHashArray_);
<a name="l02180"></a>02180         <span class="keywordflow">if</span> (parentWtPtr)
<a name="l02181"></a>02181         {
<a name="l02182"></a>02182           newClause-&gt;<a class="code" href="classGroundClause.html#57fa4005be94e9f87517ffced6a36d1b">appendParentWtPtr</a>(parentWtPtr);
<a name="l02183"></a>02183           newClause-&gt;<a class="code" href="classGroundClause.html#5949e09d289c58be8dac58b4e2162e6b">incrementClauseFrequency</a>(clauseId, 1);
<a name="l02184"></a>02184           assert(newClause-&gt;<a class="code" href="classGroundClause.html#7fed23e12512496e45056fbc5e624a23">getWt</a>() == *parentWtPtr);
<a name="l02185"></a>02185         }      
<a name="l02186"></a>02186 
<a name="l02187"></a>02187         <span class="keywordflow">if</span> (vsdebug)
<a name="l02188"></a>02188         {
<a name="l02189"></a>02189           cout &lt;&lt; <span class="stringliteral">"Appending clause "</span>;
<a name="l02190"></a>02190           newClause-&gt;<a class="code" href="classGroundClause.html#5300f9943f0e43994822ca482f7cd5ed">print</a>(cout, domain_, &amp;gndPredHashArray_);
<a name="l02191"></a>02191           cout &lt;&lt; endl;
<a name="l02192"></a>02192         }
<a name="l02193"></a>02193         clauseHashArray.<a class="code" href="classHashArray.html#5b55b617cd22fd9e0557de4d15a608be">append</a>(newClause);
<a name="l02194"></a>02194       }
<a name="l02195"></a>02195       clauseno++; 
<a name="l02196"></a>02196     } <span class="comment">//while (clauseno &lt; clauseCnt)</span>
<a name="l02197"></a>02197 
<a name="l02198"></a>02198     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; clauseHashArray.<a class="code" href="classHashArray.html#ccdf0d4f7188821cd872b1618312fbd0">size</a>(); i++)
<a name="l02199"></a>02199     {
<a name="l02200"></a>02200       newClause = clauseHashArray[i];
<a name="l02201"></a>02201       activeClauses.<a class="code" href="classArray.html#752db599431d93ee14c5b0f7b05ba03a">append</a>(newClause);
<a name="l02202"></a>02202     }
<a name="l02203"></a>02203     <span class="keyword">delete</span> newClauses;
<a name="l02204"></a>02204   }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="879c6333edb862b00e2a3550fce77e1f"></a><!-- doxytag: member="VariableState::getActiveClauses" ref="879c6333edb862b00e2a3550fce77e1f" args="(Array&lt; GroundClause * &gt; &amp;allClauses, bool const &amp;ignoreActivePreds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VariableState::getActiveClauses           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray.html">Array</a>&lt; <a class="el" href="classGroundClause.html">GroundClause</a> * &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>allClauses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const &amp;&nbsp;</td>
          <td class="paramname"> <em>ignoreActivePreds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get all the active clauses in the database. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>allClauses</em>&nbsp;</td><td>Active clauses are retrieved into this <a class="el" href="classArray.html">Array</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ignoreActivePreds</em>&nbsp;</td><td>If true, active preds are ignored; this means all unsatisfied clauses are retrieved. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="variablestate_8h-source.html#l02213">2213</a> of file <a class="el" href="variablestate_8h-source.html">variablestate.h</a>.
<p>
References <a class="el" href="variablestate_8h-source.html#l02101">getActiveClauses()</a>.<div class="fragment"><pre class="fragment"><a name="l02215"></a>02215   {
<a name="l02216"></a>02216     <a class="code" href="classVariableState.html#1944a7ef1d312dab635ad19801ba13f7">getActiveClauses</a>(NULL, allClauses, <span class="keyword">true</span>, ignoreActivePreds);
<a name="l02217"></a>02217   }
</pre></div>
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>src/logic/<a class="el" href="variablestate_8h-source.html">variablestate.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Feb 14 15:15:22 2007 for Alchemy by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
